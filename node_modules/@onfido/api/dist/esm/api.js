/* tslint:disable */
/* eslint-disable */
/**
 * Onfido API v3.6
 * The Onfido API (v3.6)
 *
 * The version of the OpenAPI document: v3.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, operationServerMap } from './base';
import { FileTransfer } from './file-transfer';
import { AxiosHeaders } from 'axios';
globalAxios.interceptors.response.use((response) => __awaiter(void 0, void 0, void 0, function* () {
    if (response.headers instanceof AxiosHeaders && response.headers['content-type']) {
        if (!response.headers['content-type'].toString().includes('application/json')) {
            const contentDisposition = response.headers['content-disposition'];
            var filename = "";
            if (contentDisposition && contentDisposition != "") {
                const matcher = contentDisposition.match(/filename=['\"]?([^'\"\s]+)['\"]?/);
                if (matcher != null) {
                    filename = matcher[1].replace(/.*[/\\\\]/g, "");
                }
            }
            response.data = new FileTransfer(response.data, filename);
        }
    }
    return response;
}));
/**
 *
 * @export
 * @enum {string}
 */
export const ApplicantConsentName = {
    PrivacyNoticesRead: 'privacy_notices_read',
    SsnVerification: 'ssn_verification',
    PhoneNumberVerification: 'phone_number_verification',
    UnknownDefaultOpenApi: '11184809'
};
export const CheckResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
};
export const CheckResponseResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The current state of the check in the checking process.
 * @export
 * @enum {string}
 */
export const CheckStatus = {
    InProgress: 'in_progress',
    AwaitingApplicant: 'awaiting_applicant',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    Paused: 'paused',
    Reopened: 'reopened',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
export const CountryCodes = {
    Abw: 'ABW',
    Afg: 'AFG',
    Ago: 'AGO',
    Aia: 'AIA',
    Ala: 'ALA',
    Alb: 'ALB',
    And: 'AND',
    Are: 'ARE',
    Arg: 'ARG',
    Arm: 'ARM',
    Asm: 'ASM',
    Ata: 'ATA',
    Atf: 'ATF',
    Atg: 'ATG',
    Aus: 'AUS',
    Aut: 'AUT',
    Aze: 'AZE',
    Bdi: 'BDI',
    Bel: 'BEL',
    Ben: 'BEN',
    Bes: 'BES',
    Bfa: 'BFA',
    Bgd: 'BGD',
    Bgr: 'BGR',
    Bhr: 'BHR',
    Bhs: 'BHS',
    Bih: 'BIH',
    Blm: 'BLM',
    Blr: 'BLR',
    Blz: 'BLZ',
    Bmu: 'BMU',
    Bol: 'BOL',
    Bra: 'BRA',
    Brb: 'BRB',
    Brn: 'BRN',
    Btn: 'BTN',
    Bvt: 'BVT',
    Bwa: 'BWA',
    Caf: 'CAF',
    Can: 'CAN',
    Cck: 'CCK',
    Che: 'CHE',
    Chl: 'CHL',
    Chn: 'CHN',
    Civ: 'CIV',
    Cmr: 'CMR',
    Cod: 'COD',
    Cog: 'COG',
    Cok: 'COK',
    Col: 'COL',
    Com: 'COM',
    Cpv: 'CPV',
    Cri: 'CRI',
    Cub: 'CUB',
    Cuw: 'CUW',
    Cxr: 'CXR',
    Cym: 'CYM',
    Cyp: 'CYP',
    Cze: 'CZE',
    Deu: 'DEU',
    Dji: 'DJI',
    Dma: 'DMA',
    Dnk: 'DNK',
    Dom: 'DOM',
    Dza: 'DZA',
    Ecu: 'ECU',
    Egy: 'EGY',
    Eri: 'ERI',
    Esh: 'ESH',
    Esp: 'ESP',
    Est: 'EST',
    Eth: 'ETH',
    Fin: 'FIN',
    Fji: 'FJI',
    Flk: 'FLK',
    Fra: 'FRA',
    Fro: 'FRO',
    Fsm: 'FSM',
    Gab: 'GAB',
    Gbr: 'GBR',
    Geo: 'GEO',
    Ggy: 'GGY',
    Gha: 'GHA',
    Gib: 'GIB',
    Gin: 'GIN',
    Glp: 'GLP',
    Gmb: 'GMB',
    Gnb: 'GNB',
    Gnq: 'GNQ',
    Grc: 'GRC',
    Grd: 'GRD',
    Grl: 'GRL',
    Gtm: 'GTM',
    Guf: 'GUF',
    Gum: 'GUM',
    Guy: 'GUY',
    Hkg: 'HKG',
    Hmd: 'HMD',
    Hnd: 'HND',
    Hrv: 'HRV',
    Hti: 'HTI',
    Hun: 'HUN',
    Idn: 'IDN',
    Imn: 'IMN',
    Ind: 'IND',
    Iot: 'IOT',
    Irl: 'IRL',
    Irn: 'IRN',
    Irq: 'IRQ',
    Isl: 'ISL',
    Isr: 'ISR',
    Ita: 'ITA',
    Jam: 'JAM',
    Jey: 'JEY',
    Jor: 'JOR',
    Jpn: 'JPN',
    Kaz: 'KAZ',
    Ken: 'KEN',
    Kgz: 'KGZ',
    Khm: 'KHM',
    Kir: 'KIR',
    Kna: 'KNA',
    Kor: 'KOR',
    Kwt: 'KWT',
    Lao: 'LAO',
    Lbn: 'LBN',
    Lbr: 'LBR',
    Lby: 'LBY',
    Lca: 'LCA',
    Lie: 'LIE',
    Lka: 'LKA',
    Lso: 'LSO',
    Ltu: 'LTU',
    Lux: 'LUX',
    Lva: 'LVA',
    Mac: 'MAC',
    Maf: 'MAF',
    Mar: 'MAR',
    Mco: 'MCO',
    Mda: 'MDA',
    Mdg: 'MDG',
    Mdv: 'MDV',
    Mex: 'MEX',
    Mhl: 'MHL',
    Mkd: 'MKD',
    Mli: 'MLI',
    Mlt: 'MLT',
    Mmr: 'MMR',
    Mne: 'MNE',
    Mng: 'MNG',
    Mnp: 'MNP',
    Moz: 'MOZ',
    Mrt: 'MRT',
    Msr: 'MSR',
    Mtq: 'MTQ',
    Mus: 'MUS',
    Mwi: 'MWI',
    Mys: 'MYS',
    Myt: 'MYT',
    Nam: 'NAM',
    Ncl: 'NCL',
    Ner: 'NER',
    Nfk: 'NFK',
    Nga: 'NGA',
    Nic: 'NIC',
    Niu: 'NIU',
    Nld: 'NLD',
    Nor: 'NOR',
    Npl: 'NPL',
    Nru: 'NRU',
    Nzl: 'NZL',
    Omn: 'OMN',
    Pak: 'PAK',
    Pan: 'PAN',
    Pcn: 'PCN',
    Per: 'PER',
    Phl: 'PHL',
    Plw: 'PLW',
    Png: 'PNG',
    Pol: 'POL',
    Pri: 'PRI',
    Prk: 'PRK',
    Prt: 'PRT',
    Pry: 'PRY',
    Pse: 'PSE',
    Pyf: 'PYF',
    Qat: 'QAT',
    Reu: 'REU',
    Rks: 'RKS',
    Rou: 'ROU',
    Rus: 'RUS',
    Rwa: 'RWA',
    Sau: 'SAU',
    Sdn: 'SDN',
    Sen: 'SEN',
    Sgp: 'SGP',
    Sgs: 'SGS',
    Shn: 'SHN',
    Sjm: 'SJM',
    Slb: 'SLB',
    Sle: 'SLE',
    Slv: 'SLV',
    Smr: 'SMR',
    Som: 'SOM',
    Spm: 'SPM',
    Srb: 'SRB',
    Ssd: 'SSD',
    Stp: 'STP',
    Sur: 'SUR',
    Svk: 'SVK',
    Svn: 'SVN',
    Swe: 'SWE',
    Swz: 'SWZ',
    Sxm: 'SXM',
    Syc: 'SYC',
    Syr: 'SYR',
    Tca: 'TCA',
    Tcd: 'TCD',
    Tgo: 'TGO',
    Tha: 'THA',
    Tjk: 'TJK',
    Tkl: 'TKL',
    Tkm: 'TKM',
    Tls: 'TLS',
    Ton: 'TON',
    Tto: 'TTO',
    Tun: 'TUN',
    Tur: 'TUR',
    Tuv: 'TUV',
    Twn: 'TWN',
    Tza: 'TZA',
    Uga: 'UGA',
    Ukr: 'UKR',
    Umi: 'UMI',
    Ury: 'URY',
    Usa: 'USA',
    Uzb: 'UZB',
    Vat: 'VAT',
    Vct: 'VCT',
    Ven: 'VEN',
    Vgb: 'VGB',
    Vir: 'VIR',
    Vnm: 'VNM',
    Vut: 'VUT',
    Wlf: 'WLF',
    Wsm: 'WSM',
    Yem: 'YEM',
    Zaf: 'ZAF',
    Zmb: 'ZMB',
    Zwe: 'ZWE',
    UnknownDefaultOpenApi: '11184809'
};
export const DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum = {
    AndroidSdk: 'onfido-android-sdk',
    IosSdk: 'onfido-ios-sdk',
    WebSdk: 'onfido-web-sdk',
    UnknownDefaultOpenApi: '11184809'
};
export const DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum = {
    SdkToken: 'sdk_token',
    MobileToken: 'mobile_token',
    ApiToken: 'api_token',
    UnknownDefaultOpenApi: '11184809'
};
export const DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum = {
    NotEnoughData: 'NOT_ENOUGH_DATA',
    HighRisk: 'HIGH_RISK',
    LowRisk: 'LOW_RISK',
    UnknownDefaultOpenApi: '11184809'
};
export const DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum = {
    Live: 'live',
    UnknownMethod: 'unknown_method',
    UnknownDefaultOpenApi: '11184809'
};
export const DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum = {
    Live: 'live',
    UnknownMethod: 'unknown_method',
    UnknownDefaultOpenApi: '11184809'
};
export const DocumentSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
};
export const DocumentPropertiesNistIdentityEvidenceStrengthEnum = {
    Superior: 'superior',
    Strong: 'strong',
    Fair: 'fair',
    Weak: 'weak',
    Unacceptable: 'unacceptable',
    UnspecifiedIdentityEvidenceStrength: 'unspecified_identity_evidence_strength',
    UnknownDefaultOpenApi: '11184809'
};
export const DocumentPropertiesHasIssuanceConfirmationEnum = {
    True: 'true',
    False: 'false',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
};
export const DocumentPropertiesSecurityTierEnum = {
    Tier1: 'tier_1',
    Tier2: 'tier_2',
    Tier3: 'tier_3',
    Tier4: 'tier_4',
    Tier5: 'tier_5',
    UnspecifiedSecurityTier: 'unspecified_security_tier',
    UnknownDefaultOpenApi: '11184809'
};
export const DocumentSharedSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
export const DocumentTypes = {
    Passport: 'passport',
    DrivingLicence: 'driving_licence',
    NationalIdentityCard: 'national_identity_card',
    ResidencePermit: 'residence_permit',
    PassportCard: 'passport_card',
    TaxId: 'tax_id',
    Visa: 'visa',
    VoterId: 'voter_id',
    ResidenceStatusDocument: 'residence_status_document',
    PostalIdentityCard: 'postal_identity_card',
    SocialSecurityCard: 'social_security_card',
    WorkPermit: 'work_permit',
    AsylumRegistrationCard: 'asylum_registration_card',
    NationalHealthInsuranceCard: 'national_health_insurance_card',
    MunicipalityIdentityCard: 'municipality_identity_card',
    PrivateOperatorsCard: 'private_operators_card',
    ProofOfCitizenship: 'proof_of_citizenship',
    ServiceIdCard: 'service_id_card',
    ImmigrationStatusDocument: 'immigration_status_document',
    IndigenousCard: 'indigenous_card',
    VehicleRegistrationCard: 'vehicle_registration_card',
    CertificateOfNaturalisation: 'certificate_of_naturalisation',
    ProfessionalQualificationCard: 'professional_qualification_card',
    ConsularId: 'consular_id',
    InternationalDrivingLicence: 'international_driving_licence',
    HomeOfficeLetter: 'home_office_letter',
    BirthCertificate: 'birth_certificate',
    VehicleRegistrationCertificate: 'vehicle_registration_certificate',
    FormForAffixingTheVisa: 'form_for_affixing_the_visa',
    IdentificationNumberDocument: 'identification_number_document',
    AdoptionCertificate: 'adoption_certificate',
    BankBuildingSocietyStatement: 'bank_building_society_statement',
    BankStatement: 'bank_statement',
    BenefitLetters: 'benefit_letters',
    Cbt: 'cbt',
    CertificateOfSponsorship: 'certificate_of_sponsorship',
    CharacterReference: 'character_reference',
    CivilPartnershipCertificate: 'civil_partnership_certificate',
    CouncilTax: 'council_tax',
    CreditCardStatement: 'credit_card_statement',
    DeedPoll: 'deed_poll',
    DivorceAbsoluteDecree: 'divorce_absolute_decree',
    EducationalStatement: 'educational_statement',
    ElectricityBill: 'electricity_bill',
    GasBill: 'gas_bill',
    GovernmentLetter: 'government_letter',
    InternetBill: 'internet_bill',
    MarriageCertificate: 'marriage_certificate',
    MotorcycleInsurance: 'motorcycle_insurance',
    NationalInsuranceCard: 'national_insurance_card',
    NaturalisationCertificate: 'naturalisation_certificate',
    NonUkDrivingLicence: 'non_uk_driving_licence',
    P45P60: 'p45_p60',
    Payslip: 'payslip',
    PhoneBill: 'phone_bill',
    ProfessionalIdentificationCard: 'professional_identification_card',
    RightToWorkShareCodeResult: 'right_to_work_share_code_result',
    StatementFact: 'statement_fact',
    T4StudentUniversityTermDatesEvidence: 't4_student_university_term_dates_evidence',
    UkBiometricResidencePermit: 'uk_biometric_residence_permit',
    UkDrivingLicence: 'uk_driving_licence',
    Unknown: 'unknown',
    UtilityBill: 'utility_bill',
    UtilityBillElectric: 'utility_bill_electric',
    UtilityBillGas: 'utility_bill_gas',
    UtilityBillOther: 'utility_bill_other',
    WaterBill: 'water_bill',
    AddressCertificate: 'address_certificate',
    GeneralLetter: 'general_letter',
    InsuranceStatement: 'insurance_statement',
    PensionPropertyStatementLetter: 'pension_property_statement_letter',
    MortgageStatement: 'mortgage_statement',
    MobilePhoneBill: 'mobile_phone_bill',
    IdentityDocumentWithAddress: 'identity_document_with_address',
    ExchangeHouseStatement: 'exchange_house_statement',
    AccommodationTenancyCertificate: 'accommodation_tenancy_certificate',
    UnknownDefaultOpenApi: '11184809'
};
export const DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum = {
    Superior: 'superior',
    Strong: 'strong',
    Fair: 'fair',
    Weak: 'weak',
    Unacceptable: 'unacceptable',
    UnspecifiedIdentityEvidenceStrength: 'unspecified_identity_evidence_strength',
    UnknownDefaultOpenApi: '11184809'
};
export const DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum = {
    True: 'true',
    False: 'false',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
};
export const DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum = {
    Tier1: 'tier_1',
    Tier2: 'tier_2',
    Tier3: 'tier_3',
    Tier4: 'tier_4',
    Tier5: 'tier_5',
    UnspecifiedSecurityTier: 'unspecified_security_tier',
    UnknownDefaultOpenApi: '11184809'
};
export const ExtractionDocumentClassificationSubtypeEnum = {
    Full: 'full',
    NotFull: 'not_full',
    Provisional: 'provisional',
    UnknownDefaultOpenApi: '11184809'
};
export const ExtractionExtractedDataGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
};
export const IdNumberTypeEnum = {
    Ssn: 'ssn',
    SocialInsurance: 'social_insurance',
    TaxId: 'tax_id',
    IdentityCard: 'identity_card',
    DrivingLicense: 'driving_license',
    DrivingLicence: 'driving_licence',
    ShareCode: 'share_code',
    VoterId: 'voter_id',
    Passport: 'passport',
    Other: 'other',
    UnknownDefaultOpenApi: '11184809'
};
export const ProofOfAddressPropertiesDocumentTypeEnum = {
    BankBuildingSocietyStatement: 'bank_building_society_statement',
    UtilityBill: 'utility_bill',
    CouncilTax: 'council_tax',
    BenefitLetters: 'benefit_letters',
    MortgageStatement: 'mortgage_statement',
    MobilePhoneBill: 'mobile_phone_bill',
    GeneralLetter: 'general_letter',
    InsuranceStatement: 'insurance_statement',
    PensionPropertyStatementLetter: 'pension_property_statement_letter',
    IdentityDocumentWithAddress: 'identity_document_with_address',
    ExchangeHouseStatement: 'exchange_house_statement',
    UnknownDefaultOpenApi: '11184809'
};
export const RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum = {
    Match: 'match',
    Mismatch: 'mismatch',
    UnknownDefaultOpenApi: '11184809'
};
export const RepeatAttemptsListRepeatAttemptsInnerNamesEnum = {
    Match: 'match',
    Mismatch: 'mismatch',
    UnknownDefaultOpenApi: '11184809'
};
export const RepeatAttemptsListRepeatAttemptsInnerResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
export const ReportName = {
    Document: 'document',
    DocumentVideo: 'document_video',
    DocumentVideoWithAddressInformation: 'document_video_with_address_information',
    DocumentWithAddressInformation: 'document_with_address_information',
    DocumentWithDrivingLicenceInformation: 'document_with_driving_licence_information',
    DocumentWithDriverVerification: 'document_with_driver_verification',
    FacialSimilarityPhoto: 'facial_similarity_photo',
    FacialSimilarityPhotoFullyAuto: 'facial_similarity_photo_fully_auto',
    FacialSimilarityVideo: 'facial_similarity_video',
    FacialSimilarityMotion: 'facial_similarity_motion',
    KnownFaces: 'known_faces',
    IdentityEnhanced: 'identity_enhanced',
    WatchlistAml: 'watchlist_aml',
    WatchlistEnhanced: 'watchlist_enhanced',
    WatchlistStandard: 'watchlist_standard',
    WatchlistPepsOnly: 'watchlist_peps_only',
    WatchlistSanctionsOnly: 'watchlist_sanctions_only',
    ProofOfAddress: 'proof_of_address',
    UsDrivingLicence: 'us_driving_licence',
    DeviceIntelligence: 'device_intelligence',
    IndiaPan: 'india_pan',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The result of the report. Read-only.
 * @export
 * @enum {string}
 */
export const ReportResult = {
    Clear: 'clear',
    Consider: 'consider',
    Unidentified: 'unidentified',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The current state of the report in the checking process. Read-only.
 * @export
 * @enum {string}
 */
export const ReportStatus = {
    AwaitingData: 'awaiting_data',
    AwaitingApproval: 'awaiting_approval',
    Cancelled: 'cancelled',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The sub_result of the report. It gives a more detailed result for document reports only, and will be null otherwise. Read-only.
 * @export
 * @enum {string}
 */
export const ReportSubResult = {
    Clear: 'clear',
    Rejected: 'rejected',
    Suspected: 'suspected',
    Caution: 'caution',
    UnknownDefaultOpenApi: '11184809'
};
export const ResultsFeedbackExpectedResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
};
export const UsDrivingLicenceBuilderDocumentCategoryEnum = {
    DriverLicense: 'driver license',
    DriverPermit: 'driver permit',
    IdCard: 'id card',
    UnknownDefaultOpenApi: '11184809'
};
export const UsDrivingLicenceBuilderEyeColorCodeEnum = {
    Blk: 'BLK',
    Blu: 'BLU',
    Bro: 'BRO',
    Dic: 'DIC',
    Gry: 'GRY',
    Grn: 'GRN',
    Haz: 'HAZ',
    Mar: 'MAR',
    Pnk: 'PNK',
    UnknownDefaultOpenApi: '11184809'
};
export const UsDrivingLicenceBuilderGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
};
export const UsDrivingLicenceSharedDocumentCategoryEnum = {
    DriverLicense: 'driver license',
    DriverPermit: 'driver permit',
    IdCard: 'id card',
    UnknownDefaultOpenApi: '11184809'
};
export const UsDrivingLicenceSharedEyeColorCodeEnum = {
    Blk: 'BLK',
    Blu: 'BLU',
    Bro: 'BRO',
    Dic: 'DIC',
    Gry: 'GRY',
    Grn: 'GRN',
    Haz: 'HAZ',
    Mar: 'MAR',
    Pnk: 'PNK',
    UnknownDefaultOpenApi: '11184809'
};
export const UsDrivingLicenceSharedGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
};
export const WatchlistMonitorReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
};
export const WatchlistMonitorBuilderReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
};
export const WatchlistMonitorSharedReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The current state of the object, if available.
 * @export
 * @enum {string}
 */
export const WebhookEventObjectStatus = {
    Processing: 'processing',
    AwaitingInput: 'awaiting_input',
    AwaitingClientInput: 'awaiting_client_input',
    Approved: 'approved',
    Declined: 'declined',
    Review: 'review',
    Abandoned: 'abandoned',
    Error: 'error',
    Started: 'started',
    Cancelled: 'cancelled',
    Completed: 'completed',
    AwaitingData: 'awaiting_data',
    AwaitingApproval: 'awaiting_approval',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    InProgress: 'in_progress',
    AwaitingApplicant: 'awaiting_applicant',
    Paused: 'paused',
    Reopened: 'reopened',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
export const WebhookEventResourceType = {
    Check: 'check',
    Report: 'report',
    AuditLog: 'audit_log',
    WorkflowRun: 'workflow_run',
    WorkflowTask: 'workflow_task',
    WatchlistMonitor: 'watchlist_monitor',
    WorkflowTimelineFile: 'workflow_timeline_file',
    WorkflowRunEvidenceFolder: 'workflow_run_evidence_folder',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
export const WebhookEventType = {
    AuditLogCreated: 'audit_log.created',
    WatchlistMonitorMatchesUpdated: 'watchlist_monitor.matches_updated',
    WorkflowRunCompleted: 'workflow_run.completed',
    WorkflowTaskStarted: 'workflow_task.started',
    WorkflowTaskCompleted: 'workflow_task.completed',
    CheckStarted: 'check.started',
    CheckReopened: 'check.reopened',
    CheckWithdrawn: 'check.withdrawn',
    CheckCompleted: 'check.completed',
    CheckFormCompleted: 'check.form_completed',
    ReportWithdrawn: 'report.withdrawn',
    ReportResumed: 'report.resumed',
    ReportCancelled: 'report.cancelled',
    ReportAwaitingApproval: 'report.awaiting_approval',
    ReportCompleted: 'report.completed',
    WorkflowTimelineFileCreated: 'workflow_timeline_file.created',
    WorkflowRunEvidenceFolderCreated: 'workflow_run_evidence_folder.created',
    UnknownDefaultOpenApi: '11184809'
};
export const WorkflowRunLinkLanguageEnum = {
    EnUs: 'en_US',
    DeDe: 'de_DE',
    EsEs: 'es_ES',
    FrFr: 'fr_FR',
    ItIt: 'it_IT',
    PtPt: 'pt_PT',
    NlNl: 'nl_NL',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
export const WorkflowRunStatus = {
    Processing: 'processing',
    AwaitingInput: 'awaiting_input',
    AwaitingClientInput: 'awaiting_client_input',
    Approved: 'approved',
    Declined: 'declined',
    Review: 'review',
    Abandoned: 'abandoned',
    Error: 'error',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Cancels single paused reports.
         * @summary Cancel report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: (reportId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('cancelReport', 'reportId', reportId);
            const localVarPath = `/reports/{report_id}/cancel`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Completes a Send / Receive Data Task.
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: (workflowRunId, taskId, completeTaskBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('completeTask', 'workflowRunId', workflowRunId);
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('completeTask', 'taskId', taskId);
            // verify required parameter 'completeTaskBuilder' is not null or undefined
            assertParamExists('completeTask', 'completeTaskBuilder', completeTaskBuilder);
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}/complete`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(completeTaskBuilder, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a single applicant. Returns an applicant object.
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant: (applicantBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantBuilder' is not null or undefined
            assertParamExists('createApplicant', 'applicantBuilder', applicantBuilder);
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(applicantBuilder, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object.
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck: (checkBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkBuilder' is not null or undefined
            assertParamExists('createCheck', 'checkBuilder', checkBuilder);
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(checkBuilder, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run.
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('createTimelineFile', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/timeline_file`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new monitor for the applicant
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor: (watchlistMonitorBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'watchlistMonitorBuilder' is not null or undefined
            assertParamExists('createWatchlistMonitor', 'watchlistMonitorBuilder', watchlistMonitorBuilder);
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(watchlistMonitorBuilder, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Registers a webhook. Returns a webhook object.
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: (webhookBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookBuilder' is not null or undefined
            assertParamExists('createWebhook', 'webhookBuilder', webhookBuilder);
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(webhookBuilder, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object.
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun: (workflowRunBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunBuilder' is not null or undefined
            assertParamExists('createWorkflowRun', 'workflowRunBuilder', workflowRunBuilder);
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(workflowRunBuilder, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a single applicant.
         * @summary Delete Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('deleteApplicant', 'applicantId', applicantId);
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deactivates the given monitor
         * @summary Delete monitor
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor: (monitorId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('deleteWatchlistMonitor', 'monitorId', monitorId);
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a webhook.
         * @summary Delete a webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: (webhookId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId);
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF.
         * @summary Download check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck: (checkId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('downloadCheck', 'checkId', checkId);
            const localVarPath = `/checks/{check_id}/download`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument: (documentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocument', 'documentId', documentId);
            const localVarPath = `/documents/{document_id}/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video.
         * @summary Download document video
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo: (documentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocumentVideo', 'documentId', documentId);
            const localVarPath = `/documents/{document_id}/video/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the evidence folder for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Folder
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEvidenceFolder: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadEvidenceFolder', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/evidence_folder`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto: (idPhotoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'idPhotoId' is not null or undefined
            assertParamExists('downloadIdPhoto', 'idPhotoId', idPhotoId);
            const localVarPath = `/id_photos/{id_photo_id}/download`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto: (livePhotoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'livePhotoId' is not null or undefined
            assertParamExists('downloadLivePhoto', 'livePhotoId', livePhotoId);
            const localVarPath = `/live_photos/{live_photo_id}/download`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo: (liveVideoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('downloadLiveVideo', 'liveVideoId', liveVideoId);
            const localVarPath = `/live_videos/{live_video_id}/download`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame: (liveVideoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('downloadLiveVideoFrame', 'liveVideoId', liveVideoId);
            const localVarPath = `/live_videos/{live_video_id}/frame`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture: (motionCaptureId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('downloadMotionCapture', 'motionCaptureId', motionCaptureId);
            const localVarPath = `/motion_captures/{motion_capture_id}/download`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame: (motionCaptureId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('downloadMotionCaptureFrame', 'motionCaptureId', motionCaptureId);
            const localVarPath = `/motion_captures/{motion_capture_id}/frame`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download NFC face
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadNfcFace: (documentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadNfcFace', 'documentId', documentId);
            const localVarPath = `/documents/{document_id}/nfc_face`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the signed document or application form depending on the file_id provided.
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument: (workflowRunId, fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadQesDocument', 'workflowRunId', workflowRunId);
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadQesDocument', 'fileId', fileId);
            const localVarPath = `/qualified_electronic_signature/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (workflowRunId !== undefined) {
                localVarQueryParameter['workflow_run_id'] = workflowRunId;
            }
            if (fileId !== undefined) {
                localVarQueryParameter['file_id'] = fileId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the signed evidence file for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadSignedEvidenceFile', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/signed_evidence_file`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Extract information from a document
         * @summary Autofill
         * @param {ExtractRequest} extractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract: (extractRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'extractRequest' is not null or undefined
            assertParamExists('extract', 'extractRequest', extractRequest);
            const localVarPath = `/extractions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(extractRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search for addresses by postcode
         * @summary Address Picker
         * @param {string} postcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses: (postcode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'postcode' is not null or undefined
            assertParamExists('findAddresses', 'postcode', postcode);
            const localVarPath = `/addresses/pick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (postcode !== undefined) {
                localVarQueryParameter['postcode'] = postcode;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single applicant. Returns an applicant object.
         * @summary Retrieve Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('findApplicant', 'applicantId', applicantId);
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck: (checkId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('findCheck', 'checkId', checkId);
            const localVarPath = `/checks/{check_id}`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
         * @summary Retrieve document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument: (documentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('findDocument', 'documentId', documentId);
            const localVarPath = `/documents/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single ID photo. Returns a ID photo object.
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto: (idPhotoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'idPhotoId' is not null or undefined
            assertParamExists('findIdPhoto', 'idPhotoId', idPhotoId);
            const localVarPath = `/id_photos/{id_photo_id}`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single live photo. Returns a live photo object.
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto: (livePhotoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'livePhotoId' is not null or undefined
            assertParamExists('findLivePhoto', 'livePhotoId', livePhotoId);
            const localVarPath = `/live_photos/{live_photo_id}`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single live video. Returns the corresponding live video object.
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo: (liveVideoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('findLiveVideo', 'liveVideoId', liveVideoId);
            const localVarPath = `/live_videos/{live_video_id}`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object.
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture: (motionCaptureId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('findMotionCapture', 'motionCaptureId', motionCaptureId);
            const localVarPath = `/motion_captures/{motion_capture_id}`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier.
         * @summary Retrieve report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport: (reportId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('findReport', 'reportId', reportId);
            const localVarPath = `/reports/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask: (workflowRunId, taskId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findTask', 'workflowRunId', workflowRunId);
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('findTask', 'taskId', taskId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the Timeline File for the designated Workflow Run.
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile: (workflowRunId, timelineFileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findTimelineFile', 'workflowRunId', workflowRunId);
            // verify required parameter 'timelineFileId' is not null or undefined
            assertParamExists('findTimelineFile', 'timelineFileId', timelineFileId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/timeline_file/{timeline_file_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"timeline_file_id"}}`, encodeURIComponent(String(timelineFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single monitor
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor: (monitorId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('findWatchlistMonitor', 'monitorId', monitorId);
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single webhook. Returns a webhook object.
         * @summary Retrieve a Webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook: (webhookId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('findWebhook', 'webhookId', webhookId);
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findWorkflowRun', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update.
         * @summary Force new report creation (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor: (monitorId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('forceReportCreationFromWatchlistMonitor', 'monitorId', monitorId);
            const localVarPath = `/watchlist_monitors/{monitor_id}/new_report`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generates an SDK token. Returns a token object containing the SDK token.
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken: (sdkTokenBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'sdkTokenBuilder' is not null or undefined
            assertParamExists('generateSdkToken', 'sdkTokenBuilder', sdkTokenBuilder);
            const localVarPath = `/sdk_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(sdkTokenBuilder, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order.
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants: (page, perPage, includeDeleted, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve Checks
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listChecks', 'applicantId', applicantId);
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listDocuments', 'applicantId', applicantId);
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists the ID photos that belong to an applicant.
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listIdPhotos', 'applicantId', applicantId);
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists the live photos that belong to an applicant.
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listLivePhotos', 'applicantId', applicantId);
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the live videos that belong to an applicant.
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listLiveVideos', 'applicantId', applicantId);
            const localVarPath = `/live_videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the motion captures that belong to an applicant.
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listMotionCaptures', 'applicantId', applicantId);
            const localVarPath = `/motion_captures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all repeat attempts for a given Document report
         * @summary Retrieve repeat attempts
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts: (reportId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('listRepeatAttempts', 'reportId', reportId);
            const localVarPath = `/repeat_attempts/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * All the reports belonging to a particular check can be listed from this endpoint.
         * @summary List reports
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports: (checkId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('listReports', 'checkId', checkId);
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (checkId !== undefined) {
                localVarQueryParameter['check_id'] = checkId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('listTasks', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status
         * @summary List matches (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches: (monitorId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('listWatchlistMonitorMatches', 'monitorId', monitorId);
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all available monitors for an applicant
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors: (applicantId, includeDeleted, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listWatchlistMonitors', 'applicantId', applicantId);
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all webhooks you\'ve created.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects.
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {string} [applicantId] the applicant\&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns: (page, status, createdAtGt, createdAtLt, sort, applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt instanceof Date) ?
                    createdAtGt.toISOString() :
                    createdAtGt;
            }
            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt instanceof Date) ?
                    createdAtLt.toISOString() :
                    createdAtLt;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Run a health check on the Onfido API
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create Feedback on checks and reports
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback: (resultsFeedback, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'resultsFeedback' is not null or undefined
            assertParamExists('postResultsFeedback', 'resultsFeedback', resultsFeedback);
            const localVarPath = `/results_feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(resultsFeedback, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Resends events to all webhooks registered with a matching environment in your account.
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks: (webhookResend, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookResend' is not null or undefined
            assertParamExists('resendWebhooks', 'webhookResend', webhookResend);
            const localVarPath = `/webhooks/resend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(webhookResend, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Restores a single applicant scheduled for deletion.
         * @summary Restore Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('restoreApplicant', 'applicantId', applicantId);
            const localVarPath = `/applicants/{applicant_id}/restore`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Resumes a paused check.
         * @summary Resume a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck: (checkId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('resumeCheck', 'checkId', checkId);
            const localVarPath = `/checks/{check_id}/resume`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Resumes a single paused report.
         * @summary Resume report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport: (reportId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('resumeReport', 'reportId', reportId);
            const localVarPath = `/reports/{report_id}/resume`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant
         * @summary Update Applicant
         * @param {string} applicantId
         * @param {ApplicantUpdater} applicantUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant: (applicantId, applicantUpdater, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('updateApplicant', 'applicantId', applicantId);
            // verify required parameter 'applicantUpdater' is not null or undefined
            assertParamExists('updateApplicant', 'applicantUpdater', applicantUpdater);
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(applicantUpdater, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the status of the given matches
         * @summary Set match status (BETA)
         * @param {string} monitorId
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch: (monitorId, watchlistMonitorMatchesUpdater, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('updateWatchlistMonitorMatch', 'monitorId', monitorId);
            // verify required parameter 'watchlistMonitorMatchesUpdater' is not null or undefined
            assertParamExists('updateWatchlistMonitorMatch', 'watchlistMonitorMatchesUpdater', watchlistMonitorMatchesUpdater);
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(watchlistMonitorMatchesUpdater, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Edits a webhook. Returns the updated webhook object.
         * @summary Edit a webhook
         * @param {string} webhookId
         * @param {WebhookUpdater} webhookUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: (webhookId, webhookUpdater, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId);
            // verify required parameter 'webhookUpdater' is not null or undefined
            assertParamExists('updateWebhook', 'webhookUpdater', webhookUpdater);
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(webhookUpdater, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB.
         * @summary Upload a document
         * @param {DocumentTypes} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {string} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument: (type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('uploadDocument', 'type', type);
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('uploadDocument', 'applicantId', applicantId);
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDocument', 'file', file);
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (fileType !== undefined) {
                localVarFormParams.append('file_type', fileType);
            }
            if (type !== undefined) {
                localVarFormParams.append('type', type);
            }
            if (side !== undefined) {
                localVarFormParams.append('side', side);
            }
            if (issuingCountry !== undefined) {
                localVarFormParams.append('issuing_country', issuingCountry);
            }
            if (applicantId !== undefined) {
                localVarFormParams.append('applicant_id', applicantId);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file.buffer, file.filename);
            }
            if (validateImageQuality !== undefined) {
                localVarFormParams.append('validate_image_quality', String(validateImageQuality));
            }
            if (location !== undefined) {
                localVarFormParams.append('location', JSON.stringify(location));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB.
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto: (applicantId, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarFormParams.append('applicant_id', applicantId);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file.buffer, file.filename);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false.
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto: (applicantId, file, advancedValidation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication Token required
            yield setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarFormParams.append('applicant_id', applicantId);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file.buffer, file.filename);
            }
            if (advancedValidation !== undefined) {
                localVarFormParams.append('advanced_validation', String(advancedValidation));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
    return {
        /**
         * Cancels single paused reports.
         * @summary Cancel report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport(reportId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelReport(reportId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.cancelReport']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Completes a Send / Receive Data Task.
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(workflowRunId, taskId, completeTaskBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.completeTask(workflowRunId, taskId, completeTaskBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.completeTask']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a single applicant. Returns an applicant object.
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant(applicantBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createApplicant(applicantBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.createApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object.
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck(checkBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCheck(checkBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.createCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run.
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTimelineFile(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.createTimelineFile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new monitor for the applicant
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor(watchlistMonitorBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWatchlistMonitor(watchlistMonitorBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.createWatchlistMonitor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Registers a webhook. Returns a webhook object.
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(webhookBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWebhook(webhookBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.createWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object.
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun(workflowRunBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWorkflowRun(workflowRunBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.createWorkflowRun']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a single applicant.
         * @summary Delete Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteApplicant(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.deleteApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deactivates the given monitor
         * @summary Delete monitor
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor(monitorId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWatchlistMonitor(monitorId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.deleteWatchlistMonitor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a webhook.
         * @summary Delete a webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWebhook(webhookId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.deleteWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF.
         * @summary Download check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck(checkId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadCheck(checkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadDocument(documentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video.
         * @summary Download document video
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo(documentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadDocumentVideo(documentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadDocumentVideo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the evidence folder for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Folder
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEvidenceFolder(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadEvidenceFolder(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadEvidenceFolder']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto(idPhotoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadIdPhoto(idPhotoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadIdPhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto(livePhotoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadLivePhoto(livePhotoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadLivePhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo(liveVideoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadLiveVideo(liveVideoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadLiveVideo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame(liveVideoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadLiveVideoFrame(liveVideoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadLiveVideoFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture(motionCaptureId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadMotionCapture(motionCaptureId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadMotionCapture']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame(motionCaptureId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadMotionCaptureFrame(motionCaptureId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadMotionCaptureFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download NFC face
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadNfcFace(documentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadNfcFace(documentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadNfcFace']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided.
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument(workflowRunId, fileId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadQesDocument(workflowRunId, fileId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadQesDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadSignedEvidenceFile(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.downloadSignedEvidenceFile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Extract information from a document
         * @summary Autofill
         * @param {ExtractRequest} extractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract(extractRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.extract(extractRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.extract']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search for addresses by postcode
         * @summary Address Picker
         * @param {string} postcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses(postcode, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findAddresses(postcode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findAddresses']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single applicant. Returns an applicant object.
         * @summary Retrieve Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findApplicant(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck(checkId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findCheck(checkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
         * @summary Retrieve document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument(documentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findDocument(documentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object.
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto(idPhotoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findIdPhoto(idPhotoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findIdPhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single live photo. Returns a live photo object.
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto(livePhotoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findLivePhoto(livePhotoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findLivePhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object.
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo(liveVideoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findLiveVideo(liveVideoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findLiveVideo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object.
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture(motionCaptureId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findMotionCapture(motionCaptureId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findMotionCapture']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier.
         * @summary Retrieve report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport(reportId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findReport(reportId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findReport']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask(workflowRunId, taskId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findTask(workflowRunId, taskId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findTask']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run.
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile(workflowRunId, timelineFileId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findTimelineFile(workflowRunId, timelineFileId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findTimelineFile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single monitor
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor(monitorId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findWatchlistMonitor(monitorId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findWatchlistMonitor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single webhook. Returns a webhook object.
         * @summary Retrieve a Webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook(webhookId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findWebhook(webhookId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findWorkflowRun(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.findWorkflowRun']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update.
         * @summary Force new report creation (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor(monitorId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.forceReportCreationFromWatchlistMonitor(monitorId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.forceReportCreationFromWatchlistMonitor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token.
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken(sdkTokenBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateSdkToken(sdkTokenBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.generateSdkToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order.
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants(page, perPage, includeDeleted, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApplicants(page, perPage, includeDeleted, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listApplicants']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve Checks
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listChecks(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listChecks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDocuments(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listDocuments']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists the ID photos that belong to an applicant.
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listIdPhotos(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listIdPhotos']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists the live photos that belong to an applicant.
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listLivePhotos(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listLivePhotos']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the live videos that belong to an applicant.
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listLiveVideos(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listLiveVideos']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the motion captures that belong to an applicant.
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listMotionCaptures(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listMotionCaptures']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns all repeat attempts for a given Document report
         * @summary Retrieve repeat attempts
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts(reportId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRepeatAttempts(reportId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listRepeatAttempts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint.
         * @summary List reports
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports(checkId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listReports(checkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listReports']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTasks(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listTasks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status
         * @summary List matches (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches(monitorId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWatchlistMonitorMatches(monitorId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listWatchlistMonitorMatches']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all available monitors for an applicant
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors(applicantId, includeDeleted, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWatchlistMonitors(applicantId, includeDeleted, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listWatchlistMonitors']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all webhooks you\'ve created.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWebhooks(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listWebhooks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects.
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {string} [applicantId] the applicant\&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.listWorkflowRuns']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Run a health check on the Onfido API
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ping(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.ping']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create Feedback on checks and reports
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback(resultsFeedback, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postResultsFeedback(resultsFeedback, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.postResultsFeedback']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account.
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks(webhookResend, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resendWebhooks(webhookResend, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.resendWebhooks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Restores a single applicant scheduled for deletion.
         * @summary Restore Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.restoreApplicant(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.restoreApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Resumes a paused check.
         * @summary Resume a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck(checkId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resumeCheck(checkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.resumeCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Resumes a single paused report.
         * @summary Resume report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport(reportId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resumeReport(reportId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.resumeReport']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant
         * @summary Update Applicant
         * @param {string} applicantId
         * @param {ApplicantUpdater} applicantUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant(applicantId, applicantUpdater, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateApplicant(applicantId, applicantUpdater, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.updateApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update the status of the given matches
         * @summary Set match status (BETA)
         * @param {string} monitorId
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.updateWatchlistMonitorMatch']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Edits a webhook. Returns the updated webhook object.
         * @summary Edit a webhook
         * @param {string} webhookId
         * @param {WebhookUpdater} webhookUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, webhookUpdater, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWebhook(webhookId, webhookUpdater, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.updateWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB.
         * @summary Upload a document
         * @param {DocumentTypes} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {string} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.uploadDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB.
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto(applicantId, file, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadIdPhoto(applicantId, file, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.uploadIdPhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false.
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto(applicantId, file, advancedValidation, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadLivePhoto(applicantId, file, advancedValidation, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['DefaultApi.uploadLivePhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DefaultApiFp(configuration);
    return {
        /**
         * Cancels single paused reports.
         * @summary Cancel report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport(reportId, options) {
            return localVarFp.cancelReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a Send / Receive Data Task.
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(workflowRunId, taskId, completeTaskBuilder, options) {
            return localVarFp.completeTask(workflowRunId, taskId, completeTaskBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a single applicant. Returns an applicant object.
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant(applicantBuilder, options) {
            return localVarFp.createApplicant(applicantBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object.
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck(checkBuilder, options) {
            return localVarFp.createCheck(checkBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run.
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile(workflowRunId, options) {
            return localVarFp.createTimelineFile(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new monitor for the applicant
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor(watchlistMonitorBuilder, options) {
            return localVarFp.createWatchlistMonitor(watchlistMonitorBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a webhook. Returns a webhook object.
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(webhookBuilder, options) {
            return localVarFp.createWebhook(webhookBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object.
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun(workflowRunBuilder, options) {
            return localVarFp.createWorkflowRun(workflowRunBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single applicant.
         * @summary Delete Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant(applicantId, options) {
            return localVarFp.deleteApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates the given monitor
         * @summary Delete monitor
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor(monitorId, options) {
            return localVarFp.deleteWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a webhook.
         * @summary Delete a webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF.
         * @summary Download check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck(checkId, options) {
            return localVarFp.downloadCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId, options) {
            return localVarFp.downloadDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video.
         * @summary Download document video
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo(documentId, options) {
            return localVarFp.downloadDocumentVideo(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the evidence folder for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Folder
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEvidenceFolder(workflowRunId, options) {
            return localVarFp.downloadEvidenceFolder(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto(idPhotoId, options) {
            return localVarFp.downloadIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto(livePhotoId, options) {
            return localVarFp.downloadLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo(liveVideoId, options) {
            return localVarFp.downloadLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame(liveVideoId, options) {
            return localVarFp.downloadLiveVideoFrame(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture(motionCaptureId, options) {
            return localVarFp.downloadMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame(motionCaptureId, options) {
            return localVarFp.downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download NFC face
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadNfcFace(documentId, options) {
            return localVarFp.downloadNfcFace(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided.
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument(workflowRunId, fileId, options) {
            return localVarFp.downloadQesDocument(workflowRunId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile(workflowRunId, options) {
            return localVarFp.downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Extract information from a document
         * @summary Autofill
         * @param {ExtractRequest} extractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract(extractRequest, options) {
            return localVarFp.extract(extractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for addresses by postcode
         * @summary Address Picker
         * @param {string} postcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses(postcode, options) {
            return localVarFp.findAddresses(postcode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single applicant. Returns an applicant object.
         * @summary Retrieve Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant(applicantId, options) {
            return localVarFp.findApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck(checkId, options) {
            return localVarFp.findCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
         * @summary Retrieve document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument(documentId, options) {
            return localVarFp.findDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object.
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto(idPhotoId, options) {
            return localVarFp.findIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single live photo. Returns a live photo object.
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto(livePhotoId, options) {
            return localVarFp.findLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object.
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo(liveVideoId, options) {
            return localVarFp.findLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object.
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture(motionCaptureId, options) {
            return localVarFp.findMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier.
         * @summary Retrieve report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport(reportId, options) {
            return localVarFp.findReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask(workflowRunId, taskId, options) {
            return localVarFp.findTask(workflowRunId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run.
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile(workflowRunId, timelineFileId, options) {
            return localVarFp.findTimelineFile(workflowRunId, timelineFileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single monitor
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor(monitorId, options) {
            return localVarFp.findWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single webhook. Returns a webhook object.
         * @summary Retrieve a Webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook(webhookId, options) {
            return localVarFp.findWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun(workflowRunId, options) {
            return localVarFp.findWorkflowRun(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update.
         * @summary Force new report creation (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor(monitorId, options) {
            return localVarFp.forceReportCreationFromWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token.
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken(sdkTokenBuilder, options) {
            return localVarFp.generateSdkToken(sdkTokenBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order.
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants(page, perPage, includeDeleted, options) {
            return localVarFp.listApplicants(page, perPage, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve Checks
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks(applicantId, options) {
            return localVarFp.listChecks(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(applicantId, options) {
            return localVarFp.listDocuments(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the ID photos that belong to an applicant.
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos(applicantId, options) {
            return localVarFp.listIdPhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the live photos that belong to an applicant.
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos(applicantId, options) {
            return localVarFp.listLivePhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the live videos that belong to an applicant.
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos(applicantId, options) {
            return localVarFp.listLiveVideos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the motion captures that belong to an applicant.
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures(applicantId, options) {
            return localVarFp.listMotionCaptures(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all repeat attempts for a given Document report
         * @summary Retrieve repeat attempts
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts(reportId, options) {
            return localVarFp.listRepeatAttempts(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint.
         * @summary List reports
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports(checkId, options) {
            return localVarFp.listReports(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(workflowRunId, options) {
            return localVarFp.listTasks(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status
         * @summary List matches (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches(monitorId, options) {
            return localVarFp.listWatchlistMonitorMatches(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available monitors for an applicant
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors(applicantId, includeDeleted, options) {
            return localVarFp.listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all webhooks you\'ve created.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options) {
            return localVarFp.listWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects.
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {string} [applicantId] the applicant\&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options) {
            return localVarFp.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a health check on the Onfido API
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Create Feedback on checks and reports
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback(resultsFeedback, options) {
            return localVarFp.postResultsFeedback(resultsFeedback, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account.
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks(webhookResend, options) {
            return localVarFp.resendWebhooks(webhookResend, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores a single applicant scheduled for deletion.
         * @summary Restore Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant(applicantId, options) {
            return localVarFp.restoreApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a paused check.
         * @summary Resume a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck(checkId, options) {
            return localVarFp.resumeCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a single paused report.
         * @summary Resume report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport(reportId, options) {
            return localVarFp.resumeReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant
         * @summary Update Applicant
         * @param {string} applicantId
         * @param {ApplicantUpdater} applicantUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant(applicantId, applicantUpdater, options) {
            return localVarFp.updateApplicant(applicantId, applicantUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of the given matches
         * @summary Set match status (BETA)
         * @param {string} monitorId
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options) {
            return localVarFp.updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a webhook. Returns the updated webhook object.
         * @summary Edit a webhook
         * @param {string} webhookId
         * @param {WebhookUpdater} webhookUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, webhookUpdater, options) {
            return localVarFp.updateWebhook(webhookId, webhookUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB.
         * @summary Upload a document
         * @param {DocumentTypes} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {string} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options) {
            return localVarFp.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB.
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto(applicantId, file, options) {
            return localVarFp.uploadIdPhoto(applicantId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false.
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto(applicantId, file, advancedValidation, options) {
            return localVarFp.uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Cancels single paused reports.
     * @summary Cancel report
     * @param {string} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    cancelReport(reportId, options) {
        return DefaultApiFp(this.configuration).cancelReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Completes a Send / Receive Data Task.
     * @summary Complete Task
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to complete.
     * @param {CompleteTaskBuilder} completeTaskBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    completeTask(workflowRunId, taskId, completeTaskBuilder, options) {
        return DefaultApiFp(this.configuration).completeTask(workflowRunId, taskId, completeTaskBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a single applicant. Returns an applicant object.
     * @summary Create Applicant
     * @param {ApplicantBuilder} applicantBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createApplicant(applicantBuilder, options) {
        return DefaultApiFp(this.configuration).createApplicant(applicantBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiates a check for an applicant, which can contain one or more reports. Returns a check object.
     * @summary Create a check
     * @param {CheckBuilder} checkBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createCheck(checkBuilder, options) {
        return DefaultApiFp(this.configuration).createCheck(checkBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Triggers the generation of the Timeline File for the designated Workflow Run.
     * @summary Create Timeline File for Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createTimelineFile(workflowRunId, options) {
        return DefaultApiFp(this.configuration).createTimelineFile(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new monitor for the applicant
     * @summary Create monitor
     * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createWatchlistMonitor(watchlistMonitorBuilder, options) {
        return DefaultApiFp(this.configuration).createWatchlistMonitor(watchlistMonitorBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Registers a webhook. Returns a webhook object.
     * @summary Register webhook
     * @param {WebhookBuilder} webhookBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createWebhook(webhookBuilder, options) {
        return DefaultApiFp(this.configuration).createWebhook(webhookBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and starts a Workflow Run. Returns a Workflow Run object.
     * @summary Create a Workflow Run
     * @param {WorkflowRunBuilder} workflowRunBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createWorkflowRun(workflowRunBuilder, options) {
        return DefaultApiFp(this.configuration).createWorkflowRun(workflowRunBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a single applicant.
     * @summary Delete Applicant
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    deleteApplicant(applicantId, options) {
        return DefaultApiFp(this.configuration).deleteApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deactivates the given monitor
     * @summary Delete monitor
     * @param {string} monitorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    deleteWatchlistMonitor(monitorId, options) {
        return DefaultApiFp(this.configuration).deleteWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a webhook.
     * @summary Delete a webhook
     * @param {string} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    deleteWebhook(webhookId, options) {
        return DefaultApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF.
     * @summary Download check
     * @param {string} checkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadCheck(checkId, options) {
        return DefaultApiFp(this.configuration).downloadCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
     * @summary Download document
     * @param {string} documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadDocument(documentId, options) {
        return DefaultApiFp(this.configuration).downloadDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads a document video. If successful, the response will be the binary data representing the video.
     * @summary Download document video
     * @param {string} documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadDocumentVideo(documentId, options) {
        return DefaultApiFp(this.configuration).downloadDocumentVideo(documentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the evidence folder for the designated Workflow Run
     * @summary Retrieve Workflow Run Evidence Folder
     * @param {string} workflowRunId Workflow Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadEvidenceFolder(workflowRunId, options) {
        return DefaultApiFp(this.configuration).downloadEvidenceFolder(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * ID photos are downloaded using this endpoint.
     * @summary Download ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadIdPhoto(idPhotoId, options) {
        return DefaultApiFp(this.configuration).downloadIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Live photos are downloaded using this endpoint.
     * @summary Download live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadLivePhoto(livePhotoId, options) {
        return DefaultApiFp(this.configuration).downloadLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Live videos are downloaded using this endpoint.
     * @summary Download live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadLiveVideo(liveVideoId, options) {
        return DefaultApiFp(this.configuration).downloadLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the binary data representing a single frame from a live video.
     * @summary Download live video frame
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadLiveVideoFrame(liveVideoId, options) {
        return DefaultApiFp(this.configuration).downloadLiveVideoFrame(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Motion captures are downloaded using this endpoint.
     * @summary Download motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadMotionCapture(motionCaptureId, options) {
        return DefaultApiFp(this.configuration).downloadMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
     * @summary Download motion capture frame
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadMotionCaptureFrame(motionCaptureId, options) {
        return DefaultApiFp(this.configuration).downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
     * @summary Download NFC face
     * @param {string} documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadNfcFace(documentId, options) {
        return DefaultApiFp(this.configuration).downloadNfcFace(documentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the signed document or application form depending on the file_id provided.
     * @summary Retrieves the signed document or application form
     * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
     * @param {string} fileId The unique identifier of the file which you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadQesDocument(workflowRunId, fileId, options) {
        return DefaultApiFp(this.configuration).downloadQesDocument(workflowRunId, fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the signed evidence file for the designated Workflow Run
     * @summary Retrieve Workflow Run Evidence Summary File
     * @param {string} workflowRunId Workflow Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadSignedEvidenceFile(workflowRunId, options) {
        return DefaultApiFp(this.configuration).downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Extract information from a document
     * @summary Autofill
     * @param {ExtractRequest} extractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    extract(extractRequest, options) {
        return DefaultApiFp(this.configuration).extract(extractRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search for addresses by postcode
     * @summary Address Picker
     * @param {string} postcode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findAddresses(postcode, options) {
        return DefaultApiFp(this.configuration).findAddresses(postcode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single applicant. Returns an applicant object.
     * @summary Retrieve Applicant
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findApplicant(applicantId, options) {
        return DefaultApiFp(this.configuration).findApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single check. Returns a check object.
     * @summary Retrieve a Check
     * @param {string} checkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findCheck(checkId, options) {
        return DefaultApiFp(this.configuration).findCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
     * @summary Retrieve document
     * @param {string} documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findDocument(documentId, options) {
        return DefaultApiFp(this.configuration).findDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single ID photo. Returns a ID photo object.
     * @summary Retrieve ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findIdPhoto(idPhotoId, options) {
        return DefaultApiFp(this.configuration).findIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single live photo. Returns a live photo object.
     * @summary Retrieve live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findLivePhoto(livePhotoId, options) {
        return DefaultApiFp(this.configuration).findLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single live video. Returns the corresponding live video object.
     * @summary Retrieve live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findLiveVideo(liveVideoId, options) {
        return DefaultApiFp(this.configuration).findLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single motion capture. Returns the corresponding motion capture object.
     * @summary Retrieve motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findMotionCapture(motionCaptureId, options) {
        return DefaultApiFp(this.configuration).findMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A single report can be retrieved using this endpoint with the corresponding unique identifier.
     * @summary Retrieve report
     * @param {string} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findReport(reportId, options) {
        return DefaultApiFp(this.configuration).findReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
     * @summary Retrieve Task
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findTask(workflowRunId, taskId, options) {
        return DefaultApiFp(this.configuration).findTask(workflowRunId, taskId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the Timeline File for the designated Workflow Run.
     * @summary Retrieve Timeline File for Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {string} timelineFileId The unique identifier for the Timefile File.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findTimelineFile(workflowRunId, timelineFileId, options) {
        return DefaultApiFp(this.configuration).findTimelineFile(workflowRunId, timelineFileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single monitor
     * @summary Retrieve monitor
     * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findWatchlistMonitor(monitorId, options) {
        return DefaultApiFp(this.configuration).findWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single webhook. Returns a webhook object.
     * @summary Retrieve a Webhook
     * @param {string} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findWebhook(webhookId, options) {
        return DefaultApiFp(this.configuration).findWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
     * @summary Retrieve Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findWorkflowRun(workflowRunId, options) {
        return DefaultApiFp(this.configuration).findWorkflowRun(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update.
     * @summary Force new report creation (BETA)
     * @param {string} monitorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    forceReportCreationFromWatchlistMonitor(monitorId, options) {
        return DefaultApiFp(this.configuration).forceReportCreationFromWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates an SDK token. Returns a token object containing the SDK token.
     * @summary Generate a SDK token
     * @param {SdkTokenBuilder} sdkTokenBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    generateSdkToken(sdkTokenBuilder, options) {
        return DefaultApiFp(this.configuration).generateSdkToken(sdkTokenBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all applicants you\'ve created, sorted by creation date in descending order.
     * @summary List Applicants
     * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
     * @param {number} [perPage] The number of objects per page.
     * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listApplicants(page, perPage, includeDeleted, options) {
        return DefaultApiFp(this.configuration).listApplicants(page, perPage, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single check. Returns a check object.
     * @summary Retrieve Checks
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listChecks(applicantId, options) {
        return DefaultApiFp(this.configuration).listChecks(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * All documents belonging to an applicant can be listed from this endpoint
     * @summary List documents
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listDocuments(applicantId, options) {
        return DefaultApiFp(this.configuration).listDocuments(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the ID photos that belong to an applicant.
     * @summary List ID photos
     * @param {string} applicantId The id of the applicant the ID photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listIdPhotos(applicantId, options) {
        return DefaultApiFp(this.configuration).listIdPhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the live photos that belong to an applicant.
     * @summary List live photos
     * @param {string} applicantId The id of the applicant the live photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listLivePhotos(applicantId, options) {
        return DefaultApiFp(this.configuration).listLivePhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the live videos that belong to an applicant.
     * @summary List live videos
     * @param {string} applicantId The id of the applicant the live videos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listLiveVideos(applicantId, options) {
        return DefaultApiFp(this.configuration).listLiveVideos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the motion captures that belong to an applicant.
     * @summary List motion captures
     * @param {string} applicantId The id of the applicant the motion captures belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listMotionCaptures(applicantId, options) {
        return DefaultApiFp(this.configuration).listMotionCaptures(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all repeat attempts for a given Document report
     * @summary Retrieve repeat attempts
     * @param {string} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listRepeatAttempts(reportId, options) {
        return DefaultApiFp(this.configuration).listRepeatAttempts(reportId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * All the reports belonging to a particular check can be listed from this endpoint.
     * @summary List reports
     * @param {string} checkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listReports(checkId, options) {
        return DefaultApiFp(this.configuration).listReports(checkId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
     * @summary List Tasks
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listTasks(workflowRunId, options) {
        return DefaultApiFp(this.configuration).listTasks(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List match IDs on this monitor, as well as their enabled/disabled status
     * @summary List matches (BETA)
     * @param {string} monitorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listWatchlistMonitorMatches(monitorId, options) {
        return DefaultApiFp(this.configuration).listWatchlistMonitorMatches(monitorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all available monitors for an applicant
     * @summary List monitors
     * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
     * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listWatchlistMonitors(applicantId, includeDeleted, options) {
        return DefaultApiFp(this.configuration).listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all webhooks you\'ve created.
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listWebhooks(options) {
        return DefaultApiFp(this.configuration).listWebhooks(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects.
     * @summary List Workflow Runs
     * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
     * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
     * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
     * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
     * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
     * @param {string} [applicantId] the applicant\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options) {
        return DefaultApiFp(this.configuration).listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Run a health check on the Onfido API
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    ping(options) {
        return DefaultApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create Feedback on checks and reports
     * @summary Fraud reporting (ALPHA)
     * @param {ResultsFeedback} resultsFeedback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    postResultsFeedback(resultsFeedback, options) {
        return DefaultApiFp(this.configuration).postResultsFeedback(resultsFeedback, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resends events to all webhooks registered with a matching environment in your account.
     * @summary Resends webhooks
     * @param {WebhookResend} webhookResend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    resendWebhooks(webhookResend, options) {
        return DefaultApiFp(this.configuration).resendWebhooks(webhookResend, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restores a single applicant scheduled for deletion.
     * @summary Restore Applicant
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    restoreApplicant(applicantId, options) {
        return DefaultApiFp(this.configuration).restoreApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resumes a paused check.
     * @summary Resume a Check
     * @param {string} checkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    resumeCheck(checkId, options) {
        return DefaultApiFp(this.configuration).resumeCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resumes a single paused report.
     * @summary Resume report
     * @param {string} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    resumeReport(reportId, options) {
        return DefaultApiFp(this.configuration).resumeReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant
     * @summary Update Applicant
     * @param {string} applicantId
     * @param {ApplicantUpdater} applicantUpdater
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateApplicant(applicantId, applicantUpdater, options) {
        return DefaultApiFp(this.configuration).updateApplicant(applicantId, applicantUpdater, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the status of the given matches
     * @summary Set match status (BETA)
     * @param {string} monitorId
     * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options) {
        return DefaultApiFp(this.configuration).updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Edits a webhook. Returns the updated webhook object.
     * @summary Edit a webhook
     * @param {string} webhookId
     * @param {WebhookUpdater} webhookUpdater
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateWebhook(webhookId, webhookUpdater, options) {
        return DefaultApiFp(this.configuration).updateWebhook(webhookId, webhookUpdater, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB.
     * @summary Upload a document
     * @param {DocumentTypes} type The type of document
     * @param {string} applicantId The ID of the applicant whose document is being uploaded.
     * @param {FileTransfer} file The file to be uploaded.
     * @param {string} [fileType] The file type of the uploaded file
     * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
     * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
     * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
     * @param {LocationBuilder} [location]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options) {
        return DefaultApiFp(this.configuration).uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB.
     * @summary Upload ID photo
     * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
     * @param {FileTransfer} [file] The file to be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    uploadIdPhoto(applicantId, file, options) {
        return DefaultApiFp(this.configuration).uploadIdPhoto(applicantId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false.
     * @summary Upload live photo
     * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
     * @param {FileTransfer} [file] The file to be uploaded.
     * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    uploadLivePhoto(applicantId, file, advancedValidation, options) {
        return DefaultApiFp(this.configuration).uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * @export
 */
export const ListWorkflowRunsSortEnum = {
    Desc: 'desc',
    Asc: 'asc',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * @export
 */
export const UploadDocumentSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
};
