"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Onfido API v3.6
 * The Onfido API (v3.6)
 *
 * The version of the OpenAPI document: v3.6
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListWorkflowRunsSortEnum = exports.DefaultApi = exports.DefaultApiFactory = exports.DefaultApiFp = exports.DefaultApiAxiosParamCreator = exports.WorkflowRunStatus = exports.WorkflowRunLinkLanguageEnum = exports.WebhookEventType = exports.WebhookEventResourceType = exports.WebhookEventObjectStatus = exports.WatchlistMonitorSharedReportNameEnum = exports.WatchlistMonitorBuilderReportNameEnum = exports.WatchlistMonitorReportNameEnum = exports.UsDrivingLicenceSharedGenderEnum = exports.UsDrivingLicenceSharedEyeColorCodeEnum = exports.UsDrivingLicenceSharedDocumentCategoryEnum = exports.UsDrivingLicenceBuilderGenderEnum = exports.UsDrivingLicenceBuilderEyeColorCodeEnum = exports.UsDrivingLicenceBuilderDocumentCategoryEnum = exports.ResultsFeedbackExpectedResultEnum = exports.ReportSubResult = exports.ReportStatus = exports.ReportResult = exports.ReportName = exports.RepeatAttemptsListRepeatAttemptsInnerResultEnum = exports.RepeatAttemptsListRepeatAttemptsInnerNamesEnum = exports.RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum = exports.ProofOfAddressPropertiesDocumentTypeEnum = exports.IdNumberTypeEnum = exports.ExtractionExtractedDataGenderEnum = exports.ExtractionDocumentClassificationSubtypeEnum = exports.DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum = exports.DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum = exports.DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum = exports.DocumentTypes = exports.DocumentSharedSideEnum = exports.DocumentPropertiesSecurityTierEnum = exports.DocumentPropertiesHasIssuanceConfirmationEnum = exports.DocumentPropertiesNistIdentityEvidenceStrengthEnum = exports.DocumentSideEnum = exports.DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum = exports.DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum = exports.DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum = exports.DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum = exports.DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum = exports.CountryCodes = exports.CheckStatus = exports.CheckResponseResultEnum = exports.CheckResultEnum = exports.ApplicantConsentName = void 0;
exports.UploadDocumentSideEnum = void 0;
const axios_1 = require("axios");
// URLSearchParams not necessarily used
// @ts-ignore
const url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
const file_transfer_1 = require("./file-transfer");
const axios_2 = require("axios");
axios_1.default.interceptors.response.use((response) => __awaiter(void 0, void 0, void 0, function* () {
    if (response.headers instanceof axios_2.AxiosHeaders && response.headers['content-type']) {
        if (!response.headers['content-type'].toString().includes('application/json')) {
            const contentDisposition = response.headers['content-disposition'];
            var filename = "";
            if (contentDisposition && contentDisposition != "") {
                const matcher = contentDisposition.match(/filename=['\"]?([^'\"\s]+)['\"]?/);
                if (matcher != null) {
                    filename = matcher[1].replace(/.*[/\\\\]/g, "");
                }
            }
            response.data = new file_transfer_1.FileTransfer(response.data, filename);
        }
    }
    return response;
}));
/**
 *
 * @export
 * @enum {string}
 */
exports.ApplicantConsentName = {
    PrivacyNoticesRead: 'privacy_notices_read',
    SsnVerification: 'ssn_verification',
    PhoneNumberVerification: 'phone_number_verification',
    UnknownDefaultOpenApi: '11184809'
};
exports.CheckResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
};
exports.CheckResponseResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The current state of the check in the checking process.
 * @export
 * @enum {string}
 */
exports.CheckStatus = {
    InProgress: 'in_progress',
    AwaitingApplicant: 'awaiting_applicant',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    Paused: 'paused',
    Reopened: 'reopened',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.CountryCodes = {
    Abw: 'ABW',
    Afg: 'AFG',
    Ago: 'AGO',
    Aia: 'AIA',
    Ala: 'ALA',
    Alb: 'ALB',
    And: 'AND',
    Are: 'ARE',
    Arg: 'ARG',
    Arm: 'ARM',
    Asm: 'ASM',
    Ata: 'ATA',
    Atf: 'ATF',
    Atg: 'ATG',
    Aus: 'AUS',
    Aut: 'AUT',
    Aze: 'AZE',
    Bdi: 'BDI',
    Bel: 'BEL',
    Ben: 'BEN',
    Bes: 'BES',
    Bfa: 'BFA',
    Bgd: 'BGD',
    Bgr: 'BGR',
    Bhr: 'BHR',
    Bhs: 'BHS',
    Bih: 'BIH',
    Blm: 'BLM',
    Blr: 'BLR',
    Blz: 'BLZ',
    Bmu: 'BMU',
    Bol: 'BOL',
    Bra: 'BRA',
    Brb: 'BRB',
    Brn: 'BRN',
    Btn: 'BTN',
    Bvt: 'BVT',
    Bwa: 'BWA',
    Caf: 'CAF',
    Can: 'CAN',
    Cck: 'CCK',
    Che: 'CHE',
    Chl: 'CHL',
    Chn: 'CHN',
    Civ: 'CIV',
    Cmr: 'CMR',
    Cod: 'COD',
    Cog: 'COG',
    Cok: 'COK',
    Col: 'COL',
    Com: 'COM',
    Cpv: 'CPV',
    Cri: 'CRI',
    Cub: 'CUB',
    Cuw: 'CUW',
    Cxr: 'CXR',
    Cym: 'CYM',
    Cyp: 'CYP',
    Cze: 'CZE',
    Deu: 'DEU',
    Dji: 'DJI',
    Dma: 'DMA',
    Dnk: 'DNK',
    Dom: 'DOM',
    Dza: 'DZA',
    Ecu: 'ECU',
    Egy: 'EGY',
    Eri: 'ERI',
    Esh: 'ESH',
    Esp: 'ESP',
    Est: 'EST',
    Eth: 'ETH',
    Fin: 'FIN',
    Fji: 'FJI',
    Flk: 'FLK',
    Fra: 'FRA',
    Fro: 'FRO',
    Fsm: 'FSM',
    Gab: 'GAB',
    Gbr: 'GBR',
    Geo: 'GEO',
    Ggy: 'GGY',
    Gha: 'GHA',
    Gib: 'GIB',
    Gin: 'GIN',
    Glp: 'GLP',
    Gmb: 'GMB',
    Gnb: 'GNB',
    Gnq: 'GNQ',
    Grc: 'GRC',
    Grd: 'GRD',
    Grl: 'GRL',
    Gtm: 'GTM',
    Guf: 'GUF',
    Gum: 'GUM',
    Guy: 'GUY',
    Hkg: 'HKG',
    Hmd: 'HMD',
    Hnd: 'HND',
    Hrv: 'HRV',
    Hti: 'HTI',
    Hun: 'HUN',
    Idn: 'IDN',
    Imn: 'IMN',
    Ind: 'IND',
    Iot: 'IOT',
    Irl: 'IRL',
    Irn: 'IRN',
    Irq: 'IRQ',
    Isl: 'ISL',
    Isr: 'ISR',
    Ita: 'ITA',
    Jam: 'JAM',
    Jey: 'JEY',
    Jor: 'JOR',
    Jpn: 'JPN',
    Kaz: 'KAZ',
    Ken: 'KEN',
    Kgz: 'KGZ',
    Khm: 'KHM',
    Kir: 'KIR',
    Kna: 'KNA',
    Kor: 'KOR',
    Kwt: 'KWT',
    Lao: 'LAO',
    Lbn: 'LBN',
    Lbr: 'LBR',
    Lby: 'LBY',
    Lca: 'LCA',
    Lie: 'LIE',
    Lka: 'LKA',
    Lso: 'LSO',
    Ltu: 'LTU',
    Lux: 'LUX',
    Lva: 'LVA',
    Mac: 'MAC',
    Maf: 'MAF',
    Mar: 'MAR',
    Mco: 'MCO',
    Mda: 'MDA',
    Mdg: 'MDG',
    Mdv: 'MDV',
    Mex: 'MEX',
    Mhl: 'MHL',
    Mkd: 'MKD',
    Mli: 'MLI',
    Mlt: 'MLT',
    Mmr: 'MMR',
    Mne: 'MNE',
    Mng: 'MNG',
    Mnp: 'MNP',
    Moz: 'MOZ',
    Mrt: 'MRT',
    Msr: 'MSR',
    Mtq: 'MTQ',
    Mus: 'MUS',
    Mwi: 'MWI',
    Mys: 'MYS',
    Myt: 'MYT',
    Nam: 'NAM',
    Ncl: 'NCL',
    Ner: 'NER',
    Nfk: 'NFK',
    Nga: 'NGA',
    Nic: 'NIC',
    Niu: 'NIU',
    Nld: 'NLD',
    Nor: 'NOR',
    Npl: 'NPL',
    Nru: 'NRU',
    Nzl: 'NZL',
    Omn: 'OMN',
    Pak: 'PAK',
    Pan: 'PAN',
    Pcn: 'PCN',
    Per: 'PER',
    Phl: 'PHL',
    Plw: 'PLW',
    Png: 'PNG',
    Pol: 'POL',
    Pri: 'PRI',
    Prk: 'PRK',
    Prt: 'PRT',
    Pry: 'PRY',
    Pse: 'PSE',
    Pyf: 'PYF',
    Qat: 'QAT',
    Reu: 'REU',
    Rks: 'RKS',
    Rou: 'ROU',
    Rus: 'RUS',
    Rwa: 'RWA',
    Sau: 'SAU',
    Sdn: 'SDN',
    Sen: 'SEN',
    Sgp: 'SGP',
    Sgs: 'SGS',
    Shn: 'SHN',
    Sjm: 'SJM',
    Slb: 'SLB',
    Sle: 'SLE',
    Slv: 'SLV',
    Smr: 'SMR',
    Som: 'SOM',
    Spm: 'SPM',
    Srb: 'SRB',
    Ssd: 'SSD',
    Stp: 'STP',
    Sur: 'SUR',
    Svk: 'SVK',
    Svn: 'SVN',
    Swe: 'SWE',
    Swz: 'SWZ',
    Sxm: 'SXM',
    Syc: 'SYC',
    Syr: 'SYR',
    Tca: 'TCA',
    Tcd: 'TCD',
    Tgo: 'TGO',
    Tha: 'THA',
    Tjk: 'TJK',
    Tkl: 'TKL',
    Tkm: 'TKM',
    Tls: 'TLS',
    Ton: 'TON',
    Tto: 'TTO',
    Tun: 'TUN',
    Tur: 'TUR',
    Tuv: 'TUV',
    Twn: 'TWN',
    Tza: 'TZA',
    Uga: 'UGA',
    Ukr: 'UKR',
    Umi: 'UMI',
    Ury: 'URY',
    Usa: 'USA',
    Uzb: 'UZB',
    Vat: 'VAT',
    Vct: 'VCT',
    Ven: 'VEN',
    Vgb: 'VGB',
    Vir: 'VIR',
    Vnm: 'VNM',
    Vut: 'VUT',
    Wlf: 'WLF',
    Wsm: 'WSM',
    Yem: 'YEM',
    Zaf: 'ZAF',
    Zmb: 'ZMB',
    Zwe: 'ZWE',
    UnknownDefaultOpenApi: '11184809'
};
exports.DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum = {
    AndroidSdk: 'onfido-android-sdk',
    IosSdk: 'onfido-ios-sdk',
    WebSdk: 'onfido-web-sdk',
    UnknownDefaultOpenApi: '11184809'
};
exports.DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum = {
    SdkToken: 'sdk_token',
    MobileToken: 'mobile_token',
    ApiToken: 'api_token',
    UnknownDefaultOpenApi: '11184809'
};
exports.DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum = {
    NotEnoughData: 'NOT_ENOUGH_DATA',
    HighRisk: 'HIGH_RISK',
    LowRisk: 'LOW_RISK',
    UnknownDefaultOpenApi: '11184809'
};
exports.DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum = {
    Live: 'live',
    UnknownMethod: 'unknown_method',
    UnknownDefaultOpenApi: '11184809'
};
exports.DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum = {
    Live: 'live',
    UnknownMethod: 'unknown_method',
    UnknownDefaultOpenApi: '11184809'
};
exports.DocumentSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
};
exports.DocumentPropertiesNistIdentityEvidenceStrengthEnum = {
    Superior: 'superior',
    Strong: 'strong',
    Fair: 'fair',
    Weak: 'weak',
    Unacceptable: 'unacceptable',
    UnspecifiedIdentityEvidenceStrength: 'unspecified_identity_evidence_strength',
    UnknownDefaultOpenApi: '11184809'
};
exports.DocumentPropertiesHasIssuanceConfirmationEnum = {
    True: 'true',
    False: 'false',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
};
exports.DocumentPropertiesSecurityTierEnum = {
    Tier1: 'tier_1',
    Tier2: 'tier_2',
    Tier3: 'tier_3',
    Tier4: 'tier_4',
    Tier5: 'tier_5',
    UnspecifiedSecurityTier: 'unspecified_security_tier',
    UnknownDefaultOpenApi: '11184809'
};
exports.DocumentSharedSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.DocumentTypes = {
    Passport: 'passport',
    DrivingLicence: 'driving_licence',
    NationalIdentityCard: 'national_identity_card',
    ResidencePermit: 'residence_permit',
    PassportCard: 'passport_card',
    TaxId: 'tax_id',
    Visa: 'visa',
    VoterId: 'voter_id',
    ResidenceStatusDocument: 'residence_status_document',
    PostalIdentityCard: 'postal_identity_card',
    SocialSecurityCard: 'social_security_card',
    WorkPermit: 'work_permit',
    AsylumRegistrationCard: 'asylum_registration_card',
    NationalHealthInsuranceCard: 'national_health_insurance_card',
    MunicipalityIdentityCard: 'municipality_identity_card',
    PrivateOperatorsCard: 'private_operators_card',
    ProofOfCitizenship: 'proof_of_citizenship',
    ServiceIdCard: 'service_id_card',
    ImmigrationStatusDocument: 'immigration_status_document',
    IndigenousCard: 'indigenous_card',
    VehicleRegistrationCard: 'vehicle_registration_card',
    CertificateOfNaturalisation: 'certificate_of_naturalisation',
    ProfessionalQualificationCard: 'professional_qualification_card',
    ConsularId: 'consular_id',
    InternationalDrivingLicence: 'international_driving_licence',
    HomeOfficeLetter: 'home_office_letter',
    BirthCertificate: 'birth_certificate',
    VehicleRegistrationCertificate: 'vehicle_registration_certificate',
    FormForAffixingTheVisa: 'form_for_affixing_the_visa',
    IdentificationNumberDocument: 'identification_number_document',
    AdoptionCertificate: 'adoption_certificate',
    BankBuildingSocietyStatement: 'bank_building_society_statement',
    BankStatement: 'bank_statement',
    BenefitLetters: 'benefit_letters',
    Cbt: 'cbt',
    CertificateOfSponsorship: 'certificate_of_sponsorship',
    CharacterReference: 'character_reference',
    CivilPartnershipCertificate: 'civil_partnership_certificate',
    CouncilTax: 'council_tax',
    CreditCardStatement: 'credit_card_statement',
    DeedPoll: 'deed_poll',
    DivorceAbsoluteDecree: 'divorce_absolute_decree',
    EducationalStatement: 'educational_statement',
    ElectricityBill: 'electricity_bill',
    GasBill: 'gas_bill',
    GovernmentLetter: 'government_letter',
    InternetBill: 'internet_bill',
    MarriageCertificate: 'marriage_certificate',
    MotorcycleInsurance: 'motorcycle_insurance',
    NationalInsuranceCard: 'national_insurance_card',
    NaturalisationCertificate: 'naturalisation_certificate',
    NonUkDrivingLicence: 'non_uk_driving_licence',
    P45P60: 'p45_p60',
    Payslip: 'payslip',
    PhoneBill: 'phone_bill',
    ProfessionalIdentificationCard: 'professional_identification_card',
    RightToWorkShareCodeResult: 'right_to_work_share_code_result',
    StatementFact: 'statement_fact',
    T4StudentUniversityTermDatesEvidence: 't4_student_university_term_dates_evidence',
    UkBiometricResidencePermit: 'uk_biometric_residence_permit',
    UkDrivingLicence: 'uk_driving_licence',
    Unknown: 'unknown',
    UtilityBill: 'utility_bill',
    UtilityBillElectric: 'utility_bill_electric',
    UtilityBillGas: 'utility_bill_gas',
    UtilityBillOther: 'utility_bill_other',
    WaterBill: 'water_bill',
    AddressCertificate: 'address_certificate',
    GeneralLetter: 'general_letter',
    InsuranceStatement: 'insurance_statement',
    PensionPropertyStatementLetter: 'pension_property_statement_letter',
    MortgageStatement: 'mortgage_statement',
    MobilePhoneBill: 'mobile_phone_bill',
    IdentityDocumentWithAddress: 'identity_document_with_address',
    ExchangeHouseStatement: 'exchange_house_statement',
    AccommodationTenancyCertificate: 'accommodation_tenancy_certificate',
    UnknownDefaultOpenApi: '11184809'
};
exports.DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum = {
    Superior: 'superior',
    Strong: 'strong',
    Fair: 'fair',
    Weak: 'weak',
    Unacceptable: 'unacceptable',
    UnspecifiedIdentityEvidenceStrength: 'unspecified_identity_evidence_strength',
    UnknownDefaultOpenApi: '11184809'
};
exports.DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum = {
    True: 'true',
    False: 'false',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
};
exports.DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum = {
    Tier1: 'tier_1',
    Tier2: 'tier_2',
    Tier3: 'tier_3',
    Tier4: 'tier_4',
    Tier5: 'tier_5',
    UnspecifiedSecurityTier: 'unspecified_security_tier',
    UnknownDefaultOpenApi: '11184809'
};
exports.ExtractionDocumentClassificationSubtypeEnum = {
    Full: 'full',
    NotFull: 'not_full',
    Provisional: 'provisional',
    UnknownDefaultOpenApi: '11184809'
};
exports.ExtractionExtractedDataGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
};
exports.IdNumberTypeEnum = {
    Ssn: 'ssn',
    SocialInsurance: 'social_insurance',
    TaxId: 'tax_id',
    IdentityCard: 'identity_card',
    DrivingLicense: 'driving_license',
    DrivingLicence: 'driving_licence',
    ShareCode: 'share_code',
    VoterId: 'voter_id',
    Passport: 'passport',
    Other: 'other',
    UnknownDefaultOpenApi: '11184809'
};
exports.ProofOfAddressPropertiesDocumentTypeEnum = {
    BankBuildingSocietyStatement: 'bank_building_society_statement',
    UtilityBill: 'utility_bill',
    CouncilTax: 'council_tax',
    BenefitLetters: 'benefit_letters',
    MortgageStatement: 'mortgage_statement',
    MobilePhoneBill: 'mobile_phone_bill',
    GeneralLetter: 'general_letter',
    InsuranceStatement: 'insurance_statement',
    PensionPropertyStatementLetter: 'pension_property_statement_letter',
    IdentityDocumentWithAddress: 'identity_document_with_address',
    ExchangeHouseStatement: 'exchange_house_statement',
    UnknownDefaultOpenApi: '11184809'
};
exports.RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum = {
    Match: 'match',
    Mismatch: 'mismatch',
    UnknownDefaultOpenApi: '11184809'
};
exports.RepeatAttemptsListRepeatAttemptsInnerNamesEnum = {
    Match: 'match',
    Mismatch: 'mismatch',
    UnknownDefaultOpenApi: '11184809'
};
exports.RepeatAttemptsListRepeatAttemptsInnerResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ReportName = {
    Document: 'document',
    DocumentVideo: 'document_video',
    DocumentVideoWithAddressInformation: 'document_video_with_address_information',
    DocumentWithAddressInformation: 'document_with_address_information',
    DocumentWithDrivingLicenceInformation: 'document_with_driving_licence_information',
    DocumentWithDriverVerification: 'document_with_driver_verification',
    FacialSimilarityPhoto: 'facial_similarity_photo',
    FacialSimilarityPhotoFullyAuto: 'facial_similarity_photo_fully_auto',
    FacialSimilarityVideo: 'facial_similarity_video',
    FacialSimilarityMotion: 'facial_similarity_motion',
    KnownFaces: 'known_faces',
    IdentityEnhanced: 'identity_enhanced',
    WatchlistAml: 'watchlist_aml',
    WatchlistEnhanced: 'watchlist_enhanced',
    WatchlistStandard: 'watchlist_standard',
    WatchlistPepsOnly: 'watchlist_peps_only',
    WatchlistSanctionsOnly: 'watchlist_sanctions_only',
    ProofOfAddress: 'proof_of_address',
    UsDrivingLicence: 'us_driving_licence',
    DeviceIntelligence: 'device_intelligence',
    IndiaPan: 'india_pan',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The result of the report. Read-only.
 * @export
 * @enum {string}
 */
exports.ReportResult = {
    Clear: 'clear',
    Consider: 'consider',
    Unidentified: 'unidentified',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The current state of the report in the checking process. Read-only.
 * @export
 * @enum {string}
 */
exports.ReportStatus = {
    AwaitingData: 'awaiting_data',
    AwaitingApproval: 'awaiting_approval',
    Cancelled: 'cancelled',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The sub_result of the report. It gives a more detailed result for document reports only, and will be null otherwise. Read-only.
 * @export
 * @enum {string}
 */
exports.ReportSubResult = {
    Clear: 'clear',
    Rejected: 'rejected',
    Suspected: 'suspected',
    Caution: 'caution',
    UnknownDefaultOpenApi: '11184809'
};
exports.ResultsFeedbackExpectedResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
};
exports.UsDrivingLicenceBuilderDocumentCategoryEnum = {
    DriverLicense: 'driver license',
    DriverPermit: 'driver permit',
    IdCard: 'id card',
    UnknownDefaultOpenApi: '11184809'
};
exports.UsDrivingLicenceBuilderEyeColorCodeEnum = {
    Blk: 'BLK',
    Blu: 'BLU',
    Bro: 'BRO',
    Dic: 'DIC',
    Gry: 'GRY',
    Grn: 'GRN',
    Haz: 'HAZ',
    Mar: 'MAR',
    Pnk: 'PNK',
    UnknownDefaultOpenApi: '11184809'
};
exports.UsDrivingLicenceBuilderGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
};
exports.UsDrivingLicenceSharedDocumentCategoryEnum = {
    DriverLicense: 'driver license',
    DriverPermit: 'driver permit',
    IdCard: 'id card',
    UnknownDefaultOpenApi: '11184809'
};
exports.UsDrivingLicenceSharedEyeColorCodeEnum = {
    Blk: 'BLK',
    Blu: 'BLU',
    Bro: 'BRO',
    Dic: 'DIC',
    Gry: 'GRY',
    Grn: 'GRN',
    Haz: 'HAZ',
    Mar: 'MAR',
    Pnk: 'PNK',
    UnknownDefaultOpenApi: '11184809'
};
exports.UsDrivingLicenceSharedGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
};
exports.WatchlistMonitorReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
};
exports.WatchlistMonitorBuilderReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
};
exports.WatchlistMonitorSharedReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * The current state of the object, if available.
 * @export
 * @enum {string}
 */
exports.WebhookEventObjectStatus = {
    Processing: 'processing',
    AwaitingInput: 'awaiting_input',
    AwaitingClientInput: 'awaiting_client_input',
    Approved: 'approved',
    Declined: 'declined',
    Review: 'review',
    Abandoned: 'abandoned',
    Error: 'error',
    Started: 'started',
    Cancelled: 'cancelled',
    Completed: 'completed',
    AwaitingData: 'awaiting_data',
    AwaitingApproval: 'awaiting_approval',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    InProgress: 'in_progress',
    AwaitingApplicant: 'awaiting_applicant',
    Paused: 'paused',
    Reopened: 'reopened',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WebhookEventResourceType = {
    Check: 'check',
    Report: 'report',
    AuditLog: 'audit_log',
    WorkflowRun: 'workflow_run',
    WorkflowTask: 'workflow_task',
    WatchlistMonitor: 'watchlist_monitor',
    WorkflowTimelineFile: 'workflow_timeline_file',
    WorkflowRunEvidenceFolder: 'workflow_run_evidence_folder',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WebhookEventType = {
    AuditLogCreated: 'audit_log.created',
    WatchlistMonitorMatchesUpdated: 'watchlist_monitor.matches_updated',
    WorkflowRunCompleted: 'workflow_run.completed',
    WorkflowTaskStarted: 'workflow_task.started',
    WorkflowTaskCompleted: 'workflow_task.completed',
    CheckStarted: 'check.started',
    CheckReopened: 'check.reopened',
    CheckWithdrawn: 'check.withdrawn',
    CheckCompleted: 'check.completed',
    CheckFormCompleted: 'check.form_completed',
    ReportWithdrawn: 'report.withdrawn',
    ReportResumed: 'report.resumed',
    ReportCancelled: 'report.cancelled',
    ReportAwaitingApproval: 'report.awaiting_approval',
    ReportCompleted: 'report.completed',
    WorkflowTimelineFileCreated: 'workflow_timeline_file.created',
    WorkflowRunEvidenceFolderCreated: 'workflow_run_evidence_folder.created',
    UnknownDefaultOpenApi: '11184809'
};
exports.WorkflowRunLinkLanguageEnum = {
    EnUs: 'en_US',
    DeDe: 'de_DE',
    EsEs: 'es_ES',
    FrFr: 'fr_FR',
    ItIt: 'it_IT',
    PtPt: 'pt_PT',
    NlNl: 'nl_NL',
    UnknownDefaultOpenApi: '11184809'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.WorkflowRunStatus = {
    Processing: 'processing',
    AwaitingInput: 'awaiting_input',
    AwaitingClientInput: 'awaiting_client_input',
    Approved: 'approved',
    Declined: 'declined',
    Review: 'review',
    Abandoned: 'abandoned',
    Error: 'error',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * DefaultApi - axios parameter creator
 * @export
 */
const DefaultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Cancels single paused reports.
         * @summary Cancel report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: (reportId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'reportId' is not null or undefined
            (0, common_1.assertParamExists)('cancelReport', 'reportId', reportId);
            const localVarPath = `/reports/{report_id}/cancel`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Completes a Send / Receive Data Task.
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: (workflowRunId, taskId, completeTaskBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            (0, common_1.assertParamExists)('completeTask', 'workflowRunId', workflowRunId);
            // verify required parameter 'taskId' is not null or undefined
            (0, common_1.assertParamExists)('completeTask', 'taskId', taskId);
            // verify required parameter 'completeTaskBuilder' is not null or undefined
            (0, common_1.assertParamExists)('completeTask', 'completeTaskBuilder', completeTaskBuilder);
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}/complete`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(completeTaskBuilder, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a single applicant. Returns an applicant object.
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant: (applicantBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantBuilder' is not null or undefined
            (0, common_1.assertParamExists)('createApplicant', 'applicantBuilder', applicantBuilder);
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(applicantBuilder, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object.
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck: (checkBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkBuilder' is not null or undefined
            (0, common_1.assertParamExists)('createCheck', 'checkBuilder', checkBuilder);
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(checkBuilder, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run.
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            (0, common_1.assertParamExists)('createTimelineFile', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/timeline_file`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates a new monitor for the applicant
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor: (watchlistMonitorBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'watchlistMonitorBuilder' is not null or undefined
            (0, common_1.assertParamExists)('createWatchlistMonitor', 'watchlistMonitorBuilder', watchlistMonitorBuilder);
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(watchlistMonitorBuilder, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Registers a webhook. Returns a webhook object.
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: (webhookBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookBuilder' is not null or undefined
            (0, common_1.assertParamExists)('createWebhook', 'webhookBuilder', webhookBuilder);
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookBuilder, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object.
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun: (workflowRunBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunBuilder' is not null or undefined
            (0, common_1.assertParamExists)('createWorkflowRun', 'workflowRunBuilder', workflowRunBuilder);
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowRunBuilder, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a single applicant.
         * @summary Delete Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('deleteApplicant', 'applicantId', applicantId);
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deactivates the given monitor
         * @summary Delete monitor
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor: (monitorId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            (0, common_1.assertParamExists)('deleteWatchlistMonitor', 'monitorId', monitorId);
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a webhook.
         * @summary Delete a webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: (webhookId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookId' is not null or undefined
            (0, common_1.assertParamExists)('deleteWebhook', 'webhookId', webhookId);
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF.
         * @summary Download check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck: (checkId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkId' is not null or undefined
            (0, common_1.assertParamExists)('downloadCheck', 'checkId', checkId);
            const localVarPath = `/checks/{check_id}/download`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument: (documentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'documentId' is not null or undefined
            (0, common_1.assertParamExists)('downloadDocument', 'documentId', documentId);
            const localVarPath = `/documents/{document_id}/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video.
         * @summary Download document video
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo: (documentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'documentId' is not null or undefined
            (0, common_1.assertParamExists)('downloadDocumentVideo', 'documentId', documentId);
            const localVarPath = `/documents/{document_id}/video/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the evidence folder for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Folder
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEvidenceFolder: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            (0, common_1.assertParamExists)('downloadEvidenceFolder', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/evidence_folder`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto: (idPhotoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'idPhotoId' is not null or undefined
            (0, common_1.assertParamExists)('downloadIdPhoto', 'idPhotoId', idPhotoId);
            const localVarPath = `/id_photos/{id_photo_id}/download`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto: (livePhotoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'livePhotoId' is not null or undefined
            (0, common_1.assertParamExists)('downloadLivePhoto', 'livePhotoId', livePhotoId);
            const localVarPath = `/live_photos/{live_photo_id}/download`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo: (liveVideoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'liveVideoId' is not null or undefined
            (0, common_1.assertParamExists)('downloadLiveVideo', 'liveVideoId', liveVideoId);
            const localVarPath = `/live_videos/{live_video_id}/download`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame: (liveVideoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'liveVideoId' is not null or undefined
            (0, common_1.assertParamExists)('downloadLiveVideoFrame', 'liveVideoId', liveVideoId);
            const localVarPath = `/live_videos/{live_video_id}/frame`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture: (motionCaptureId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'motionCaptureId' is not null or undefined
            (0, common_1.assertParamExists)('downloadMotionCapture', 'motionCaptureId', motionCaptureId);
            const localVarPath = `/motion_captures/{motion_capture_id}/download`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame: (motionCaptureId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'motionCaptureId' is not null or undefined
            (0, common_1.assertParamExists)('downloadMotionCaptureFrame', 'motionCaptureId', motionCaptureId);
            const localVarPath = `/motion_captures/{motion_capture_id}/frame`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download NFC face
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadNfcFace: (documentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'documentId' is not null or undefined
            (0, common_1.assertParamExists)('downloadNfcFace', 'documentId', documentId);
            const localVarPath = `/documents/{document_id}/nfc_face`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the signed document or application form depending on the file_id provided.
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument: (workflowRunId, fileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            (0, common_1.assertParamExists)('downloadQesDocument', 'workflowRunId', workflowRunId);
            // verify required parameter 'fileId' is not null or undefined
            (0, common_1.assertParamExists)('downloadQesDocument', 'fileId', fileId);
            const localVarPath = `/qualified_electronic_signature/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (workflowRunId !== undefined) {
                localVarQueryParameter['workflow_run_id'] = workflowRunId;
            }
            if (fileId !== undefined) {
                localVarQueryParameter['file_id'] = fileId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the signed evidence file for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            (0, common_1.assertParamExists)('downloadSignedEvidenceFile', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/signed_evidence_file`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Extract information from a document
         * @summary Autofill
         * @param {ExtractRequest} extractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract: (extractRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'extractRequest' is not null or undefined
            (0, common_1.assertParamExists)('extract', 'extractRequest', extractRequest);
            const localVarPath = `/extractions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(extractRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search for addresses by postcode
         * @summary Address Picker
         * @param {string} postcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses: (postcode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'postcode' is not null or undefined
            (0, common_1.assertParamExists)('findAddresses', 'postcode', postcode);
            const localVarPath = `/addresses/pick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (postcode !== undefined) {
                localVarQueryParameter['postcode'] = postcode;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single applicant. Returns an applicant object.
         * @summary Retrieve Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('findApplicant', 'applicantId', applicantId);
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck: (checkId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkId' is not null or undefined
            (0, common_1.assertParamExists)('findCheck', 'checkId', checkId);
            const localVarPath = `/checks/{check_id}`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
         * @summary Retrieve document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument: (documentId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'documentId' is not null or undefined
            (0, common_1.assertParamExists)('findDocument', 'documentId', documentId);
            const localVarPath = `/documents/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single ID photo. Returns a ID photo object.
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto: (idPhotoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'idPhotoId' is not null or undefined
            (0, common_1.assertParamExists)('findIdPhoto', 'idPhotoId', idPhotoId);
            const localVarPath = `/id_photos/{id_photo_id}`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single live photo. Returns a live photo object.
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto: (livePhotoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'livePhotoId' is not null or undefined
            (0, common_1.assertParamExists)('findLivePhoto', 'livePhotoId', livePhotoId);
            const localVarPath = `/live_photos/{live_photo_id}`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single live video. Returns the corresponding live video object.
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo: (liveVideoId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'liveVideoId' is not null or undefined
            (0, common_1.assertParamExists)('findLiveVideo', 'liveVideoId', liveVideoId);
            const localVarPath = `/live_videos/{live_video_id}`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object.
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture: (motionCaptureId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'motionCaptureId' is not null or undefined
            (0, common_1.assertParamExists)('findMotionCapture', 'motionCaptureId', motionCaptureId);
            const localVarPath = `/motion_captures/{motion_capture_id}`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier.
         * @summary Retrieve report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport: (reportId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'reportId' is not null or undefined
            (0, common_1.assertParamExists)('findReport', 'reportId', reportId);
            const localVarPath = `/reports/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask: (workflowRunId, taskId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            (0, common_1.assertParamExists)('findTask', 'workflowRunId', workflowRunId);
            // verify required parameter 'taskId' is not null or undefined
            (0, common_1.assertParamExists)('findTask', 'taskId', taskId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the Timeline File for the designated Workflow Run.
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile: (workflowRunId, timelineFileId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            (0, common_1.assertParamExists)('findTimelineFile', 'workflowRunId', workflowRunId);
            // verify required parameter 'timelineFileId' is not null or undefined
            (0, common_1.assertParamExists)('findTimelineFile', 'timelineFileId', timelineFileId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/timeline_file/{timeline_file_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"timeline_file_id"}}`, encodeURIComponent(String(timelineFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single monitor
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor: (monitorId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            (0, common_1.assertParamExists)('findWatchlistMonitor', 'monitorId', monitorId);
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single webhook. Returns a webhook object.
         * @summary Retrieve a Webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook: (webhookId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookId' is not null or undefined
            (0, common_1.assertParamExists)('findWebhook', 'webhookId', webhookId);
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            (0, common_1.assertParamExists)('findWorkflowRun', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update.
         * @summary Force new report creation (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor: (monitorId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            (0, common_1.assertParamExists)('forceReportCreationFromWatchlistMonitor', 'monitorId', monitorId);
            const localVarPath = `/watchlist_monitors/{monitor_id}/new_report`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generates an SDK token. Returns a token object containing the SDK token.
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken: (sdkTokenBuilder, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'sdkTokenBuilder' is not null or undefined
            (0, common_1.assertParamExists)('generateSdkToken', 'sdkTokenBuilder', sdkTokenBuilder);
            const localVarPath = `/sdk_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(sdkTokenBuilder, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order.
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants: (page, perPage, includeDeleted, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve Checks
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('listChecks', 'applicantId', applicantId);
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('listDocuments', 'applicantId', applicantId);
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists the ID photos that belong to an applicant.
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('listIdPhotos', 'applicantId', applicantId);
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists the live photos that belong to an applicant.
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('listLivePhotos', 'applicantId', applicantId);
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the live videos that belong to an applicant.
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('listLiveVideos', 'applicantId', applicantId);
            const localVarPath = `/live_videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all the motion captures that belong to an applicant.
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('listMotionCaptures', 'applicantId', applicantId);
            const localVarPath = `/motion_captures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all repeat attempts for a given Document report
         * @summary Retrieve repeat attempts
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts: (reportId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'reportId' is not null or undefined
            (0, common_1.assertParamExists)('listRepeatAttempts', 'reportId', reportId);
            const localVarPath = `/repeat_attempts/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * All the reports belonging to a particular check can be listed from this endpoint.
         * @summary List reports
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports: (checkId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkId' is not null or undefined
            (0, common_1.assertParamExists)('listReports', 'checkId', checkId);
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (checkId !== undefined) {
                localVarQueryParameter['check_id'] = checkId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: (workflowRunId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'workflowRunId' is not null or undefined
            (0, common_1.assertParamExists)('listTasks', 'workflowRunId', workflowRunId);
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status
         * @summary List matches (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches: (monitorId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            (0, common_1.assertParamExists)('listWatchlistMonitorMatches', 'monitorId', monitorId);
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all available monitors for an applicant
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors: (applicantId, includeDeleted, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('listWatchlistMonitors', 'applicantId', applicantId);
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists all webhooks you\'ve created.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects.
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {string} [applicantId] the applicant\&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns: (page, status, createdAtGt, createdAtLt, sort, applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt instanceof Date) ?
                    createdAtGt.toISOString() :
                    createdAtGt;
            }
            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt instanceof Date) ?
                    createdAtLt.toISOString() :
                    createdAtLt;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Run a health check on the Onfido API
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create Feedback on checks and reports
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback: (resultsFeedback, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'resultsFeedback' is not null or undefined
            (0, common_1.assertParamExists)('postResultsFeedback', 'resultsFeedback', resultsFeedback);
            const localVarPath = `/results_feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(resultsFeedback, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Resends events to all webhooks registered with a matching environment in your account.
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks: (webhookResend, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookResend' is not null or undefined
            (0, common_1.assertParamExists)('resendWebhooks', 'webhookResend', webhookResend);
            const localVarPath = `/webhooks/resend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookResend, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Restores a single applicant scheduled for deletion.
         * @summary Restore Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant: (applicantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('restoreApplicant', 'applicantId', applicantId);
            const localVarPath = `/applicants/{applicant_id}/restore`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Resumes a paused check.
         * @summary Resume a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck: (checkId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'checkId' is not null or undefined
            (0, common_1.assertParamExists)('resumeCheck', 'checkId', checkId);
            const localVarPath = `/checks/{check_id}/resume`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Resumes a single paused report.
         * @summary Resume report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport: (reportId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'reportId' is not null or undefined
            (0, common_1.assertParamExists)('resumeReport', 'reportId', reportId);
            const localVarPath = `/reports/{report_id}/resume`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant
         * @summary Update Applicant
         * @param {string} applicantId
         * @param {ApplicantUpdater} applicantUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant: (applicantId, applicantUpdater, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('updateApplicant', 'applicantId', applicantId);
            // verify required parameter 'applicantUpdater' is not null or undefined
            (0, common_1.assertParamExists)('updateApplicant', 'applicantUpdater', applicantUpdater);
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(applicantUpdater, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the status of the given matches
         * @summary Set match status (BETA)
         * @param {string} monitorId
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch: (monitorId, watchlistMonitorMatchesUpdater, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'monitorId' is not null or undefined
            (0, common_1.assertParamExists)('updateWatchlistMonitorMatch', 'monitorId', monitorId);
            // verify required parameter 'watchlistMonitorMatchesUpdater' is not null or undefined
            (0, common_1.assertParamExists)('updateWatchlistMonitorMatch', 'watchlistMonitorMatchesUpdater', watchlistMonitorMatchesUpdater);
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(watchlistMonitorMatchesUpdater, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Edits a webhook. Returns the updated webhook object.
         * @summary Edit a webhook
         * @param {string} webhookId
         * @param {WebhookUpdater} webhookUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: (webhookId, webhookUpdater, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'webhookId' is not null or undefined
            (0, common_1.assertParamExists)('updateWebhook', 'webhookId', webhookId);
            // verify required parameter 'webhookUpdater' is not null or undefined
            (0, common_1.assertParamExists)('updateWebhook', 'webhookUpdater', webhookUpdater);
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webhookUpdater, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB.
         * @summary Upload a document
         * @param {DocumentTypes} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {string} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument: (type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'type' is not null or undefined
            (0, common_1.assertParamExists)('uploadDocument', 'type', type);
            // verify required parameter 'applicantId' is not null or undefined
            (0, common_1.assertParamExists)('uploadDocument', 'applicantId', applicantId);
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('uploadDocument', 'file', file);
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (fileType !== undefined) {
                localVarFormParams.append('file_type', fileType);
            }
            if (type !== undefined) {
                localVarFormParams.append('type', type);
            }
            if (side !== undefined) {
                localVarFormParams.append('side', side);
            }
            if (issuingCountry !== undefined) {
                localVarFormParams.append('issuing_country', issuingCountry);
            }
            if (applicantId !== undefined) {
                localVarFormParams.append('applicant_id', applicantId);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file.buffer, file.filename);
            }
            if (validateImageQuality !== undefined) {
                localVarFormParams.append('validate_image_quality', String(validateImageQuality));
            }
            if (location !== undefined) {
                localVarFormParams.append('location', JSON.stringify(location));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB.
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto: (applicantId, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarFormParams.append('applicant_id', applicantId);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file.buffer, file.filename);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false.
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto: (applicantId, file, advancedValidation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            // authentication Token required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "Authorization", configuration);
            if (applicantId !== undefined) {
                localVarFormParams.append('applicant_id', applicantId);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file.buffer, file.filename);
            }
            if (advancedValidation !== undefined) {
                localVarFormParams.append('advanced_validation', String(advancedValidation));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DefaultApiAxiosParamCreator = DefaultApiAxiosParamCreator;
/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.DefaultApiAxiosParamCreator)(configuration);
    return {
        /**
         * Cancels single paused reports.
         * @summary Cancel report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport(reportId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelReport(reportId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.cancelReport']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Completes a Send / Receive Data Task.
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(workflowRunId, taskId, completeTaskBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.completeTask(workflowRunId, taskId, completeTaskBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.completeTask']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a single applicant. Returns an applicant object.
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant(applicantBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createApplicant(applicantBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object.
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck(checkBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCheck(checkBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run.
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTimelineFile(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createTimelineFile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates a new monitor for the applicant
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor(watchlistMonitorBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWatchlistMonitor(watchlistMonitorBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createWatchlistMonitor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Registers a webhook. Returns a webhook object.
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(webhookBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWebhook(webhookBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object.
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun(workflowRunBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWorkflowRun(workflowRunBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.createWorkflowRun']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a single applicant.
         * @summary Delete Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteApplicant(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.deleteApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deactivates the given monitor
         * @summary Delete monitor
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor(monitorId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWatchlistMonitor(monitorId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.deleteWatchlistMonitor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deletes a webhook.
         * @summary Delete a webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWebhook(webhookId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.deleteWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF.
         * @summary Download check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck(checkId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadCheck(checkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadDocument(documentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video.
         * @summary Download document video
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo(documentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadDocumentVideo(documentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadDocumentVideo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the evidence folder for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Folder
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEvidenceFolder(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadEvidenceFolder(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadEvidenceFolder']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto(idPhotoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadIdPhoto(idPhotoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadIdPhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto(livePhotoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadLivePhoto(livePhotoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadLivePhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo(liveVideoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadLiveVideo(liveVideoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadLiveVideo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame(liveVideoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadLiveVideoFrame(liveVideoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadLiveVideoFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture(motionCaptureId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadMotionCapture(motionCaptureId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadMotionCapture']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame(motionCaptureId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadMotionCaptureFrame(motionCaptureId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadMotionCaptureFrame']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download NFC face
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadNfcFace(documentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadNfcFace(documentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadNfcFace']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided.
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument(workflowRunId, fileId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadQesDocument(workflowRunId, fileId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadQesDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.downloadSignedEvidenceFile(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.downloadSignedEvidenceFile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Extract information from a document
         * @summary Autofill
         * @param {ExtractRequest} extractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract(extractRequest, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.extract(extractRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.extract']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Search for addresses by postcode
         * @summary Address Picker
         * @param {string} postcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses(postcode, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findAddresses(postcode, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findAddresses']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single applicant. Returns an applicant object.
         * @summary Retrieve Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findApplicant(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck(checkId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findCheck(checkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
         * @summary Retrieve document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument(documentId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findDocument(documentId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object.
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto(idPhotoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findIdPhoto(idPhotoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findIdPhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single live photo. Returns a live photo object.
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto(livePhotoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findLivePhoto(livePhotoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findLivePhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object.
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo(liveVideoId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findLiveVideo(liveVideoId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findLiveVideo']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object.
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture(motionCaptureId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findMotionCapture(motionCaptureId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findMotionCapture']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier.
         * @summary Retrieve report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport(reportId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findReport(reportId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findReport']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask(workflowRunId, taskId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findTask(workflowRunId, taskId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findTask']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run.
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile(workflowRunId, timelineFileId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findTimelineFile(workflowRunId, timelineFileId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findTimelineFile']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single monitor
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor(monitorId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findWatchlistMonitor(monitorId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findWatchlistMonitor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single webhook. Returns a webhook object.
         * @summary Retrieve a Webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook(webhookId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findWebhook(webhookId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.findWorkflowRun(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.findWorkflowRun']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update.
         * @summary Force new report creation (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor(monitorId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.forceReportCreationFromWatchlistMonitor(monitorId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.forceReportCreationFromWatchlistMonitor']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token.
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken(sdkTokenBuilder, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateSdkToken(sdkTokenBuilder, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.generateSdkToken']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order.
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants(page, perPage, includeDeleted, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listApplicants(page, perPage, includeDeleted, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listApplicants']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve Checks
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listChecks(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listChecks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listDocuments(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listDocuments']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists the ID photos that belong to an applicant.
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listIdPhotos(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listIdPhotos']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists the live photos that belong to an applicant.
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listLivePhotos(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listLivePhotos']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the live videos that belong to an applicant.
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listLiveVideos(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listLiveVideos']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all the motion captures that belong to an applicant.
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listMotionCaptures(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listMotionCaptures']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Returns all repeat attempts for a given Document report
         * @summary Retrieve repeat attempts
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts(reportId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listRepeatAttempts(reportId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listRepeatAttempts']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint.
         * @summary List reports
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports(checkId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listReports(checkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listReports']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(workflowRunId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTasks(workflowRunId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listTasks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status
         * @summary List matches (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches(monitorId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWatchlistMonitorMatches(monitorId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listWatchlistMonitorMatches']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all available monitors for an applicant
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors(applicantId, includeDeleted, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWatchlistMonitors(applicantId, includeDeleted, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listWatchlistMonitors']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Lists all webhooks you\'ve created.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWebhooks(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listWebhooks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects.
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {string} [applicantId] the applicant\&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.listWorkflowRuns']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Run a health check on the Onfido API
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ping(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.ping']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create Feedback on checks and reports
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback(resultsFeedback, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postResultsFeedback(resultsFeedback, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.postResultsFeedback']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account.
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks(webhookResend, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resendWebhooks(webhookResend, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.resendWebhooks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Restores a single applicant scheduled for deletion.
         * @summary Restore Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant(applicantId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.restoreApplicant(applicantId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.restoreApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Resumes a paused check.
         * @summary Resume a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck(checkId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resumeCheck(checkId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.resumeCheck']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Resumes a single paused report.
         * @summary Resume report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport(reportId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resumeReport(reportId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.resumeReport']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant
         * @summary Update Applicant
         * @param {string} applicantId
         * @param {ApplicantUpdater} applicantUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant(applicantId, applicantUpdater, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateApplicant(applicantId, applicantUpdater, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.updateApplicant']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update the status of the given matches
         * @summary Set match status (BETA)
         * @param {string} monitorId
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.updateWatchlistMonitorMatch']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Edits a webhook. Returns the updated webhook object.
         * @summary Edit a webhook
         * @param {string} webhookId
         * @param {WebhookUpdater} webhookUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, webhookUpdater, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWebhook(webhookId, webhookUpdater, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.updateWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB.
         * @summary Upload a document
         * @param {DocumentTypes} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {string} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.uploadDocument']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB.
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto(applicantId, file, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadIdPhoto(applicantId, file, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.uploadIdPhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false.
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto(applicantId, file, advancedValidation, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadLivePhoto(applicantId, file, advancedValidation, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = base_1.operationServerMap['DefaultApi.uploadLivePhoto']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.DefaultApiFp = DefaultApiFp;
/**
 * DefaultApi - factory interface
 * @export
 */
const DefaultApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.DefaultApiFp)(configuration);
    return {
        /**
         * Cancels single paused reports.
         * @summary Cancel report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport(reportId, options) {
            return localVarFp.cancelReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a Send / Receive Data Task.
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(workflowRunId, taskId, completeTaskBuilder, options) {
            return localVarFp.completeTask(workflowRunId, taskId, completeTaskBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a single applicant. Returns an applicant object.
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant(applicantBuilder, options) {
            return localVarFp.createApplicant(applicantBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object.
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck(checkBuilder, options) {
            return localVarFp.createCheck(checkBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run.
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile(workflowRunId, options) {
            return localVarFp.createTimelineFile(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new monitor for the applicant
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor(watchlistMonitorBuilder, options) {
            return localVarFp.createWatchlistMonitor(watchlistMonitorBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a webhook. Returns a webhook object.
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(webhookBuilder, options) {
            return localVarFp.createWebhook(webhookBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object.
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun(workflowRunBuilder, options) {
            return localVarFp.createWorkflowRun(workflowRunBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single applicant.
         * @summary Delete Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant(applicantId, options) {
            return localVarFp.deleteApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates the given monitor
         * @summary Delete monitor
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor(monitorId, options) {
            return localVarFp.deleteWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a webhook.
         * @summary Delete a webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF.
         * @summary Download check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck(checkId, options) {
            return localVarFp.downloadCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId, options) {
            return localVarFp.downloadDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video.
         * @summary Download document video
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo(documentId, options) {
            return localVarFp.downloadDocumentVideo(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the evidence folder for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Folder
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEvidenceFolder(workflowRunId, options) {
            return localVarFp.downloadEvidenceFolder(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto(idPhotoId, options) {
            return localVarFp.downloadIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto(livePhotoId, options) {
            return localVarFp.downloadLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo(liveVideoId, options) {
            return localVarFp.downloadLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame(liveVideoId, options) {
            return localVarFp.downloadLiveVideoFrame(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture(motionCaptureId, options) {
            return localVarFp.downloadMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame(motionCaptureId, options) {
            return localVarFp.downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
         * @summary Download NFC face
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadNfcFace(documentId, options) {
            return localVarFp.downloadNfcFace(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided.
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument(workflowRunId, fileId, options) {
            return localVarFp.downloadQesDocument(workflowRunId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile(workflowRunId, options) {
            return localVarFp.downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Extract information from a document
         * @summary Autofill
         * @param {ExtractRequest} extractRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract(extractRequest, options) {
            return localVarFp.extract(extractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for addresses by postcode
         * @summary Address Picker
         * @param {string} postcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses(postcode, options) {
            return localVarFp.findAddresses(postcode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single applicant. Returns an applicant object.
         * @summary Retrieve Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant(applicantId, options) {
            return localVarFp.findApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck(checkId, options) {
            return localVarFp.findCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
         * @summary Retrieve document
         * @param {string} documentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument(documentId, options) {
            return localVarFp.findDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object.
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto(idPhotoId, options) {
            return localVarFp.findIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single live photo. Returns a live photo object.
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto(livePhotoId, options) {
            return localVarFp.findLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object.
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo(liveVideoId, options) {
            return localVarFp.findLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object.
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture(motionCaptureId, options) {
            return localVarFp.findMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier.
         * @summary Retrieve report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport(reportId, options) {
            return localVarFp.findReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask(workflowRunId, taskId, options) {
            return localVarFp.findTask(workflowRunId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run.
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile(workflowRunId, timelineFileId, options) {
            return localVarFp.findTimelineFile(workflowRunId, timelineFileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single monitor
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor(monitorId, options) {
            return localVarFp.findWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single webhook. Returns a webhook object.
         * @summary Retrieve a Webhook
         * @param {string} webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook(webhookId, options) {
            return localVarFp.findWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun(workflowRunId, options) {
            return localVarFp.findWorkflowRun(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update.
         * @summary Force new report creation (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor(monitorId, options) {
            return localVarFp.forceReportCreationFromWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token.
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken(sdkTokenBuilder, options) {
            return localVarFp.generateSdkToken(sdkTokenBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order.
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants(page, perPage, includeDeleted, options) {
            return localVarFp.listApplicants(page, perPage, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single check. Returns a check object.
         * @summary Retrieve Checks
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks(applicantId, options) {
            return localVarFp.listChecks(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(applicantId, options) {
            return localVarFp.listDocuments(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the ID photos that belong to an applicant.
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos(applicantId, options) {
            return localVarFp.listIdPhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the live photos that belong to an applicant.
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos(applicantId, options) {
            return localVarFp.listLivePhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the live videos that belong to an applicant.
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos(applicantId, options) {
            return localVarFp.listLiveVideos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the motion captures that belong to an applicant.
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures(applicantId, options) {
            return localVarFp.listMotionCaptures(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all repeat attempts for a given Document report
         * @summary Retrieve repeat attempts
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts(reportId, options) {
            return localVarFp.listRepeatAttempts(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint.
         * @summary List reports
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports(checkId, options) {
            return localVarFp.listReports(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(workflowRunId, options) {
            return localVarFp.listTasks(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status
         * @summary List matches (BETA)
         * @param {string} monitorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches(monitorId, options) {
            return localVarFp.listWatchlistMonitorMatches(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available monitors for an applicant
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors(applicantId, includeDeleted, options) {
            return localVarFp.listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all webhooks you\'ve created.
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options) {
            return localVarFp.listWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects.
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {string} [applicantId] the applicant\&#39;s id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options) {
            return localVarFp.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a health check on the Onfido API
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Create Feedback on checks and reports
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback(resultsFeedback, options) {
            return localVarFp.postResultsFeedback(resultsFeedback, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account.
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks(webhookResend, options) {
            return localVarFp.resendWebhooks(webhookResend, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores a single applicant scheduled for deletion.
         * @summary Restore Applicant
         * @param {string} applicantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant(applicantId, options) {
            return localVarFp.restoreApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a paused check.
         * @summary Resume a Check
         * @param {string} checkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck(checkId, options) {
            return localVarFp.resumeCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a single paused report.
         * @summary Resume report
         * @param {string} reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport(reportId, options) {
            return localVarFp.resumeReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant
         * @summary Update Applicant
         * @param {string} applicantId
         * @param {ApplicantUpdater} applicantUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant(applicantId, applicantUpdater, options) {
            return localVarFp.updateApplicant(applicantId, applicantUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of the given matches
         * @summary Set match status (BETA)
         * @param {string} monitorId
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options) {
            return localVarFp.updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a webhook. Returns the updated webhook object.
         * @summary Edit a webhook
         * @param {string} webhookId
         * @param {WebhookUpdater} webhookUpdater
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, webhookUpdater, options) {
            return localVarFp.updateWebhook(webhookId, webhookUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB.
         * @summary Upload a document
         * @param {DocumentTypes} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {string} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options) {
            return localVarFp.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB.
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto(applicantId, file, options) {
            return localVarFp.uploadIdPhoto(applicantId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false.
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto(applicantId, file, advancedValidation, options) {
            return localVarFp.uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(axios, basePath));
        },
    };
};
exports.DefaultApiFactory = DefaultApiFactory;
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
class DefaultApi extends base_1.BaseAPI {
    /**
     * Cancels single paused reports.
     * @summary Cancel report
     * @param {string} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    cancelReport(reportId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).cancelReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Completes a Send / Receive Data Task.
     * @summary Complete Task
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to complete.
     * @param {CompleteTaskBuilder} completeTaskBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    completeTask(workflowRunId, taskId, completeTaskBuilder, options) {
        return (0, exports.DefaultApiFp)(this.configuration).completeTask(workflowRunId, taskId, completeTaskBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a single applicant. Returns an applicant object.
     * @summary Create Applicant
     * @param {ApplicantBuilder} applicantBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createApplicant(applicantBuilder, options) {
        return (0, exports.DefaultApiFp)(this.configuration).createApplicant(applicantBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiates a check for an applicant, which can contain one or more reports. Returns a check object.
     * @summary Create a check
     * @param {CheckBuilder} checkBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createCheck(checkBuilder, options) {
        return (0, exports.DefaultApiFp)(this.configuration).createCheck(checkBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Triggers the generation of the Timeline File for the designated Workflow Run.
     * @summary Create Timeline File for Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createTimelineFile(workflowRunId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).createTimelineFile(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new monitor for the applicant
     * @summary Create monitor
     * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createWatchlistMonitor(watchlistMonitorBuilder, options) {
        return (0, exports.DefaultApiFp)(this.configuration).createWatchlistMonitor(watchlistMonitorBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Registers a webhook. Returns a webhook object.
     * @summary Register webhook
     * @param {WebhookBuilder} webhookBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createWebhook(webhookBuilder, options) {
        return (0, exports.DefaultApiFp)(this.configuration).createWebhook(webhookBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and starts a Workflow Run. Returns a Workflow Run object.
     * @summary Create a Workflow Run
     * @param {WorkflowRunBuilder} workflowRunBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    createWorkflowRun(workflowRunBuilder, options) {
        return (0, exports.DefaultApiFp)(this.configuration).createWorkflowRun(workflowRunBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a single applicant.
     * @summary Delete Applicant
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    deleteApplicant(applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).deleteApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deactivates the given monitor
     * @summary Delete monitor
     * @param {string} monitorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    deleteWatchlistMonitor(monitorId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).deleteWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a webhook.
     * @summary Delete a webhook
     * @param {string} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    deleteWebhook(webhookId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF.
     * @summary Download check
     * @param {string} checkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadCheck(checkId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
     * @summary Download document
     * @param {string} documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadDocument(documentId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads a document video. If successful, the response will be the binary data representing the video.
     * @summary Download document video
     * @param {string} documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadDocumentVideo(documentId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadDocumentVideo(documentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the evidence folder for the designated Workflow Run
     * @summary Retrieve Workflow Run Evidence Folder
     * @param {string} workflowRunId Workflow Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadEvidenceFolder(workflowRunId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadEvidenceFolder(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * ID photos are downloaded using this endpoint.
     * @summary Download ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadIdPhoto(idPhotoId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Live photos are downloaded using this endpoint.
     * @summary Download live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadLivePhoto(livePhotoId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Live videos are downloaded using this endpoint.
     * @summary Download live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadLiveVideo(liveVideoId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the binary data representing a single frame from a live video.
     * @summary Download live video frame
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadLiveVideoFrame(liveVideoId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadLiveVideoFrame(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Motion captures are downloaded using this endpoint.
     * @summary Download motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadMotionCapture(motionCaptureId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
     * @summary Download motion capture frame
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadMotionCaptureFrame(motionCaptureId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image.
     * @summary Download NFC face
     * @param {string} documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadNfcFace(documentId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadNfcFace(documentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the signed document or application form depending on the file_id provided.
     * @summary Retrieves the signed document or application form
     * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
     * @param {string} fileId The unique identifier of the file which you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadQesDocument(workflowRunId, fileId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadQesDocument(workflowRunId, fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the signed evidence file for the designated Workflow Run
     * @summary Retrieve Workflow Run Evidence Summary File
     * @param {string} workflowRunId Workflow Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    downloadSignedEvidenceFile(workflowRunId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Extract information from a document
     * @summary Autofill
     * @param {ExtractRequest} extractRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    extract(extractRequest, options) {
        return (0, exports.DefaultApiFp)(this.configuration).extract(extractRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search for addresses by postcode
     * @summary Address Picker
     * @param {string} postcode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findAddresses(postcode, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findAddresses(postcode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single applicant. Returns an applicant object.
     * @summary Retrieve Applicant
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findApplicant(applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single check. Returns a check object.
     * @summary Retrieve a Check
     * @param {string} checkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findCheck(checkId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A single document can be retrieved by calling this endpoint with the document\'s unique identifier.
     * @summary Retrieve document
     * @param {string} documentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findDocument(documentId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single ID photo. Returns a ID photo object.
     * @summary Retrieve ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findIdPhoto(idPhotoId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single live photo. Returns a live photo object.
     * @summary Retrieve live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findLivePhoto(livePhotoId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single live video. Returns the corresponding live video object.
     * @summary Retrieve live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findLiveVideo(liveVideoId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single motion capture. Returns the corresponding motion capture object.
     * @summary Retrieve motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findMotionCapture(motionCaptureId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A single report can be retrieved using this endpoint with the corresponding unique identifier.
     * @summary Retrieve report
     * @param {string} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findReport(reportId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run.
     * @summary Retrieve Task
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findTask(workflowRunId, taskId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findTask(workflowRunId, taskId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the Timeline File for the designated Workflow Run.
     * @summary Retrieve Timeline File for Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {string} timelineFileId The unique identifier for the Timefile File.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findTimelineFile(workflowRunId, timelineFileId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findTimelineFile(workflowRunId, timelineFileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single monitor
     * @summary Retrieve monitor
     * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findWatchlistMonitor(monitorId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single webhook. Returns a webhook object.
     * @summary Retrieve a Webhook
     * @param {string} webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findWebhook(webhookId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
     * @summary Retrieve Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    findWorkflowRun(workflowRunId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).findWorkflowRun(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update.
     * @summary Force new report creation (BETA)
     * @param {string} monitorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    forceReportCreationFromWatchlistMonitor(monitorId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).forceReportCreationFromWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates an SDK token. Returns a token object containing the SDK token.
     * @summary Generate a SDK token
     * @param {SdkTokenBuilder} sdkTokenBuilder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    generateSdkToken(sdkTokenBuilder, options) {
        return (0, exports.DefaultApiFp)(this.configuration).generateSdkToken(sdkTokenBuilder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all applicants you\'ve created, sorted by creation date in descending order.
     * @summary List Applicants
     * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
     * @param {number} [perPage] The number of objects per page.
     * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listApplicants(page, perPage, includeDeleted, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listApplicants(page, perPage, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a single check. Returns a check object.
     * @summary Retrieve Checks
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listChecks(applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listChecks(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * All documents belonging to an applicant can be listed from this endpoint
     * @summary List documents
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listDocuments(applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listDocuments(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the ID photos that belong to an applicant.
     * @summary List ID photos
     * @param {string} applicantId The id of the applicant the ID photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listIdPhotos(applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listIdPhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the live photos that belong to an applicant.
     * @summary List live photos
     * @param {string} applicantId The id of the applicant the live photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listLivePhotos(applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listLivePhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the live videos that belong to an applicant.
     * @summary List live videos
     * @param {string} applicantId The id of the applicant the live videos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listLiveVideos(applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listLiveVideos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all the motion captures that belong to an applicant.
     * @summary List motion captures
     * @param {string} applicantId The id of the applicant the motion captures belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listMotionCaptures(applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listMotionCaptures(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all repeat attempts for a given Document report
     * @summary Retrieve repeat attempts
     * @param {string} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listRepeatAttempts(reportId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listRepeatAttempts(reportId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * All the reports belonging to a particular check can be listed from this endpoint.
     * @summary List reports
     * @param {string} checkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listReports(checkId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listReports(checkId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run.
     * @summary List Tasks
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listTasks(workflowRunId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listTasks(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List match IDs on this monitor, as well as their enabled/disabled status
     * @summary List matches (BETA)
     * @param {string} monitorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listWatchlistMonitorMatches(monitorId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listWatchlistMonitorMatches(monitorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all available monitors for an applicant
     * @summary List monitors
     * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
     * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listWatchlistMonitors(applicantId, includeDeleted, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all webhooks you\'ve created.
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listWebhooks(options) {
        return (0, exports.DefaultApiFp)(this.configuration).listWebhooks(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects.
     * @summary List Workflow Runs
     * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
     * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
     * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
     * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
     * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
     * @param {string} [applicantId] the applicant\&#39;s id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Run a health check on the Onfido API
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    ping(options) {
        return (0, exports.DefaultApiFp)(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create Feedback on checks and reports
     * @summary Fraud reporting (ALPHA)
     * @param {ResultsFeedback} resultsFeedback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    postResultsFeedback(resultsFeedback, options) {
        return (0, exports.DefaultApiFp)(this.configuration).postResultsFeedback(resultsFeedback, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resends events to all webhooks registered with a matching environment in your account.
     * @summary Resends webhooks
     * @param {WebhookResend} webhookResend
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    resendWebhooks(webhookResend, options) {
        return (0, exports.DefaultApiFp)(this.configuration).resendWebhooks(webhookResend, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restores a single applicant scheduled for deletion.
     * @summary Restore Applicant
     * @param {string} applicantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    restoreApplicant(applicantId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).restoreApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resumes a paused check.
     * @summary Resume a Check
     * @param {string} checkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    resumeCheck(checkId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).resumeCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Resumes a single paused report.
     * @summary Resume report
     * @param {string} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    resumeReport(reportId, options) {
        return (0, exports.DefaultApiFp)(this.configuration).resumeReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant
     * @summary Update Applicant
     * @param {string} applicantId
     * @param {ApplicantUpdater} applicantUpdater
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateApplicant(applicantId, applicantUpdater, options) {
        return (0, exports.DefaultApiFp)(this.configuration).updateApplicant(applicantId, applicantUpdater, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the status of the given matches
     * @summary Set match status (BETA)
     * @param {string} monitorId
     * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options) {
        return (0, exports.DefaultApiFp)(this.configuration).updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Edits a webhook. Returns the updated webhook object.
     * @summary Edit a webhook
     * @param {string} webhookId
     * @param {WebhookUpdater} webhookUpdater
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    updateWebhook(webhookId, webhookUpdater, options) {
        return (0, exports.DefaultApiFp)(this.configuration).updateWebhook(webhookId, webhookUpdater, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB.
     * @summary Upload a document
     * @param {DocumentTypes} type The type of document
     * @param {string} applicantId The ID of the applicant whose document is being uploaded.
     * @param {FileTransfer} file The file to be uploaded.
     * @param {string} [fileType] The file type of the uploaded file
     * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
     * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
     * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
     * @param {LocationBuilder} [location]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options) {
        return (0, exports.DefaultApiFp)(this.configuration).uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB.
     * @summary Upload ID photo
     * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
     * @param {FileTransfer} [file] The file to be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    uploadIdPhoto(applicantId, file, options) {
        return (0, exports.DefaultApiFp)(this.configuration).uploadIdPhoto(applicantId, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false.
     * @summary Upload live photo
     * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
     * @param {FileTransfer} [file] The file to be uploaded.
     * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    uploadLivePhoto(applicantId, file, advancedValidation, options) {
        return (0, exports.DefaultApiFp)(this.configuration).uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DefaultApi = DefaultApi;
/**
 * @export
 */
exports.ListWorkflowRunsSortEnum = {
    Desc: 'desc',
    Asc: 'asc',
    UnknownDefaultOpenApi: '11184809'
};
/**
 * @export
 */
exports.UploadDocumentSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
};
