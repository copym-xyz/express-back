
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model kycVerification
 * 
 */
export type kycVerification = $Result.DefaultSelection<Prisma.$kycVerificationPayload>
/**
 * Model KycDocument
 * 
 */
export type KycDocument = $Result.DefaultSelection<Prisma.$KycDocumentPayload>
/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model authprovider
 * 
 */
export type authprovider = $Result.DefaultSelection<Prisma.$authproviderPayload>
/**
 * Model didwallet
 * 
 */
export type didwallet = $Result.DefaultSelection<Prisma.$didwalletPayload>
/**
 * Model investor
 * 
 */
export type investor = $Result.DefaultSelection<Prisma.$investorPayload>
/**
 * Model issuer
 * 
 */
export type issuer = $Result.DefaultSelection<Prisma.$issuerPayload>
/**
 * Model kyc_address_info
 * 
 */
export type kyc_address_info = $Result.DefaultSelection<Prisma.$kyc_address_infoPayload>
/**
 * Model kyc_addresses
 * 
 */
export type kyc_addresses = $Result.DefaultSelection<Prisma.$kyc_addressesPayload>
/**
 * Model kyc_applicants
 * 
 */
export type kyc_applicants = $Result.DefaultSelection<Prisma.$kyc_applicantsPayload>
/**
 * Model kyc_audit_log
 * 
 */
export type kyc_audit_log = $Result.DefaultSelection<Prisma.$kyc_audit_logPayload>
/**
 * Model kyc_complete_records
 * 
 */
export type kyc_complete_records = $Result.DefaultSelection<Prisma.$kyc_complete_recordsPayload>
/**
 * Model kyc_personal_info
 * 
 */
export type kyc_personal_info = $Result.DefaultSelection<Prisma.$kyc_personal_infoPayload>
/**
 * Model kyc_raw_data
 * 
 */
export type kyc_raw_data = $Result.DefaultSelection<Prisma.$kyc_raw_dataPayload>
/**
 * Model kyc_verification_events
 * 
 */
export type kyc_verification_events = $Result.DefaultSelection<Prisma.$kyc_verification_eventsPayload>
/**
 * Model kyc_verification_history
 * 
 */
export type kyc_verification_history = $Result.DefaultSelection<Prisma.$kyc_verification_historyPayload>
/**
 * Model refreshtoken
 * 
 */
export type refreshtoken = $Result.DefaultSelection<Prisma.$refreshtokenPayload>
/**
 * Model userrole
 * 
 */
export type userrole = $Result.DefaultSelection<Prisma.$userrolePayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model wallet
 * 
 */
export type wallet = $Result.DefaultSelection<Prisma.$walletPayload>
/**
 * Model webhookLog
 * 
 */
export type webhookLog = $Result.DefaultSelection<Prisma.$webhookLogPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more KycVerifications
 * const kycVerifications = await prisma.kycVerification.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more KycVerifications
   * const kycVerifications = await prisma.kycVerification.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.kycVerification`: Exposes CRUD operations for the **kycVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KycVerifications
    * const kycVerifications = await prisma.kycVerification.findMany()
    * ```
    */
  get kycVerification(): Prisma.kycVerificationDelegate<ExtArgs>;

  /**
   * `prisma.kycDocument`: Exposes CRUD operations for the **KycDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KycDocuments
    * const kycDocuments = await prisma.kycDocument.findMany()
    * ```
    */
  get kycDocument(): Prisma.KycDocumentDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs>;

  /**
   * `prisma.authprovider`: Exposes CRUD operations for the **authprovider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authproviders
    * const authproviders = await prisma.authprovider.findMany()
    * ```
    */
  get authprovider(): Prisma.authproviderDelegate<ExtArgs>;

  /**
   * `prisma.didwallet`: Exposes CRUD operations for the **didwallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Didwallets
    * const didwallets = await prisma.didwallet.findMany()
    * ```
    */
  get didwallet(): Prisma.didwalletDelegate<ExtArgs>;

  /**
   * `prisma.investor`: Exposes CRUD operations for the **investor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investors
    * const investors = await prisma.investor.findMany()
    * ```
    */
  get investor(): Prisma.investorDelegate<ExtArgs>;

  /**
   * `prisma.issuer`: Exposes CRUD operations for the **issuer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issuers
    * const issuers = await prisma.issuer.findMany()
    * ```
    */
  get issuer(): Prisma.issuerDelegate<ExtArgs>;

  /**
   * `prisma.kyc_address_info`: Exposes CRUD operations for the **kyc_address_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kyc_address_infos
    * const kyc_address_infos = await prisma.kyc_address_info.findMany()
    * ```
    */
  get kyc_address_info(): Prisma.kyc_address_infoDelegate<ExtArgs>;

  /**
   * `prisma.kyc_addresses`: Exposes CRUD operations for the **kyc_addresses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kyc_addresses
    * const kyc_addresses = await prisma.kyc_addresses.findMany()
    * ```
    */
  get kyc_addresses(): Prisma.kyc_addressesDelegate<ExtArgs>;

  /**
   * `prisma.kyc_applicants`: Exposes CRUD operations for the **kyc_applicants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kyc_applicants
    * const kyc_applicants = await prisma.kyc_applicants.findMany()
    * ```
    */
  get kyc_applicants(): Prisma.kyc_applicantsDelegate<ExtArgs>;

  /**
   * `prisma.kyc_audit_log`: Exposes CRUD operations for the **kyc_audit_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kyc_audit_logs
    * const kyc_audit_logs = await prisma.kyc_audit_log.findMany()
    * ```
    */
  get kyc_audit_log(): Prisma.kyc_audit_logDelegate<ExtArgs>;

  /**
   * `prisma.kyc_complete_records`: Exposes CRUD operations for the **kyc_complete_records** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kyc_complete_records
    * const kyc_complete_records = await prisma.kyc_complete_records.findMany()
    * ```
    */
  get kyc_complete_records(): Prisma.kyc_complete_recordsDelegate<ExtArgs>;

  /**
   * `prisma.kyc_personal_info`: Exposes CRUD operations for the **kyc_personal_info** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kyc_personal_infos
    * const kyc_personal_infos = await prisma.kyc_personal_info.findMany()
    * ```
    */
  get kyc_personal_info(): Prisma.kyc_personal_infoDelegate<ExtArgs>;

  /**
   * `prisma.kyc_raw_data`: Exposes CRUD operations for the **kyc_raw_data** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kyc_raw_data
    * const kyc_raw_data = await prisma.kyc_raw_data.findMany()
    * ```
    */
  get kyc_raw_data(): Prisma.kyc_raw_dataDelegate<ExtArgs>;

  /**
   * `prisma.kyc_verification_events`: Exposes CRUD operations for the **kyc_verification_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kyc_verification_events
    * const kyc_verification_events = await prisma.kyc_verification_events.findMany()
    * ```
    */
  get kyc_verification_events(): Prisma.kyc_verification_eventsDelegate<ExtArgs>;

  /**
   * `prisma.kyc_verification_history`: Exposes CRUD operations for the **kyc_verification_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kyc_verification_histories
    * const kyc_verification_histories = await prisma.kyc_verification_history.findMany()
    * ```
    */
  get kyc_verification_history(): Prisma.kyc_verification_historyDelegate<ExtArgs>;

  /**
   * `prisma.refreshtoken`: Exposes CRUD operations for the **refreshtoken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refreshtokens
    * const refreshtokens = await prisma.refreshtoken.findMany()
    * ```
    */
  get refreshtoken(): Prisma.refreshtokenDelegate<ExtArgs>;

  /**
   * `prisma.userrole`: Exposes CRUD operations for the **userrole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userroles
    * const userroles = await prisma.userrole.findMany()
    * ```
    */
  get userrole(): Prisma.userroleDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.walletDelegate<ExtArgs>;

  /**
   * `prisma.webhookLog`: Exposes CRUD operations for the **webhookLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookLogs
    * const webhookLogs = await prisma.webhookLog.findMany()
    * ```
    */
  get webhookLog(): Prisma.webhookLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    kycVerification: 'kycVerification',
    KycDocument: 'KycDocument',
    admin: 'admin',
    authprovider: 'authprovider',
    didwallet: 'didwallet',
    investor: 'investor',
    issuer: 'issuer',
    kyc_address_info: 'kyc_address_info',
    kyc_addresses: 'kyc_addresses',
    kyc_applicants: 'kyc_applicants',
    kyc_audit_log: 'kyc_audit_log',
    kyc_complete_records: 'kyc_complete_records',
    kyc_personal_info: 'kyc_personal_info',
    kyc_raw_data: 'kyc_raw_data',
    kyc_verification_events: 'kyc_verification_events',
    kyc_verification_history: 'kyc_verification_history',
    refreshtoken: 'refreshtoken',
    userrole: 'userrole',
    users: 'users',
    wallet: 'wallet',
    webhookLog: 'webhookLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "kycVerification" | "kycDocument" | "admin" | "authprovider" | "didwallet" | "investor" | "issuer" | "kyc_address_info" | "kyc_addresses" | "kyc_applicants" | "kyc_audit_log" | "kyc_complete_records" | "kyc_personal_info" | "kyc_raw_data" | "kyc_verification_events" | "kyc_verification_history" | "refreshtoken" | "userrole" | "users" | "wallet" | "webhookLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      kycVerification: {
        payload: Prisma.$kycVerificationPayload<ExtArgs>
        fields: Prisma.kycVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kycVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kycVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kycVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kycVerificationPayload>
          }
          findFirst: {
            args: Prisma.kycVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kycVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kycVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kycVerificationPayload>
          }
          findMany: {
            args: Prisma.kycVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kycVerificationPayload>[]
          }
          create: {
            args: Prisma.kycVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kycVerificationPayload>
          }
          createMany: {
            args: Prisma.kycVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kycVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kycVerificationPayload>
          }
          update: {
            args: Prisma.kycVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kycVerificationPayload>
          }
          deleteMany: {
            args: Prisma.kycVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kycVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kycVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kycVerificationPayload>
          }
          aggregate: {
            args: Prisma.KycVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKycVerification>
          }
          groupBy: {
            args: Prisma.kycVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<KycVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.kycVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<KycVerificationCountAggregateOutputType> | number
          }
        }
      }
      KycDocument: {
        payload: Prisma.$KycDocumentPayload<ExtArgs>
        fields: Prisma.KycDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KycDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KycDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycDocumentPayload>
          }
          findFirst: {
            args: Prisma.KycDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KycDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycDocumentPayload>
          }
          findMany: {
            args: Prisma.KycDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycDocumentPayload>[]
          }
          create: {
            args: Prisma.KycDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycDocumentPayload>
          }
          createMany: {
            args: Prisma.KycDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KycDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycDocumentPayload>
          }
          update: {
            args: Prisma.KycDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycDocumentPayload>
          }
          deleteMany: {
            args: Prisma.KycDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KycDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KycDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KycDocumentPayload>
          }
          aggregate: {
            args: Prisma.KycDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKycDocument>
          }
          groupBy: {
            args: Prisma.KycDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<KycDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.KycDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<KycDocumentCountAggregateOutputType> | number
          }
        }
      }
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      authprovider: {
        payload: Prisma.$authproviderPayload<ExtArgs>
        fields: Prisma.authproviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.authproviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.authproviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          findFirst: {
            args: Prisma.authproviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.authproviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          findMany: {
            args: Prisma.authproviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>[]
          }
          create: {
            args: Prisma.authproviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          createMany: {
            args: Prisma.authproviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.authproviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          update: {
            args: Prisma.authproviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          deleteMany: {
            args: Prisma.authproviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.authproviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.authproviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          aggregate: {
            args: Prisma.AuthproviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthprovider>
          }
          groupBy: {
            args: Prisma.authproviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthproviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.authproviderCountArgs<ExtArgs>
            result: $Utils.Optional<AuthproviderCountAggregateOutputType> | number
          }
        }
      }
      didwallet: {
        payload: Prisma.$didwalletPayload<ExtArgs>
        fields: Prisma.didwalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.didwalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.didwalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          findFirst: {
            args: Prisma.didwalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.didwalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          findMany: {
            args: Prisma.didwalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>[]
          }
          create: {
            args: Prisma.didwalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          createMany: {
            args: Prisma.didwalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.didwalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          update: {
            args: Prisma.didwalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          deleteMany: {
            args: Prisma.didwalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.didwalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.didwalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          aggregate: {
            args: Prisma.DidwalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDidwallet>
          }
          groupBy: {
            args: Prisma.didwalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<DidwalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.didwalletCountArgs<ExtArgs>
            result: $Utils.Optional<DidwalletCountAggregateOutputType> | number
          }
        }
      }
      investor: {
        payload: Prisma.$investorPayload<ExtArgs>
        fields: Prisma.investorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.investorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.investorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          findFirst: {
            args: Prisma.investorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.investorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          findMany: {
            args: Prisma.investorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>[]
          }
          create: {
            args: Prisma.investorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          createMany: {
            args: Prisma.investorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.investorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          update: {
            args: Prisma.investorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          deleteMany: {
            args: Prisma.investorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.investorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.investorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          aggregate: {
            args: Prisma.InvestorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestor>
          }
          groupBy: {
            args: Prisma.investorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.investorCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorCountAggregateOutputType> | number
          }
        }
      }
      issuer: {
        payload: Prisma.$issuerPayload<ExtArgs>
        fields: Prisma.issuerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.issuerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.issuerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          findFirst: {
            args: Prisma.issuerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.issuerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          findMany: {
            args: Prisma.issuerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>[]
          }
          create: {
            args: Prisma.issuerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          createMany: {
            args: Prisma.issuerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.issuerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          update: {
            args: Prisma.issuerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          deleteMany: {
            args: Prisma.issuerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.issuerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.issuerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          aggregate: {
            args: Prisma.IssuerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIssuer>
          }
          groupBy: {
            args: Prisma.issuerGroupByArgs<ExtArgs>
            result: $Utils.Optional<IssuerGroupByOutputType>[]
          }
          count: {
            args: Prisma.issuerCountArgs<ExtArgs>
            result: $Utils.Optional<IssuerCountAggregateOutputType> | number
          }
        }
      }
      kyc_address_info: {
        payload: Prisma.$kyc_address_infoPayload<ExtArgs>
        fields: Prisma.kyc_address_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kyc_address_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_address_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kyc_address_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_address_infoPayload>
          }
          findFirst: {
            args: Prisma.kyc_address_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_address_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kyc_address_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_address_infoPayload>
          }
          findMany: {
            args: Prisma.kyc_address_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_address_infoPayload>[]
          }
          create: {
            args: Prisma.kyc_address_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_address_infoPayload>
          }
          createMany: {
            args: Prisma.kyc_address_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kyc_address_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_address_infoPayload>
          }
          update: {
            args: Prisma.kyc_address_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_address_infoPayload>
          }
          deleteMany: {
            args: Prisma.kyc_address_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kyc_address_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kyc_address_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_address_infoPayload>
          }
          aggregate: {
            args: Prisma.Kyc_address_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc_address_info>
          }
          groupBy: {
            args: Prisma.kyc_address_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kyc_address_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.kyc_address_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Kyc_address_infoCountAggregateOutputType> | number
          }
        }
      }
      kyc_addresses: {
        payload: Prisma.$kyc_addressesPayload<ExtArgs>
        fields: Prisma.kyc_addressesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kyc_addressesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_addressesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kyc_addressesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_addressesPayload>
          }
          findFirst: {
            args: Prisma.kyc_addressesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_addressesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kyc_addressesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_addressesPayload>
          }
          findMany: {
            args: Prisma.kyc_addressesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_addressesPayload>[]
          }
          create: {
            args: Prisma.kyc_addressesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_addressesPayload>
          }
          createMany: {
            args: Prisma.kyc_addressesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kyc_addressesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_addressesPayload>
          }
          update: {
            args: Prisma.kyc_addressesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_addressesPayload>
          }
          deleteMany: {
            args: Prisma.kyc_addressesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kyc_addressesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kyc_addressesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_addressesPayload>
          }
          aggregate: {
            args: Prisma.Kyc_addressesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc_addresses>
          }
          groupBy: {
            args: Prisma.kyc_addressesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kyc_addressesGroupByOutputType>[]
          }
          count: {
            args: Prisma.kyc_addressesCountArgs<ExtArgs>
            result: $Utils.Optional<Kyc_addressesCountAggregateOutputType> | number
          }
        }
      }
      kyc_applicants: {
        payload: Prisma.$kyc_applicantsPayload<ExtArgs>
        fields: Prisma.kyc_applicantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kyc_applicantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_applicantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kyc_applicantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_applicantsPayload>
          }
          findFirst: {
            args: Prisma.kyc_applicantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_applicantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kyc_applicantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_applicantsPayload>
          }
          findMany: {
            args: Prisma.kyc_applicantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_applicantsPayload>[]
          }
          create: {
            args: Prisma.kyc_applicantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_applicantsPayload>
          }
          createMany: {
            args: Prisma.kyc_applicantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kyc_applicantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_applicantsPayload>
          }
          update: {
            args: Prisma.kyc_applicantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_applicantsPayload>
          }
          deleteMany: {
            args: Prisma.kyc_applicantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kyc_applicantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kyc_applicantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_applicantsPayload>
          }
          aggregate: {
            args: Prisma.Kyc_applicantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc_applicants>
          }
          groupBy: {
            args: Prisma.kyc_applicantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kyc_applicantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.kyc_applicantsCountArgs<ExtArgs>
            result: $Utils.Optional<Kyc_applicantsCountAggregateOutputType> | number
          }
        }
      }
      kyc_audit_log: {
        payload: Prisma.$kyc_audit_logPayload<ExtArgs>
        fields: Prisma.kyc_audit_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kyc_audit_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_audit_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kyc_audit_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_audit_logPayload>
          }
          findFirst: {
            args: Prisma.kyc_audit_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_audit_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kyc_audit_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_audit_logPayload>
          }
          findMany: {
            args: Prisma.kyc_audit_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_audit_logPayload>[]
          }
          create: {
            args: Prisma.kyc_audit_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_audit_logPayload>
          }
          createMany: {
            args: Prisma.kyc_audit_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kyc_audit_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_audit_logPayload>
          }
          update: {
            args: Prisma.kyc_audit_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_audit_logPayload>
          }
          deleteMany: {
            args: Prisma.kyc_audit_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kyc_audit_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kyc_audit_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_audit_logPayload>
          }
          aggregate: {
            args: Prisma.Kyc_audit_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc_audit_log>
          }
          groupBy: {
            args: Prisma.kyc_audit_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kyc_audit_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.kyc_audit_logCountArgs<ExtArgs>
            result: $Utils.Optional<Kyc_audit_logCountAggregateOutputType> | number
          }
        }
      }
      kyc_complete_records: {
        payload: Prisma.$kyc_complete_recordsPayload<ExtArgs>
        fields: Prisma.kyc_complete_recordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kyc_complete_recordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_complete_recordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kyc_complete_recordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_complete_recordsPayload>
          }
          findFirst: {
            args: Prisma.kyc_complete_recordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_complete_recordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kyc_complete_recordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_complete_recordsPayload>
          }
          findMany: {
            args: Prisma.kyc_complete_recordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_complete_recordsPayload>[]
          }
          create: {
            args: Prisma.kyc_complete_recordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_complete_recordsPayload>
          }
          createMany: {
            args: Prisma.kyc_complete_recordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kyc_complete_recordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_complete_recordsPayload>
          }
          update: {
            args: Prisma.kyc_complete_recordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_complete_recordsPayload>
          }
          deleteMany: {
            args: Prisma.kyc_complete_recordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kyc_complete_recordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kyc_complete_recordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_complete_recordsPayload>
          }
          aggregate: {
            args: Prisma.Kyc_complete_recordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc_complete_records>
          }
          groupBy: {
            args: Prisma.kyc_complete_recordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kyc_complete_recordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.kyc_complete_recordsCountArgs<ExtArgs>
            result: $Utils.Optional<Kyc_complete_recordsCountAggregateOutputType> | number
          }
        }
      }
      kyc_personal_info: {
        payload: Prisma.$kyc_personal_infoPayload<ExtArgs>
        fields: Prisma.kyc_personal_infoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kyc_personal_infoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_personal_infoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kyc_personal_infoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_personal_infoPayload>
          }
          findFirst: {
            args: Prisma.kyc_personal_infoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_personal_infoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kyc_personal_infoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_personal_infoPayload>
          }
          findMany: {
            args: Prisma.kyc_personal_infoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_personal_infoPayload>[]
          }
          create: {
            args: Prisma.kyc_personal_infoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_personal_infoPayload>
          }
          createMany: {
            args: Prisma.kyc_personal_infoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kyc_personal_infoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_personal_infoPayload>
          }
          update: {
            args: Prisma.kyc_personal_infoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_personal_infoPayload>
          }
          deleteMany: {
            args: Prisma.kyc_personal_infoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kyc_personal_infoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kyc_personal_infoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_personal_infoPayload>
          }
          aggregate: {
            args: Prisma.Kyc_personal_infoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc_personal_info>
          }
          groupBy: {
            args: Prisma.kyc_personal_infoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kyc_personal_infoGroupByOutputType>[]
          }
          count: {
            args: Prisma.kyc_personal_infoCountArgs<ExtArgs>
            result: $Utils.Optional<Kyc_personal_infoCountAggregateOutputType> | number
          }
        }
      }
      kyc_raw_data: {
        payload: Prisma.$kyc_raw_dataPayload<ExtArgs>
        fields: Prisma.kyc_raw_dataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kyc_raw_dataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_raw_dataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kyc_raw_dataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_raw_dataPayload>
          }
          findFirst: {
            args: Prisma.kyc_raw_dataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_raw_dataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kyc_raw_dataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_raw_dataPayload>
          }
          findMany: {
            args: Prisma.kyc_raw_dataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_raw_dataPayload>[]
          }
          create: {
            args: Prisma.kyc_raw_dataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_raw_dataPayload>
          }
          createMany: {
            args: Prisma.kyc_raw_dataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kyc_raw_dataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_raw_dataPayload>
          }
          update: {
            args: Prisma.kyc_raw_dataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_raw_dataPayload>
          }
          deleteMany: {
            args: Prisma.kyc_raw_dataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kyc_raw_dataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kyc_raw_dataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_raw_dataPayload>
          }
          aggregate: {
            args: Prisma.Kyc_raw_dataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc_raw_data>
          }
          groupBy: {
            args: Prisma.kyc_raw_dataGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kyc_raw_dataGroupByOutputType>[]
          }
          count: {
            args: Prisma.kyc_raw_dataCountArgs<ExtArgs>
            result: $Utils.Optional<Kyc_raw_dataCountAggregateOutputType> | number
          }
        }
      }
      kyc_verification_events: {
        payload: Prisma.$kyc_verification_eventsPayload<ExtArgs>
        fields: Prisma.kyc_verification_eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kyc_verification_eventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kyc_verification_eventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_eventsPayload>
          }
          findFirst: {
            args: Prisma.kyc_verification_eventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kyc_verification_eventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_eventsPayload>
          }
          findMany: {
            args: Prisma.kyc_verification_eventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_eventsPayload>[]
          }
          create: {
            args: Prisma.kyc_verification_eventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_eventsPayload>
          }
          createMany: {
            args: Prisma.kyc_verification_eventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kyc_verification_eventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_eventsPayload>
          }
          update: {
            args: Prisma.kyc_verification_eventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_eventsPayload>
          }
          deleteMany: {
            args: Prisma.kyc_verification_eventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kyc_verification_eventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kyc_verification_eventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_eventsPayload>
          }
          aggregate: {
            args: Prisma.Kyc_verification_eventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc_verification_events>
          }
          groupBy: {
            args: Prisma.kyc_verification_eventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kyc_verification_eventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.kyc_verification_eventsCountArgs<ExtArgs>
            result: $Utils.Optional<Kyc_verification_eventsCountAggregateOutputType> | number
          }
        }
      }
      kyc_verification_history: {
        payload: Prisma.$kyc_verification_historyPayload<ExtArgs>
        fields: Prisma.kyc_verification_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.kyc_verification_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.kyc_verification_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_historyPayload>
          }
          findFirst: {
            args: Prisma.kyc_verification_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.kyc_verification_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_historyPayload>
          }
          findMany: {
            args: Prisma.kyc_verification_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_historyPayload>[]
          }
          create: {
            args: Prisma.kyc_verification_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_historyPayload>
          }
          createMany: {
            args: Prisma.kyc_verification_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.kyc_verification_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_historyPayload>
          }
          update: {
            args: Prisma.kyc_verification_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_historyPayload>
          }
          deleteMany: {
            args: Prisma.kyc_verification_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.kyc_verification_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.kyc_verification_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$kyc_verification_historyPayload>
          }
          aggregate: {
            args: Prisma.Kyc_verification_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKyc_verification_history>
          }
          groupBy: {
            args: Prisma.kyc_verification_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Kyc_verification_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.kyc_verification_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Kyc_verification_historyCountAggregateOutputType> | number
          }
        }
      }
      refreshtoken: {
        payload: Prisma.$refreshtokenPayload<ExtArgs>
        fields: Prisma.refreshtokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.refreshtokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.refreshtokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          findFirst: {
            args: Prisma.refreshtokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.refreshtokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          findMany: {
            args: Prisma.refreshtokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>[]
          }
          create: {
            args: Prisma.refreshtokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          createMany: {
            args: Prisma.refreshtokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.refreshtokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          update: {
            args: Prisma.refreshtokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          deleteMany: {
            args: Prisma.refreshtokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.refreshtokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.refreshtokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshtokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshtoken>
          }
          groupBy: {
            args: Prisma.refreshtokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshtokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.refreshtokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshtokenCountAggregateOutputType> | number
          }
        }
      }
      userrole: {
        payload: Prisma.$userrolePayload<ExtArgs>
        fields: Prisma.userroleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userroleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userroleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findFirst: {
            args: Prisma.userroleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userroleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findMany: {
            args: Prisma.userroleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          create: {
            args: Prisma.userroleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          createMany: {
            args: Prisma.userroleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userroleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          update: {
            args: Prisma.userroleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          deleteMany: {
            args: Prisma.userroleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userroleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userroleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          aggregate: {
            args: Prisma.UserroleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserrole>
          }
          groupBy: {
            args: Prisma.userroleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserroleGroupByOutputType>[]
          }
          count: {
            args: Prisma.userroleCountArgs<ExtArgs>
            result: $Utils.Optional<UserroleCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      wallet: {
        payload: Prisma.$walletPayload<ExtArgs>
        fields: Prisma.walletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.walletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.walletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          findFirst: {
            args: Prisma.walletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.walletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          findMany: {
            args: Prisma.walletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>[]
          }
          create: {
            args: Prisma.walletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          createMany: {
            args: Prisma.walletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.walletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          update: {
            args: Prisma.walletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          deleteMany: {
            args: Prisma.walletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.walletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.walletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.walletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.walletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      webhookLog: {
        payload: Prisma.$webhookLogPayload<ExtArgs>
        fields: Prisma.webhookLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.webhookLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhookLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.webhookLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhookLogPayload>
          }
          findFirst: {
            args: Prisma.webhookLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhookLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.webhookLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhookLogPayload>
          }
          findMany: {
            args: Prisma.webhookLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhookLogPayload>[]
          }
          create: {
            args: Prisma.webhookLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhookLogPayload>
          }
          createMany: {
            args: Prisma.webhookLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.webhookLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhookLogPayload>
          }
          update: {
            args: Prisma.webhookLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhookLogPayload>
          }
          deleteMany: {
            args: Prisma.webhookLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.webhookLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.webhookLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$webhookLogPayload>
          }
          aggregate: {
            args: Prisma.WebhookLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookLog>
          }
          groupBy: {
            args: Prisma.webhookLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.webhookLogCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Kyc_applicantsCountOutputType
   */

  export type Kyc_applicantsCountOutputType = {
    kyc_address_info: number
    kyc_audit_log: number
    kyc_raw_data: number
    kyc_verification_history: number
  }

  export type Kyc_applicantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_address_info?: boolean | Kyc_applicantsCountOutputTypeCountKyc_address_infoArgs
    kyc_audit_log?: boolean | Kyc_applicantsCountOutputTypeCountKyc_audit_logArgs
    kyc_raw_data?: boolean | Kyc_applicantsCountOutputTypeCountKyc_raw_dataArgs
    kyc_verification_history?: boolean | Kyc_applicantsCountOutputTypeCountKyc_verification_historyArgs
  }

  // Custom InputTypes
  /**
   * Kyc_applicantsCountOutputType without action
   */
  export type Kyc_applicantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc_applicantsCountOutputType
     */
    select?: Kyc_applicantsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Kyc_applicantsCountOutputType without action
   */
  export type Kyc_applicantsCountOutputTypeCountKyc_address_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_address_infoWhereInput
  }

  /**
   * Kyc_applicantsCountOutputType without action
   */
  export type Kyc_applicantsCountOutputTypeCountKyc_audit_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_audit_logWhereInput
  }

  /**
   * Kyc_applicantsCountOutputType without action
   */
  export type Kyc_applicantsCountOutputTypeCountKyc_raw_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_raw_dataWhereInput
  }

  /**
   * Kyc_applicantsCountOutputType without action
   */
  export type Kyc_applicantsCountOutputTypeCountKyc_verification_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_verification_historyWhereInput
  }


  /**
   * Count Type Kyc_complete_recordsCountOutputType
   */

  export type Kyc_complete_recordsCountOutputType = {
    kyc_addresses: number
    kyc_documents: number
    kyc_verification_events: number
  }

  export type Kyc_complete_recordsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_addresses?: boolean | Kyc_complete_recordsCountOutputTypeCountKyc_addressesArgs
    kyc_documents?: boolean | Kyc_complete_recordsCountOutputTypeCountKyc_documentsArgs
    kyc_verification_events?: boolean | Kyc_complete_recordsCountOutputTypeCountKyc_verification_eventsArgs
  }

  // Custom InputTypes
  /**
   * Kyc_complete_recordsCountOutputType without action
   */
  export type Kyc_complete_recordsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kyc_complete_recordsCountOutputType
     */
    select?: Kyc_complete_recordsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Kyc_complete_recordsCountOutputType without action
   */
  export type Kyc_complete_recordsCountOutputTypeCountKyc_addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_addressesWhereInput
  }

  /**
   * Kyc_complete_recordsCountOutputType without action
   */
  export type Kyc_complete_recordsCountOutputTypeCountKyc_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KycDocumentWhereInput
  }

  /**
   * Kyc_complete_recordsCountOutputType without action
   */
  export type Kyc_complete_recordsCountOutputTypeCountKyc_verification_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_verification_eventsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    authprovider: number
    didwallet: number
    kyc_applicants: number
    kyc_complete_records: number
    kyc_documents: number
    kyc_verifications: number
    refreshtoken: number
    userrole: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authprovider?: boolean | UsersCountOutputTypeCountAuthproviderArgs
    didwallet?: boolean | UsersCountOutputTypeCountDidwalletArgs
    kyc_applicants?: boolean | UsersCountOutputTypeCountKyc_applicantsArgs
    kyc_complete_records?: boolean | UsersCountOutputTypeCountKyc_complete_recordsArgs
    kyc_documents?: boolean | UsersCountOutputTypeCountKyc_documentsArgs
    kyc_verifications?: boolean | UsersCountOutputTypeCountKyc_verificationsArgs
    refreshtoken?: boolean | UsersCountOutputTypeCountRefreshtokenArgs
    userrole?: boolean | UsersCountOutputTypeCountUserroleArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAuthproviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authproviderWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountDidwalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: didwalletWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountKyc_applicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_applicantsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountKyc_complete_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_complete_recordsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountKyc_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KycDocumentWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountKyc_verificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kycVerificationWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRefreshtokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refreshtokenWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model kycVerification
   */

  export type AggregateKycVerification = {
    _count: KycVerificationCountAggregateOutputType | null
    _avg: KycVerificationAvgAggregateOutputType | null
    _sum: KycVerificationSumAggregateOutputType | null
    _min: KycVerificationMinAggregateOutputType | null
    _max: KycVerificationMaxAggregateOutputType | null
  }

  export type KycVerificationAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type KycVerificationSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type KycVerificationMinAggregateOutputType = {
    id: number | null
    type: string | null
    applicant_id: string | null
    correlation_id: string | null
    created_at: Date | null
    error_message: string | null
    event_timestamp: Date | null
    external_user_id: string | null
    inspection_id: string | null
    processing_status: string | null
    raw_data: string | null
    review_result: string | null
    review_status: string | null
    signature_valid: boolean | null
    updated_at: Date | null
    user_id: number | null
    webhook_type: string | null
  }

  export type KycVerificationMaxAggregateOutputType = {
    id: number | null
    type: string | null
    applicant_id: string | null
    correlation_id: string | null
    created_at: Date | null
    error_message: string | null
    event_timestamp: Date | null
    external_user_id: string | null
    inspection_id: string | null
    processing_status: string | null
    raw_data: string | null
    review_result: string | null
    review_status: string | null
    signature_valid: boolean | null
    updated_at: Date | null
    user_id: number | null
    webhook_type: string | null
  }

  export type KycVerificationCountAggregateOutputType = {
    id: number
    type: number
    applicant_id: number
    correlation_id: number
    created_at: number
    error_message: number
    event_timestamp: number
    external_user_id: number
    inspection_id: number
    processing_status: number
    raw_data: number
    review_result: number
    review_status: number
    signature_valid: number
    updated_at: number
    user_id: number
    webhook_type: number
    _all: number
  }


  export type KycVerificationAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type KycVerificationSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type KycVerificationMinAggregateInputType = {
    id?: true
    type?: true
    applicant_id?: true
    correlation_id?: true
    created_at?: true
    error_message?: true
    event_timestamp?: true
    external_user_id?: true
    inspection_id?: true
    processing_status?: true
    raw_data?: true
    review_result?: true
    review_status?: true
    signature_valid?: true
    updated_at?: true
    user_id?: true
    webhook_type?: true
  }

  export type KycVerificationMaxAggregateInputType = {
    id?: true
    type?: true
    applicant_id?: true
    correlation_id?: true
    created_at?: true
    error_message?: true
    event_timestamp?: true
    external_user_id?: true
    inspection_id?: true
    processing_status?: true
    raw_data?: true
    review_result?: true
    review_status?: true
    signature_valid?: true
    updated_at?: true
    user_id?: true
    webhook_type?: true
  }

  export type KycVerificationCountAggregateInputType = {
    id?: true
    type?: true
    applicant_id?: true
    correlation_id?: true
    created_at?: true
    error_message?: true
    event_timestamp?: true
    external_user_id?: true
    inspection_id?: true
    processing_status?: true
    raw_data?: true
    review_result?: true
    review_status?: true
    signature_valid?: true
    updated_at?: true
    user_id?: true
    webhook_type?: true
    _all?: true
  }

  export type KycVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kycVerification to aggregate.
     */
    where?: kycVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kycVerifications to fetch.
     */
    orderBy?: kycVerificationOrderByWithRelationInput | kycVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kycVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kycVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kycVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kycVerifications
    **/
    _count?: true | KycVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KycVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KycVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KycVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KycVerificationMaxAggregateInputType
  }

  export type GetKycVerificationAggregateType<T extends KycVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateKycVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKycVerification[P]>
      : GetScalarType<T[P], AggregateKycVerification[P]>
  }




  export type kycVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kycVerificationWhereInput
    orderBy?: kycVerificationOrderByWithAggregationInput | kycVerificationOrderByWithAggregationInput[]
    by: KycVerificationScalarFieldEnum[] | KycVerificationScalarFieldEnum
    having?: kycVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KycVerificationCountAggregateInputType | true
    _avg?: KycVerificationAvgAggregateInputType
    _sum?: KycVerificationSumAggregateInputType
    _min?: KycVerificationMinAggregateInputType
    _max?: KycVerificationMaxAggregateInputType
  }

  export type KycVerificationGroupByOutputType = {
    id: number
    type: string
    applicant_id: string
    correlation_id: string | null
    created_at: Date
    error_message: string | null
    event_timestamp: Date
    external_user_id: string | null
    inspection_id: string | null
    processing_status: string | null
    raw_data: string
    review_result: string | null
    review_status: string
    signature_valid: boolean
    updated_at: Date
    user_id: number | null
    webhook_type: string
    _count: KycVerificationCountAggregateOutputType | null
    _avg: KycVerificationAvgAggregateOutputType | null
    _sum: KycVerificationSumAggregateOutputType | null
    _min: KycVerificationMinAggregateOutputType | null
    _max: KycVerificationMaxAggregateOutputType | null
  }

  type GetKycVerificationGroupByPayload<T extends kycVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KycVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KycVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KycVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], KycVerificationGroupByOutputType[P]>
        }
      >
    >


  export type kycVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    applicant_id?: boolean
    correlation_id?: boolean
    created_at?: boolean
    error_message?: boolean
    event_timestamp?: boolean
    external_user_id?: boolean
    inspection_id?: boolean
    processing_status?: boolean
    raw_data?: boolean
    review_result?: boolean
    review_status?: boolean
    signature_valid?: boolean
    updated_at?: boolean
    user_id?: boolean
    webhook_type?: boolean
    users?: boolean | kycVerification$usersArgs<ExtArgs>
  }, ExtArgs["result"]["kycVerification"]>


  export type kycVerificationSelectScalar = {
    id?: boolean
    type?: boolean
    applicant_id?: boolean
    correlation_id?: boolean
    created_at?: boolean
    error_message?: boolean
    event_timestamp?: boolean
    external_user_id?: boolean
    inspection_id?: boolean
    processing_status?: boolean
    raw_data?: boolean
    review_result?: boolean
    review_status?: boolean
    signature_valid?: boolean
    updated_at?: boolean
    user_id?: boolean
    webhook_type?: boolean
  }

  export type kycVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | kycVerification$usersArgs<ExtArgs>
  }

  export type $kycVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kycVerification"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      applicant_id: string
      correlation_id: string | null
      created_at: Date
      error_message: string | null
      event_timestamp: Date
      external_user_id: string | null
      inspection_id: string | null
      processing_status: string | null
      raw_data: string
      review_result: string | null
      review_status: string
      signature_valid: boolean
      updated_at: Date
      user_id: number | null
      webhook_type: string
    }, ExtArgs["result"]["kycVerification"]>
    composites: {}
  }

  type kycVerificationGetPayload<S extends boolean | null | undefined | kycVerificationDefaultArgs> = $Result.GetResult<Prisma.$kycVerificationPayload, S>

  type kycVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kycVerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KycVerificationCountAggregateInputType | true
    }

  export interface kycVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kycVerification'], meta: { name: 'kycVerification' } }
    /**
     * Find zero or one KycVerification that matches the filter.
     * @param {kycVerificationFindUniqueArgs} args - Arguments to find a KycVerification
     * @example
     * // Get one KycVerification
     * const kycVerification = await prisma.kycVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kycVerificationFindUniqueArgs>(args: SelectSubset<T, kycVerificationFindUniqueArgs<ExtArgs>>): Prisma__kycVerificationClient<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KycVerification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kycVerificationFindUniqueOrThrowArgs} args - Arguments to find a KycVerification
     * @example
     * // Get one KycVerification
     * const kycVerification = await prisma.kycVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kycVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, kycVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kycVerificationClient<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KycVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kycVerificationFindFirstArgs} args - Arguments to find a KycVerification
     * @example
     * // Get one KycVerification
     * const kycVerification = await prisma.kycVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kycVerificationFindFirstArgs>(args?: SelectSubset<T, kycVerificationFindFirstArgs<ExtArgs>>): Prisma__kycVerificationClient<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KycVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kycVerificationFindFirstOrThrowArgs} args - Arguments to find a KycVerification
     * @example
     * // Get one KycVerification
     * const kycVerification = await prisma.kycVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kycVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, kycVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__kycVerificationClient<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KycVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kycVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KycVerifications
     * const kycVerifications = await prisma.kycVerification.findMany()
     * 
     * // Get first 10 KycVerifications
     * const kycVerifications = await prisma.kycVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kycVerificationWithIdOnly = await prisma.kycVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kycVerificationFindManyArgs>(args?: SelectSubset<T, kycVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KycVerification.
     * @param {kycVerificationCreateArgs} args - Arguments to create a KycVerification.
     * @example
     * // Create one KycVerification
     * const KycVerification = await prisma.kycVerification.create({
     *   data: {
     *     // ... data to create a KycVerification
     *   }
     * })
     * 
     */
    create<T extends kycVerificationCreateArgs>(args: SelectSubset<T, kycVerificationCreateArgs<ExtArgs>>): Prisma__kycVerificationClient<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KycVerifications.
     * @param {kycVerificationCreateManyArgs} args - Arguments to create many KycVerifications.
     * @example
     * // Create many KycVerifications
     * const kycVerification = await prisma.kycVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kycVerificationCreateManyArgs>(args?: SelectSubset<T, kycVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KycVerification.
     * @param {kycVerificationDeleteArgs} args - Arguments to delete one KycVerification.
     * @example
     * // Delete one KycVerification
     * const KycVerification = await prisma.kycVerification.delete({
     *   where: {
     *     // ... filter to delete one KycVerification
     *   }
     * })
     * 
     */
    delete<T extends kycVerificationDeleteArgs>(args: SelectSubset<T, kycVerificationDeleteArgs<ExtArgs>>): Prisma__kycVerificationClient<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KycVerification.
     * @param {kycVerificationUpdateArgs} args - Arguments to update one KycVerification.
     * @example
     * // Update one KycVerification
     * const kycVerification = await prisma.kycVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kycVerificationUpdateArgs>(args: SelectSubset<T, kycVerificationUpdateArgs<ExtArgs>>): Prisma__kycVerificationClient<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KycVerifications.
     * @param {kycVerificationDeleteManyArgs} args - Arguments to filter KycVerifications to delete.
     * @example
     * // Delete a few KycVerifications
     * const { count } = await prisma.kycVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kycVerificationDeleteManyArgs>(args?: SelectSubset<T, kycVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KycVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kycVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KycVerifications
     * const kycVerification = await prisma.kycVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kycVerificationUpdateManyArgs>(args: SelectSubset<T, kycVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KycVerification.
     * @param {kycVerificationUpsertArgs} args - Arguments to update or create a KycVerification.
     * @example
     * // Update or create a KycVerification
     * const kycVerification = await prisma.kycVerification.upsert({
     *   create: {
     *     // ... data to create a KycVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KycVerification we want to update
     *   }
     * })
     */
    upsert<T extends kycVerificationUpsertArgs>(args: SelectSubset<T, kycVerificationUpsertArgs<ExtArgs>>): Prisma__kycVerificationClient<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KycVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kycVerificationCountArgs} args - Arguments to filter KycVerifications to count.
     * @example
     * // Count the number of KycVerifications
     * const count = await prisma.kycVerification.count({
     *   where: {
     *     // ... the filter for the KycVerifications we want to count
     *   }
     * })
    **/
    count<T extends kycVerificationCountArgs>(
      args?: Subset<T, kycVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KycVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KycVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KycVerificationAggregateArgs>(args: Subset<T, KycVerificationAggregateArgs>): Prisma.PrismaPromise<GetKycVerificationAggregateType<T>>

    /**
     * Group by KycVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kycVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kycVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kycVerificationGroupByArgs['orderBy'] }
        : { orderBy?: kycVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kycVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKycVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kycVerification model
   */
  readonly fields: kycVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kycVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kycVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends kycVerification$usersArgs<ExtArgs> = {}>(args?: Subset<T, kycVerification$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kycVerification model
   */ 
  interface kycVerificationFieldRefs {
    readonly id: FieldRef<"kycVerification", 'Int'>
    readonly type: FieldRef<"kycVerification", 'String'>
    readonly applicant_id: FieldRef<"kycVerification", 'String'>
    readonly correlation_id: FieldRef<"kycVerification", 'String'>
    readonly created_at: FieldRef<"kycVerification", 'DateTime'>
    readonly error_message: FieldRef<"kycVerification", 'String'>
    readonly event_timestamp: FieldRef<"kycVerification", 'DateTime'>
    readonly external_user_id: FieldRef<"kycVerification", 'String'>
    readonly inspection_id: FieldRef<"kycVerification", 'String'>
    readonly processing_status: FieldRef<"kycVerification", 'String'>
    readonly raw_data: FieldRef<"kycVerification", 'String'>
    readonly review_result: FieldRef<"kycVerification", 'String'>
    readonly review_status: FieldRef<"kycVerification", 'String'>
    readonly signature_valid: FieldRef<"kycVerification", 'Boolean'>
    readonly updated_at: FieldRef<"kycVerification", 'DateTime'>
    readonly user_id: FieldRef<"kycVerification", 'Int'>
    readonly webhook_type: FieldRef<"kycVerification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * kycVerification findUnique
   */
  export type kycVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    /**
     * Filter, which kycVerification to fetch.
     */
    where: kycVerificationWhereUniqueInput
  }

  /**
   * kycVerification findUniqueOrThrow
   */
  export type kycVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    /**
     * Filter, which kycVerification to fetch.
     */
    where: kycVerificationWhereUniqueInput
  }

  /**
   * kycVerification findFirst
   */
  export type kycVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    /**
     * Filter, which kycVerification to fetch.
     */
    where?: kycVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kycVerifications to fetch.
     */
    orderBy?: kycVerificationOrderByWithRelationInput | kycVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kycVerifications.
     */
    cursor?: kycVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kycVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kycVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kycVerifications.
     */
    distinct?: KycVerificationScalarFieldEnum | KycVerificationScalarFieldEnum[]
  }

  /**
   * kycVerification findFirstOrThrow
   */
  export type kycVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    /**
     * Filter, which kycVerification to fetch.
     */
    where?: kycVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kycVerifications to fetch.
     */
    orderBy?: kycVerificationOrderByWithRelationInput | kycVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kycVerifications.
     */
    cursor?: kycVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kycVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kycVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kycVerifications.
     */
    distinct?: KycVerificationScalarFieldEnum | KycVerificationScalarFieldEnum[]
  }

  /**
   * kycVerification findMany
   */
  export type kycVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    /**
     * Filter, which kycVerifications to fetch.
     */
    where?: kycVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kycVerifications to fetch.
     */
    orderBy?: kycVerificationOrderByWithRelationInput | kycVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kycVerifications.
     */
    cursor?: kycVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kycVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kycVerifications.
     */
    skip?: number
    distinct?: KycVerificationScalarFieldEnum | KycVerificationScalarFieldEnum[]
  }

  /**
   * kycVerification create
   */
  export type kycVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a kycVerification.
     */
    data: XOR<kycVerificationCreateInput, kycVerificationUncheckedCreateInput>
  }

  /**
   * kycVerification createMany
   */
  export type kycVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kycVerifications.
     */
    data: kycVerificationCreateManyInput | kycVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kycVerification update
   */
  export type kycVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a kycVerification.
     */
    data: XOR<kycVerificationUpdateInput, kycVerificationUncheckedUpdateInput>
    /**
     * Choose, which kycVerification to update.
     */
    where: kycVerificationWhereUniqueInput
  }

  /**
   * kycVerification updateMany
   */
  export type kycVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kycVerifications.
     */
    data: XOR<kycVerificationUpdateManyMutationInput, kycVerificationUncheckedUpdateManyInput>
    /**
     * Filter which kycVerifications to update
     */
    where?: kycVerificationWhereInput
  }

  /**
   * kycVerification upsert
   */
  export type kycVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the kycVerification to update in case it exists.
     */
    where: kycVerificationWhereUniqueInput
    /**
     * In case the kycVerification found by the `where` argument doesn't exist, create a new kycVerification with this data.
     */
    create: XOR<kycVerificationCreateInput, kycVerificationUncheckedCreateInput>
    /**
     * In case the kycVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kycVerificationUpdateInput, kycVerificationUncheckedUpdateInput>
  }

  /**
   * kycVerification delete
   */
  export type kycVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    /**
     * Filter which kycVerification to delete.
     */
    where: kycVerificationWhereUniqueInput
  }

  /**
   * kycVerification deleteMany
   */
  export type kycVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kycVerifications to delete
     */
    where?: kycVerificationWhereInput
  }

  /**
   * kycVerification.users
   */
  export type kycVerification$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * kycVerification without action
   */
  export type kycVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
  }


  /**
   * Model KycDocument
   */

  export type AggregateKycDocument = {
    _count: KycDocumentCountAggregateOutputType | null
    _avg: KycDocumentAvgAggregateOutputType | null
    _sum: KycDocumentSumAggregateOutputType | null
    _min: KycDocumentMinAggregateOutputType | null
    _max: KycDocumentMaxAggregateOutputType | null
  }

  export type KycDocumentAvgAggregateOutputType = {
    id: number | null
    record_id: number | null
    user_id: number | null
  }

  export type KycDocumentSumAggregateOutputType = {
    id: number | null
    record_id: number | null
    user_id: number | null
  }

  export type KycDocumentMinAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    country: string | null
    created_at: Date | null
    document_id: string | null
    document_sub_type: string | null
    document_type: string | null
    field_name: string | null
    file_name: string | null
    file_path: string | null
    file_type: string | null
    file_url: string | null
    id_doc_type: string | null
    issued_date: Date | null
    number: string | null
    page_type: string | null
    record_id: number | null
    status: string | null
    updated_at: Date | null
    user_id: number | null
    valid_until: Date | null
  }

  export type KycDocumentMaxAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    country: string | null
    created_at: Date | null
    document_id: string | null
    document_sub_type: string | null
    document_type: string | null
    field_name: string | null
    file_name: string | null
    file_path: string | null
    file_type: string | null
    file_url: string | null
    id_doc_type: string | null
    issued_date: Date | null
    number: string | null
    page_type: string | null
    record_id: number | null
    status: string | null
    updated_at: Date | null
    user_id: number | null
    valid_until: Date | null
  }

  export type KycDocumentCountAggregateOutputType = {
    id: number
    applicant_id: number
    country: number
    created_at: number
    document_id: number
    document_sub_type: number
    document_type: number
    field_name: number
    file_name: number
    file_path: number
    file_type: number
    file_url: number
    id_doc_type: number
    issued_date: number
    number: number
    page_type: number
    record_id: number
    status: number
    updated_at: number
    user_id: number
    valid_until: number
    _all: number
  }


  export type KycDocumentAvgAggregateInputType = {
    id?: true
    record_id?: true
    user_id?: true
  }

  export type KycDocumentSumAggregateInputType = {
    id?: true
    record_id?: true
    user_id?: true
  }

  export type KycDocumentMinAggregateInputType = {
    id?: true
    applicant_id?: true
    country?: true
    created_at?: true
    document_id?: true
    document_sub_type?: true
    document_type?: true
    field_name?: true
    file_name?: true
    file_path?: true
    file_type?: true
    file_url?: true
    id_doc_type?: true
    issued_date?: true
    number?: true
    page_type?: true
    record_id?: true
    status?: true
    updated_at?: true
    user_id?: true
    valid_until?: true
  }

  export type KycDocumentMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    country?: true
    created_at?: true
    document_id?: true
    document_sub_type?: true
    document_type?: true
    field_name?: true
    file_name?: true
    file_path?: true
    file_type?: true
    file_url?: true
    id_doc_type?: true
    issued_date?: true
    number?: true
    page_type?: true
    record_id?: true
    status?: true
    updated_at?: true
    user_id?: true
    valid_until?: true
  }

  export type KycDocumentCountAggregateInputType = {
    id?: true
    applicant_id?: true
    country?: true
    created_at?: true
    document_id?: true
    document_sub_type?: true
    document_type?: true
    field_name?: true
    file_name?: true
    file_path?: true
    file_type?: true
    file_url?: true
    id_doc_type?: true
    issued_date?: true
    number?: true
    page_type?: true
    record_id?: true
    status?: true
    updated_at?: true
    user_id?: true
    valid_until?: true
    _all?: true
  }

  export type KycDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KycDocument to aggregate.
     */
    where?: KycDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycDocuments to fetch.
     */
    orderBy?: KycDocumentOrderByWithRelationInput | KycDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KycDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KycDocuments
    **/
    _count?: true | KycDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KycDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KycDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KycDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KycDocumentMaxAggregateInputType
  }

  export type GetKycDocumentAggregateType<T extends KycDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateKycDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKycDocument[P]>
      : GetScalarType<T[P], AggregateKycDocument[P]>
  }




  export type KycDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KycDocumentWhereInput
    orderBy?: KycDocumentOrderByWithAggregationInput | KycDocumentOrderByWithAggregationInput[]
    by: KycDocumentScalarFieldEnum[] | KycDocumentScalarFieldEnum
    having?: KycDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KycDocumentCountAggregateInputType | true
    _avg?: KycDocumentAvgAggregateInputType
    _sum?: KycDocumentSumAggregateInputType
    _min?: KycDocumentMinAggregateInputType
    _max?: KycDocumentMaxAggregateInputType
  }

  export type KycDocumentGroupByOutputType = {
    id: number
    applicant_id: string | null
    country: string | null
    created_at: Date
    document_id: string | null
    document_sub_type: string | null
    document_type: string
    field_name: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url: string | null
    id_doc_type: string | null
    issued_date: Date | null
    number: string | null
    page_type: string | null
    record_id: number | null
    status: string
    updated_at: Date
    user_id: number | null
    valid_until: Date | null
    _count: KycDocumentCountAggregateOutputType | null
    _avg: KycDocumentAvgAggregateOutputType | null
    _sum: KycDocumentSumAggregateOutputType | null
    _min: KycDocumentMinAggregateOutputType | null
    _max: KycDocumentMaxAggregateOutputType | null
  }

  type GetKycDocumentGroupByPayload<T extends KycDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KycDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KycDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KycDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], KycDocumentGroupByOutputType[P]>
        }
      >
    >


  export type KycDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicant_id?: boolean
    country?: boolean
    created_at?: boolean
    document_id?: boolean
    document_sub_type?: boolean
    document_type?: boolean
    field_name?: boolean
    file_name?: boolean
    file_path?: boolean
    file_type?: boolean
    file_url?: boolean
    id_doc_type?: boolean
    issued_date?: boolean
    number?: boolean
    page_type?: boolean
    record_id?: boolean
    status?: boolean
    updated_at?: boolean
    user_id?: boolean
    valid_until?: boolean
    kyc_complete_records?: boolean | KycDocument$kyc_complete_recordsArgs<ExtArgs>
    users?: boolean | KycDocument$usersArgs<ExtArgs>
  }, ExtArgs["result"]["kycDocument"]>


  export type KycDocumentSelectScalar = {
    id?: boolean
    applicant_id?: boolean
    country?: boolean
    created_at?: boolean
    document_id?: boolean
    document_sub_type?: boolean
    document_type?: boolean
    field_name?: boolean
    file_name?: boolean
    file_path?: boolean
    file_type?: boolean
    file_url?: boolean
    id_doc_type?: boolean
    issued_date?: boolean
    number?: boolean
    page_type?: boolean
    record_id?: boolean
    status?: boolean
    updated_at?: boolean
    user_id?: boolean
    valid_until?: boolean
  }

  export type KycDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_complete_records?: boolean | KycDocument$kyc_complete_recordsArgs<ExtArgs>
    users?: boolean | KycDocument$usersArgs<ExtArgs>
  }

  export type $KycDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KycDocument"
    objects: {
      kyc_complete_records: Prisma.$kyc_complete_recordsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicant_id: string | null
      country: string | null
      created_at: Date
      document_id: string | null
      document_sub_type: string | null
      document_type: string
      field_name: string | null
      file_name: string
      file_path: string
      file_type: string
      file_url: string | null
      id_doc_type: string | null
      issued_date: Date | null
      number: string | null
      page_type: string | null
      record_id: number | null
      status: string
      updated_at: Date
      user_id: number | null
      valid_until: Date | null
    }, ExtArgs["result"]["kycDocument"]>
    composites: {}
  }

  type KycDocumentGetPayload<S extends boolean | null | undefined | KycDocumentDefaultArgs> = $Result.GetResult<Prisma.$KycDocumentPayload, S>

  type KycDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KycDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KycDocumentCountAggregateInputType | true
    }

  export interface KycDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KycDocument'], meta: { name: 'KycDocument' } }
    /**
     * Find zero or one KycDocument that matches the filter.
     * @param {KycDocumentFindUniqueArgs} args - Arguments to find a KycDocument
     * @example
     * // Get one KycDocument
     * const kycDocument = await prisma.kycDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KycDocumentFindUniqueArgs>(args: SelectSubset<T, KycDocumentFindUniqueArgs<ExtArgs>>): Prisma__KycDocumentClient<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KycDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KycDocumentFindUniqueOrThrowArgs} args - Arguments to find a KycDocument
     * @example
     * // Get one KycDocument
     * const kycDocument = await prisma.kycDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KycDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, KycDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KycDocumentClient<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KycDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycDocumentFindFirstArgs} args - Arguments to find a KycDocument
     * @example
     * // Get one KycDocument
     * const kycDocument = await prisma.kycDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KycDocumentFindFirstArgs>(args?: SelectSubset<T, KycDocumentFindFirstArgs<ExtArgs>>): Prisma__KycDocumentClient<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KycDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycDocumentFindFirstOrThrowArgs} args - Arguments to find a KycDocument
     * @example
     * // Get one KycDocument
     * const kycDocument = await prisma.kycDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KycDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, KycDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__KycDocumentClient<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KycDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KycDocuments
     * const kycDocuments = await prisma.kycDocument.findMany()
     * 
     * // Get first 10 KycDocuments
     * const kycDocuments = await prisma.kycDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kycDocumentWithIdOnly = await prisma.kycDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KycDocumentFindManyArgs>(args?: SelectSubset<T, KycDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KycDocument.
     * @param {KycDocumentCreateArgs} args - Arguments to create a KycDocument.
     * @example
     * // Create one KycDocument
     * const KycDocument = await prisma.kycDocument.create({
     *   data: {
     *     // ... data to create a KycDocument
     *   }
     * })
     * 
     */
    create<T extends KycDocumentCreateArgs>(args: SelectSubset<T, KycDocumentCreateArgs<ExtArgs>>): Prisma__KycDocumentClient<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KycDocuments.
     * @param {KycDocumentCreateManyArgs} args - Arguments to create many KycDocuments.
     * @example
     * // Create many KycDocuments
     * const kycDocument = await prisma.kycDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KycDocumentCreateManyArgs>(args?: SelectSubset<T, KycDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KycDocument.
     * @param {KycDocumentDeleteArgs} args - Arguments to delete one KycDocument.
     * @example
     * // Delete one KycDocument
     * const KycDocument = await prisma.kycDocument.delete({
     *   where: {
     *     // ... filter to delete one KycDocument
     *   }
     * })
     * 
     */
    delete<T extends KycDocumentDeleteArgs>(args: SelectSubset<T, KycDocumentDeleteArgs<ExtArgs>>): Prisma__KycDocumentClient<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KycDocument.
     * @param {KycDocumentUpdateArgs} args - Arguments to update one KycDocument.
     * @example
     * // Update one KycDocument
     * const kycDocument = await prisma.kycDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KycDocumentUpdateArgs>(args: SelectSubset<T, KycDocumentUpdateArgs<ExtArgs>>): Prisma__KycDocumentClient<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KycDocuments.
     * @param {KycDocumentDeleteManyArgs} args - Arguments to filter KycDocuments to delete.
     * @example
     * // Delete a few KycDocuments
     * const { count } = await prisma.kycDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KycDocumentDeleteManyArgs>(args?: SelectSubset<T, KycDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KycDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KycDocuments
     * const kycDocument = await prisma.kycDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KycDocumentUpdateManyArgs>(args: SelectSubset<T, KycDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KycDocument.
     * @param {KycDocumentUpsertArgs} args - Arguments to update or create a KycDocument.
     * @example
     * // Update or create a KycDocument
     * const kycDocument = await prisma.kycDocument.upsert({
     *   create: {
     *     // ... data to create a KycDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KycDocument we want to update
     *   }
     * })
     */
    upsert<T extends KycDocumentUpsertArgs>(args: SelectSubset<T, KycDocumentUpsertArgs<ExtArgs>>): Prisma__KycDocumentClient<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KycDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycDocumentCountArgs} args - Arguments to filter KycDocuments to count.
     * @example
     * // Count the number of KycDocuments
     * const count = await prisma.kycDocument.count({
     *   where: {
     *     // ... the filter for the KycDocuments we want to count
     *   }
     * })
    **/
    count<T extends KycDocumentCountArgs>(
      args?: Subset<T, KycDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KycDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KycDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KycDocumentAggregateArgs>(args: Subset<T, KycDocumentAggregateArgs>): Prisma.PrismaPromise<GetKycDocumentAggregateType<T>>

    /**
     * Group by KycDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KycDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KycDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KycDocumentGroupByArgs['orderBy'] }
        : { orderBy?: KycDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KycDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKycDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KycDocument model
   */
  readonly fields: KycDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KycDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KycDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_complete_records<T extends KycDocument$kyc_complete_recordsArgs<ExtArgs> = {}>(args?: Subset<T, KycDocument$kyc_complete_recordsArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users<T extends KycDocument$usersArgs<ExtArgs> = {}>(args?: Subset<T, KycDocument$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KycDocument model
   */ 
  interface KycDocumentFieldRefs {
    readonly id: FieldRef<"KycDocument", 'Int'>
    readonly applicant_id: FieldRef<"KycDocument", 'String'>
    readonly country: FieldRef<"KycDocument", 'String'>
    readonly created_at: FieldRef<"KycDocument", 'DateTime'>
    readonly document_id: FieldRef<"KycDocument", 'String'>
    readonly document_sub_type: FieldRef<"KycDocument", 'String'>
    readonly document_type: FieldRef<"KycDocument", 'String'>
    readonly field_name: FieldRef<"KycDocument", 'String'>
    readonly file_name: FieldRef<"KycDocument", 'String'>
    readonly file_path: FieldRef<"KycDocument", 'String'>
    readonly file_type: FieldRef<"KycDocument", 'String'>
    readonly file_url: FieldRef<"KycDocument", 'String'>
    readonly id_doc_type: FieldRef<"KycDocument", 'String'>
    readonly issued_date: FieldRef<"KycDocument", 'DateTime'>
    readonly number: FieldRef<"KycDocument", 'String'>
    readonly page_type: FieldRef<"KycDocument", 'String'>
    readonly record_id: FieldRef<"KycDocument", 'Int'>
    readonly status: FieldRef<"KycDocument", 'String'>
    readonly updated_at: FieldRef<"KycDocument", 'DateTime'>
    readonly user_id: FieldRef<"KycDocument", 'Int'>
    readonly valid_until: FieldRef<"KycDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KycDocument findUnique
   */
  export type KycDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KycDocument to fetch.
     */
    where: KycDocumentWhereUniqueInput
  }

  /**
   * KycDocument findUniqueOrThrow
   */
  export type KycDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KycDocument to fetch.
     */
    where: KycDocumentWhereUniqueInput
  }

  /**
   * KycDocument findFirst
   */
  export type KycDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KycDocument to fetch.
     */
    where?: KycDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycDocuments to fetch.
     */
    orderBy?: KycDocumentOrderByWithRelationInput | KycDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KycDocuments.
     */
    cursor?: KycDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KycDocuments.
     */
    distinct?: KycDocumentScalarFieldEnum | KycDocumentScalarFieldEnum[]
  }

  /**
   * KycDocument findFirstOrThrow
   */
  export type KycDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KycDocument to fetch.
     */
    where?: KycDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycDocuments to fetch.
     */
    orderBy?: KycDocumentOrderByWithRelationInput | KycDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KycDocuments.
     */
    cursor?: KycDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KycDocuments.
     */
    distinct?: KycDocumentScalarFieldEnum | KycDocumentScalarFieldEnum[]
  }

  /**
   * KycDocument findMany
   */
  export type KycDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    /**
     * Filter, which KycDocuments to fetch.
     */
    where?: KycDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KycDocuments to fetch.
     */
    orderBy?: KycDocumentOrderByWithRelationInput | KycDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KycDocuments.
     */
    cursor?: KycDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KycDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KycDocuments.
     */
    skip?: number
    distinct?: KycDocumentScalarFieldEnum | KycDocumentScalarFieldEnum[]
  }

  /**
   * KycDocument create
   */
  export type KycDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a KycDocument.
     */
    data: XOR<KycDocumentCreateInput, KycDocumentUncheckedCreateInput>
  }

  /**
   * KycDocument createMany
   */
  export type KycDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KycDocuments.
     */
    data: KycDocumentCreateManyInput | KycDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KycDocument update
   */
  export type KycDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a KycDocument.
     */
    data: XOR<KycDocumentUpdateInput, KycDocumentUncheckedUpdateInput>
    /**
     * Choose, which KycDocument to update.
     */
    where: KycDocumentWhereUniqueInput
  }

  /**
   * KycDocument updateMany
   */
  export type KycDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KycDocuments.
     */
    data: XOR<KycDocumentUpdateManyMutationInput, KycDocumentUncheckedUpdateManyInput>
    /**
     * Filter which KycDocuments to update
     */
    where?: KycDocumentWhereInput
  }

  /**
   * KycDocument upsert
   */
  export type KycDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the KycDocument to update in case it exists.
     */
    where: KycDocumentWhereUniqueInput
    /**
     * In case the KycDocument found by the `where` argument doesn't exist, create a new KycDocument with this data.
     */
    create: XOR<KycDocumentCreateInput, KycDocumentUncheckedCreateInput>
    /**
     * In case the KycDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KycDocumentUpdateInput, KycDocumentUncheckedUpdateInput>
  }

  /**
   * KycDocument delete
   */
  export type KycDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    /**
     * Filter which KycDocument to delete.
     */
    where: KycDocumentWhereUniqueInput
  }

  /**
   * KycDocument deleteMany
   */
  export type KycDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KycDocuments to delete
     */
    where?: KycDocumentWhereInput
  }

  /**
   * KycDocument.kyc_complete_records
   */
  export type KycDocument$kyc_complete_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    where?: kyc_complete_recordsWhereInput
  }

  /**
   * KycDocument.users
   */
  export type KycDocument$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * KycDocument without action
   */
  export type KycDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
  }


  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    department: string | null
    position: string | null
    last_login: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    department: string | null
    position: string | null
    last_login: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    user_id: number
    department: number
    position: number
    last_login: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    user_id?: true
    department?: true
    position?: true
    last_login?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    user_id?: true
    department?: true
    position?: true
    last_login?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    user_id?: true
    department?: true
    position?: true
    last_login?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    user_id: number
    department: string
    position: string
    last_login: Date | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    department?: boolean
    position?: boolean
    last_login?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>


  export type adminSelectScalar = {
    id?: boolean
    user_id?: boolean
    department?: boolean
    position?: boolean
    last_login?: boolean
  }

  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      department: string
      position: string
      last_login: Date | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */ 
  interface adminFieldRefs {
    readonly id: FieldRef<"admin", 'Int'>
    readonly user_id: FieldRef<"admin", 'Int'>
    readonly department: FieldRef<"admin", 'String'>
    readonly position: FieldRef<"admin", 'String'>
    readonly last_login: FieldRef<"admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
  }


  /**
   * Model authprovider
   */

  export type AggregateAuthprovider = {
    _count: AuthproviderCountAggregateOutputType | null
    _avg: AuthproviderAvgAggregateOutputType | null
    _sum: AuthproviderSumAggregateOutputType | null
    _min: AuthproviderMinAggregateOutputType | null
    _max: AuthproviderMaxAggregateOutputType | null
  }

  export type AuthproviderAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AuthproviderSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AuthproviderMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    provider_name: string | null
    provider_user_id: string | null
    created_at: Date | null
    last_used: Date | null
  }

  export type AuthproviderMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    provider_name: string | null
    provider_user_id: string | null
    created_at: Date | null
    last_used: Date | null
  }

  export type AuthproviderCountAggregateOutputType = {
    id: number
    user_id: number
    provider_name: number
    provider_user_id: number
    provider_data: number
    created_at: number
    last_used: number
    _all: number
  }


  export type AuthproviderAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AuthproviderSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AuthproviderMinAggregateInputType = {
    id?: true
    user_id?: true
    provider_name?: true
    provider_user_id?: true
    created_at?: true
    last_used?: true
  }

  export type AuthproviderMaxAggregateInputType = {
    id?: true
    user_id?: true
    provider_name?: true
    provider_user_id?: true
    created_at?: true
    last_used?: true
  }

  export type AuthproviderCountAggregateInputType = {
    id?: true
    user_id?: true
    provider_name?: true
    provider_user_id?: true
    provider_data?: true
    created_at?: true
    last_used?: true
    _all?: true
  }

  export type AuthproviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authprovider to aggregate.
     */
    where?: authproviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authproviders to fetch.
     */
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: authproviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authproviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned authproviders
    **/
    _count?: true | AuthproviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthproviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthproviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthproviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthproviderMaxAggregateInputType
  }

  export type GetAuthproviderAggregateType<T extends AuthproviderAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthprovider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthprovider[P]>
      : GetScalarType<T[P], AggregateAuthprovider[P]>
  }




  export type authproviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authproviderWhereInput
    orderBy?: authproviderOrderByWithAggregationInput | authproviderOrderByWithAggregationInput[]
    by: AuthproviderScalarFieldEnum[] | AuthproviderScalarFieldEnum
    having?: authproviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthproviderCountAggregateInputType | true
    _avg?: AuthproviderAvgAggregateInputType
    _sum?: AuthproviderSumAggregateInputType
    _min?: AuthproviderMinAggregateInputType
    _max?: AuthproviderMaxAggregateInputType
  }

  export type AuthproviderGroupByOutputType = {
    id: number
    user_id: number
    provider_name: string
    provider_user_id: string
    provider_data: JsonValue | null
    created_at: Date
    last_used: Date
    _count: AuthproviderCountAggregateOutputType | null
    _avg: AuthproviderAvgAggregateOutputType | null
    _sum: AuthproviderSumAggregateOutputType | null
    _min: AuthproviderMinAggregateOutputType | null
    _max: AuthproviderMaxAggregateOutputType | null
  }

  type GetAuthproviderGroupByPayload<T extends authproviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthproviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthproviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthproviderGroupByOutputType[P]>
            : GetScalarType<T[P], AuthproviderGroupByOutputType[P]>
        }
      >
    >


  export type authproviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    provider_name?: boolean
    provider_user_id?: boolean
    provider_data?: boolean
    created_at?: boolean
    last_used?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authprovider"]>


  export type authproviderSelectScalar = {
    id?: boolean
    user_id?: boolean
    provider_name?: boolean
    provider_user_id?: boolean
    provider_data?: boolean
    created_at?: boolean
    last_used?: boolean
  }

  export type authproviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $authproviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "authprovider"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      provider_name: string
      provider_user_id: string
      provider_data: Prisma.JsonValue | null
      created_at: Date
      last_used: Date
    }, ExtArgs["result"]["authprovider"]>
    composites: {}
  }

  type authproviderGetPayload<S extends boolean | null | undefined | authproviderDefaultArgs> = $Result.GetResult<Prisma.$authproviderPayload, S>

  type authproviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<authproviderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthproviderCountAggregateInputType | true
    }

  export interface authproviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['authprovider'], meta: { name: 'authprovider' } }
    /**
     * Find zero or one Authprovider that matches the filter.
     * @param {authproviderFindUniqueArgs} args - Arguments to find a Authprovider
     * @example
     * // Get one Authprovider
     * const authprovider = await prisma.authprovider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends authproviderFindUniqueArgs>(args: SelectSubset<T, authproviderFindUniqueArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Authprovider that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {authproviderFindUniqueOrThrowArgs} args - Arguments to find a Authprovider
     * @example
     * // Get one Authprovider
     * const authprovider = await prisma.authprovider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends authproviderFindUniqueOrThrowArgs>(args: SelectSubset<T, authproviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Authprovider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderFindFirstArgs} args - Arguments to find a Authprovider
     * @example
     * // Get one Authprovider
     * const authprovider = await prisma.authprovider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends authproviderFindFirstArgs>(args?: SelectSubset<T, authproviderFindFirstArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Authprovider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderFindFirstOrThrowArgs} args - Arguments to find a Authprovider
     * @example
     * // Get one Authprovider
     * const authprovider = await prisma.authprovider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends authproviderFindFirstOrThrowArgs>(args?: SelectSubset<T, authproviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Authproviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authproviders
     * const authproviders = await prisma.authprovider.findMany()
     * 
     * // Get first 10 Authproviders
     * const authproviders = await prisma.authprovider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authproviderWithIdOnly = await prisma.authprovider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends authproviderFindManyArgs>(args?: SelectSubset<T, authproviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Authprovider.
     * @param {authproviderCreateArgs} args - Arguments to create a Authprovider.
     * @example
     * // Create one Authprovider
     * const Authprovider = await prisma.authprovider.create({
     *   data: {
     *     // ... data to create a Authprovider
     *   }
     * })
     * 
     */
    create<T extends authproviderCreateArgs>(args: SelectSubset<T, authproviderCreateArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Authproviders.
     * @param {authproviderCreateManyArgs} args - Arguments to create many Authproviders.
     * @example
     * // Create many Authproviders
     * const authprovider = await prisma.authprovider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends authproviderCreateManyArgs>(args?: SelectSubset<T, authproviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Authprovider.
     * @param {authproviderDeleteArgs} args - Arguments to delete one Authprovider.
     * @example
     * // Delete one Authprovider
     * const Authprovider = await prisma.authprovider.delete({
     *   where: {
     *     // ... filter to delete one Authprovider
     *   }
     * })
     * 
     */
    delete<T extends authproviderDeleteArgs>(args: SelectSubset<T, authproviderDeleteArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Authprovider.
     * @param {authproviderUpdateArgs} args - Arguments to update one Authprovider.
     * @example
     * // Update one Authprovider
     * const authprovider = await prisma.authprovider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends authproviderUpdateArgs>(args: SelectSubset<T, authproviderUpdateArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Authproviders.
     * @param {authproviderDeleteManyArgs} args - Arguments to filter Authproviders to delete.
     * @example
     * // Delete a few Authproviders
     * const { count } = await prisma.authprovider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends authproviderDeleteManyArgs>(args?: SelectSubset<T, authproviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authproviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authproviders
     * const authprovider = await prisma.authprovider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends authproviderUpdateManyArgs>(args: SelectSubset<T, authproviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Authprovider.
     * @param {authproviderUpsertArgs} args - Arguments to update or create a Authprovider.
     * @example
     * // Update or create a Authprovider
     * const authprovider = await prisma.authprovider.upsert({
     *   create: {
     *     // ... data to create a Authprovider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authprovider we want to update
     *   }
     * })
     */
    upsert<T extends authproviderUpsertArgs>(args: SelectSubset<T, authproviderUpsertArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Authproviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderCountArgs} args - Arguments to filter Authproviders to count.
     * @example
     * // Count the number of Authproviders
     * const count = await prisma.authprovider.count({
     *   where: {
     *     // ... the filter for the Authproviders we want to count
     *   }
     * })
    **/
    count<T extends authproviderCountArgs>(
      args?: Subset<T, authproviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthproviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authprovider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthproviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthproviderAggregateArgs>(args: Subset<T, AuthproviderAggregateArgs>): Prisma.PrismaPromise<GetAuthproviderAggregateType<T>>

    /**
     * Group by Authprovider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends authproviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: authproviderGroupByArgs['orderBy'] }
        : { orderBy?: authproviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, authproviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthproviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the authprovider model
   */
  readonly fields: authproviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for authprovider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__authproviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the authprovider model
   */ 
  interface authproviderFieldRefs {
    readonly id: FieldRef<"authprovider", 'Int'>
    readonly user_id: FieldRef<"authprovider", 'Int'>
    readonly provider_name: FieldRef<"authprovider", 'String'>
    readonly provider_user_id: FieldRef<"authprovider", 'String'>
    readonly provider_data: FieldRef<"authprovider", 'Json'>
    readonly created_at: FieldRef<"authprovider", 'DateTime'>
    readonly last_used: FieldRef<"authprovider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * authprovider findUnique
   */
  export type authproviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authprovider to fetch.
     */
    where: authproviderWhereUniqueInput
  }

  /**
   * authprovider findUniqueOrThrow
   */
  export type authproviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authprovider to fetch.
     */
    where: authproviderWhereUniqueInput
  }

  /**
   * authprovider findFirst
   */
  export type authproviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authprovider to fetch.
     */
    where?: authproviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authproviders to fetch.
     */
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authproviders.
     */
    cursor?: authproviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authproviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authproviders.
     */
    distinct?: AuthproviderScalarFieldEnum | AuthproviderScalarFieldEnum[]
  }

  /**
   * authprovider findFirstOrThrow
   */
  export type authproviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authprovider to fetch.
     */
    where?: authproviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authproviders to fetch.
     */
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authproviders.
     */
    cursor?: authproviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authproviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authproviders.
     */
    distinct?: AuthproviderScalarFieldEnum | AuthproviderScalarFieldEnum[]
  }

  /**
   * authprovider findMany
   */
  export type authproviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authproviders to fetch.
     */
    where?: authproviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authproviders to fetch.
     */
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing authproviders.
     */
    cursor?: authproviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authproviders.
     */
    skip?: number
    distinct?: AuthproviderScalarFieldEnum | AuthproviderScalarFieldEnum[]
  }

  /**
   * authprovider create
   */
  export type authproviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * The data needed to create a authprovider.
     */
    data: XOR<authproviderCreateInput, authproviderUncheckedCreateInput>
  }

  /**
   * authprovider createMany
   */
  export type authproviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many authproviders.
     */
    data: authproviderCreateManyInput | authproviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * authprovider update
   */
  export type authproviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * The data needed to update a authprovider.
     */
    data: XOR<authproviderUpdateInput, authproviderUncheckedUpdateInput>
    /**
     * Choose, which authprovider to update.
     */
    where: authproviderWhereUniqueInput
  }

  /**
   * authprovider updateMany
   */
  export type authproviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update authproviders.
     */
    data: XOR<authproviderUpdateManyMutationInput, authproviderUncheckedUpdateManyInput>
    /**
     * Filter which authproviders to update
     */
    where?: authproviderWhereInput
  }

  /**
   * authprovider upsert
   */
  export type authproviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * The filter to search for the authprovider to update in case it exists.
     */
    where: authproviderWhereUniqueInput
    /**
     * In case the authprovider found by the `where` argument doesn't exist, create a new authprovider with this data.
     */
    create: XOR<authproviderCreateInput, authproviderUncheckedCreateInput>
    /**
     * In case the authprovider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<authproviderUpdateInput, authproviderUncheckedUpdateInput>
  }

  /**
   * authprovider delete
   */
  export type authproviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter which authprovider to delete.
     */
    where: authproviderWhereUniqueInput
  }

  /**
   * authprovider deleteMany
   */
  export type authproviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authproviders to delete
     */
    where?: authproviderWhereInput
  }

  /**
   * authprovider without action
   */
  export type authproviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
  }


  /**
   * Model didwallet
   */

  export type AggregateDidwallet = {
    _count: DidwalletCountAggregateOutputType | null
    _avg: DidwalletAvgAggregateOutputType | null
    _sum: DidwalletSumAggregateOutputType | null
    _min: DidwalletMinAggregateOutputType | null
    _max: DidwalletMaxAggregateOutputType | null
  }

  export type DidwalletAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type DidwalletSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type DidwalletMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    wallet_address: string | null
    did: string | null
    is_primary: boolean | null
    created_at: Date | null
    last_used: Date | null
  }

  export type DidwalletMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    wallet_address: string | null
    did: string | null
    is_primary: boolean | null
    created_at: Date | null
    last_used: Date | null
  }

  export type DidwalletCountAggregateOutputType = {
    id: number
    user_id: number
    wallet_address: number
    did: number
    is_primary: number
    created_at: number
    last_used: number
    _all: number
  }


  export type DidwalletAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type DidwalletSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type DidwalletMinAggregateInputType = {
    id?: true
    user_id?: true
    wallet_address?: true
    did?: true
    is_primary?: true
    created_at?: true
    last_used?: true
  }

  export type DidwalletMaxAggregateInputType = {
    id?: true
    user_id?: true
    wallet_address?: true
    did?: true
    is_primary?: true
    created_at?: true
    last_used?: true
  }

  export type DidwalletCountAggregateInputType = {
    id?: true
    user_id?: true
    wallet_address?: true
    did?: true
    is_primary?: true
    created_at?: true
    last_used?: true
    _all?: true
  }

  export type DidwalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which didwallet to aggregate.
     */
    where?: didwalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of didwallets to fetch.
     */
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: didwalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` didwallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` didwallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned didwallets
    **/
    _count?: true | DidwalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DidwalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DidwalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DidwalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DidwalletMaxAggregateInputType
  }

  export type GetDidwalletAggregateType<T extends DidwalletAggregateArgs> = {
        [P in keyof T & keyof AggregateDidwallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDidwallet[P]>
      : GetScalarType<T[P], AggregateDidwallet[P]>
  }




  export type didwalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: didwalletWhereInput
    orderBy?: didwalletOrderByWithAggregationInput | didwalletOrderByWithAggregationInput[]
    by: DidwalletScalarFieldEnum[] | DidwalletScalarFieldEnum
    having?: didwalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DidwalletCountAggregateInputType | true
    _avg?: DidwalletAvgAggregateInputType
    _sum?: DidwalletSumAggregateInputType
    _min?: DidwalletMinAggregateInputType
    _max?: DidwalletMaxAggregateInputType
  }

  export type DidwalletGroupByOutputType = {
    id: number
    user_id: number
    wallet_address: string
    did: string
    is_primary: boolean
    created_at: Date
    last_used: Date
    _count: DidwalletCountAggregateOutputType | null
    _avg: DidwalletAvgAggregateOutputType | null
    _sum: DidwalletSumAggregateOutputType | null
    _min: DidwalletMinAggregateOutputType | null
    _max: DidwalletMaxAggregateOutputType | null
  }

  type GetDidwalletGroupByPayload<T extends didwalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DidwalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DidwalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DidwalletGroupByOutputType[P]>
            : GetScalarType<T[P], DidwalletGroupByOutputType[P]>
        }
      >
    >


  export type didwalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    wallet_address?: boolean
    did?: boolean
    is_primary?: boolean
    created_at?: boolean
    last_used?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["didwallet"]>


  export type didwalletSelectScalar = {
    id?: boolean
    user_id?: boolean
    wallet_address?: boolean
    did?: boolean
    is_primary?: boolean
    created_at?: boolean
    last_used?: boolean
  }

  export type didwalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $didwalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "didwallet"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      wallet_address: string
      did: string
      is_primary: boolean
      created_at: Date
      last_used: Date
    }, ExtArgs["result"]["didwallet"]>
    composites: {}
  }

  type didwalletGetPayload<S extends boolean | null | undefined | didwalletDefaultArgs> = $Result.GetResult<Prisma.$didwalletPayload, S>

  type didwalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<didwalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DidwalletCountAggregateInputType | true
    }

  export interface didwalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['didwallet'], meta: { name: 'didwallet' } }
    /**
     * Find zero or one Didwallet that matches the filter.
     * @param {didwalletFindUniqueArgs} args - Arguments to find a Didwallet
     * @example
     * // Get one Didwallet
     * const didwallet = await prisma.didwallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends didwalletFindUniqueArgs>(args: SelectSubset<T, didwalletFindUniqueArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Didwallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {didwalletFindUniqueOrThrowArgs} args - Arguments to find a Didwallet
     * @example
     * // Get one Didwallet
     * const didwallet = await prisma.didwallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends didwalletFindUniqueOrThrowArgs>(args: SelectSubset<T, didwalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Didwallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletFindFirstArgs} args - Arguments to find a Didwallet
     * @example
     * // Get one Didwallet
     * const didwallet = await prisma.didwallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends didwalletFindFirstArgs>(args?: SelectSubset<T, didwalletFindFirstArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Didwallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletFindFirstOrThrowArgs} args - Arguments to find a Didwallet
     * @example
     * // Get one Didwallet
     * const didwallet = await prisma.didwallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends didwalletFindFirstOrThrowArgs>(args?: SelectSubset<T, didwalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Didwallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Didwallets
     * const didwallets = await prisma.didwallet.findMany()
     * 
     * // Get first 10 Didwallets
     * const didwallets = await prisma.didwallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const didwalletWithIdOnly = await prisma.didwallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends didwalletFindManyArgs>(args?: SelectSubset<T, didwalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Didwallet.
     * @param {didwalletCreateArgs} args - Arguments to create a Didwallet.
     * @example
     * // Create one Didwallet
     * const Didwallet = await prisma.didwallet.create({
     *   data: {
     *     // ... data to create a Didwallet
     *   }
     * })
     * 
     */
    create<T extends didwalletCreateArgs>(args: SelectSubset<T, didwalletCreateArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Didwallets.
     * @param {didwalletCreateManyArgs} args - Arguments to create many Didwallets.
     * @example
     * // Create many Didwallets
     * const didwallet = await prisma.didwallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends didwalletCreateManyArgs>(args?: SelectSubset<T, didwalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Didwallet.
     * @param {didwalletDeleteArgs} args - Arguments to delete one Didwallet.
     * @example
     * // Delete one Didwallet
     * const Didwallet = await prisma.didwallet.delete({
     *   where: {
     *     // ... filter to delete one Didwallet
     *   }
     * })
     * 
     */
    delete<T extends didwalletDeleteArgs>(args: SelectSubset<T, didwalletDeleteArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Didwallet.
     * @param {didwalletUpdateArgs} args - Arguments to update one Didwallet.
     * @example
     * // Update one Didwallet
     * const didwallet = await prisma.didwallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends didwalletUpdateArgs>(args: SelectSubset<T, didwalletUpdateArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Didwallets.
     * @param {didwalletDeleteManyArgs} args - Arguments to filter Didwallets to delete.
     * @example
     * // Delete a few Didwallets
     * const { count } = await prisma.didwallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends didwalletDeleteManyArgs>(args?: SelectSubset<T, didwalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Didwallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Didwallets
     * const didwallet = await prisma.didwallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends didwalletUpdateManyArgs>(args: SelectSubset<T, didwalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Didwallet.
     * @param {didwalletUpsertArgs} args - Arguments to update or create a Didwallet.
     * @example
     * // Update or create a Didwallet
     * const didwallet = await prisma.didwallet.upsert({
     *   create: {
     *     // ... data to create a Didwallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Didwallet we want to update
     *   }
     * })
     */
    upsert<T extends didwalletUpsertArgs>(args: SelectSubset<T, didwalletUpsertArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Didwallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletCountArgs} args - Arguments to filter Didwallets to count.
     * @example
     * // Count the number of Didwallets
     * const count = await prisma.didwallet.count({
     *   where: {
     *     // ... the filter for the Didwallets we want to count
     *   }
     * })
    **/
    count<T extends didwalletCountArgs>(
      args?: Subset<T, didwalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DidwalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Didwallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DidwalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DidwalletAggregateArgs>(args: Subset<T, DidwalletAggregateArgs>): Prisma.PrismaPromise<GetDidwalletAggregateType<T>>

    /**
     * Group by Didwallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends didwalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: didwalletGroupByArgs['orderBy'] }
        : { orderBy?: didwalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, didwalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDidwalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the didwallet model
   */
  readonly fields: didwalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for didwallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__didwalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the didwallet model
   */ 
  interface didwalletFieldRefs {
    readonly id: FieldRef<"didwallet", 'Int'>
    readonly user_id: FieldRef<"didwallet", 'Int'>
    readonly wallet_address: FieldRef<"didwallet", 'String'>
    readonly did: FieldRef<"didwallet", 'String'>
    readonly is_primary: FieldRef<"didwallet", 'Boolean'>
    readonly created_at: FieldRef<"didwallet", 'DateTime'>
    readonly last_used: FieldRef<"didwallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * didwallet findUnique
   */
  export type didwalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallet to fetch.
     */
    where: didwalletWhereUniqueInput
  }

  /**
   * didwallet findUniqueOrThrow
   */
  export type didwalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallet to fetch.
     */
    where: didwalletWhereUniqueInput
  }

  /**
   * didwallet findFirst
   */
  export type didwalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallet to fetch.
     */
    where?: didwalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of didwallets to fetch.
     */
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for didwallets.
     */
    cursor?: didwalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` didwallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` didwallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of didwallets.
     */
    distinct?: DidwalletScalarFieldEnum | DidwalletScalarFieldEnum[]
  }

  /**
   * didwallet findFirstOrThrow
   */
  export type didwalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallet to fetch.
     */
    where?: didwalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of didwallets to fetch.
     */
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for didwallets.
     */
    cursor?: didwalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` didwallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` didwallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of didwallets.
     */
    distinct?: DidwalletScalarFieldEnum | DidwalletScalarFieldEnum[]
  }

  /**
   * didwallet findMany
   */
  export type didwalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallets to fetch.
     */
    where?: didwalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of didwallets to fetch.
     */
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing didwallets.
     */
    cursor?: didwalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` didwallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` didwallets.
     */
    skip?: number
    distinct?: DidwalletScalarFieldEnum | DidwalletScalarFieldEnum[]
  }

  /**
   * didwallet create
   */
  export type didwalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * The data needed to create a didwallet.
     */
    data: XOR<didwalletCreateInput, didwalletUncheckedCreateInput>
  }

  /**
   * didwallet createMany
   */
  export type didwalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many didwallets.
     */
    data: didwalletCreateManyInput | didwalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * didwallet update
   */
  export type didwalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * The data needed to update a didwallet.
     */
    data: XOR<didwalletUpdateInput, didwalletUncheckedUpdateInput>
    /**
     * Choose, which didwallet to update.
     */
    where: didwalletWhereUniqueInput
  }

  /**
   * didwallet updateMany
   */
  export type didwalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update didwallets.
     */
    data: XOR<didwalletUpdateManyMutationInput, didwalletUncheckedUpdateManyInput>
    /**
     * Filter which didwallets to update
     */
    where?: didwalletWhereInput
  }

  /**
   * didwallet upsert
   */
  export type didwalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * The filter to search for the didwallet to update in case it exists.
     */
    where: didwalletWhereUniqueInput
    /**
     * In case the didwallet found by the `where` argument doesn't exist, create a new didwallet with this data.
     */
    create: XOR<didwalletCreateInput, didwalletUncheckedCreateInput>
    /**
     * In case the didwallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<didwalletUpdateInput, didwalletUncheckedUpdateInput>
  }

  /**
   * didwallet delete
   */
  export type didwalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter which didwallet to delete.
     */
    where: didwalletWhereUniqueInput
  }

  /**
   * didwallet deleteMany
   */
  export type didwalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which didwallets to delete
     */
    where?: didwalletWhereInput
  }

  /**
   * didwallet without action
   */
  export type didwalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
  }


  /**
   * Model investor
   */

  export type AggregateInvestor = {
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  export type InvestorAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type InvestorSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type InvestorMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    investor_type: string | null
    accreditation_status: string | null
    accreditation_date: Date | null
    kyc_verified: boolean | null
    aml_verified: boolean | null
  }

  export type InvestorMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    investor_type: string | null
    accreditation_status: string | null
    accreditation_date: Date | null
    kyc_verified: boolean | null
    aml_verified: boolean | null
  }

  export type InvestorCountAggregateOutputType = {
    id: number
    user_id: number
    investor_type: number
    accreditation_status: number
    accreditation_date: number
    kyc_documents: number
    aml_documents: number
    kyc_verified: number
    aml_verified: number
    _all: number
  }


  export type InvestorAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type InvestorSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type InvestorMinAggregateInputType = {
    id?: true
    user_id?: true
    investor_type?: true
    accreditation_status?: true
    accreditation_date?: true
    kyc_verified?: true
    aml_verified?: true
  }

  export type InvestorMaxAggregateInputType = {
    id?: true
    user_id?: true
    investor_type?: true
    accreditation_status?: true
    accreditation_date?: true
    kyc_verified?: true
    aml_verified?: true
  }

  export type InvestorCountAggregateInputType = {
    id?: true
    user_id?: true
    investor_type?: true
    accreditation_status?: true
    accreditation_date?: true
    kyc_documents?: true
    aml_documents?: true
    kyc_verified?: true
    aml_verified?: true
    _all?: true
  }

  export type InvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investor to aggregate.
     */
    where?: investorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investors to fetch.
     */
    orderBy?: investorOrderByWithRelationInput | investorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: investorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned investors
    **/
    _count?: true | InvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorMaxAggregateInputType
  }

  export type GetInvestorAggregateType<T extends InvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestor[P]>
      : GetScalarType<T[P], AggregateInvestor[P]>
  }




  export type investorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: investorWhereInput
    orderBy?: investorOrderByWithAggregationInput | investorOrderByWithAggregationInput[]
    by: InvestorScalarFieldEnum[] | InvestorScalarFieldEnum
    having?: investorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorCountAggregateInputType | true
    _avg?: InvestorAvgAggregateInputType
    _sum?: InvestorSumAggregateInputType
    _min?: InvestorMinAggregateInputType
    _max?: InvestorMaxAggregateInputType
  }

  export type InvestorGroupByOutputType = {
    id: number
    user_id: number
    investor_type: string
    accreditation_status: string
    accreditation_date: Date | null
    kyc_documents: JsonValue | null
    aml_documents: JsonValue | null
    kyc_verified: boolean
    aml_verified: boolean
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  type GetInvestorGroupByPayload<T extends investorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorGroupByOutputType[P]>
        }
      >
    >


  export type investorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    investor_type?: boolean
    accreditation_status?: boolean
    accreditation_date?: boolean
    kyc_documents?: boolean
    aml_documents?: boolean
    kyc_verified?: boolean
    aml_verified?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>


  export type investorSelectScalar = {
    id?: boolean
    user_id?: boolean
    investor_type?: boolean
    accreditation_status?: boolean
    accreditation_date?: boolean
    kyc_documents?: boolean
    aml_documents?: boolean
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $investorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "investor"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      investor_type: string
      accreditation_status: string
      accreditation_date: Date | null
      kyc_documents: Prisma.JsonValue | null
      aml_documents: Prisma.JsonValue | null
      kyc_verified: boolean
      aml_verified: boolean
    }, ExtArgs["result"]["investor"]>
    composites: {}
  }

  type investorGetPayload<S extends boolean | null | undefined | investorDefaultArgs> = $Result.GetResult<Prisma.$investorPayload, S>

  type investorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<investorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvestorCountAggregateInputType | true
    }

  export interface investorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['investor'], meta: { name: 'investor' } }
    /**
     * Find zero or one Investor that matches the filter.
     * @param {investorFindUniqueArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends investorFindUniqueArgs>(args: SelectSubset<T, investorFindUniqueArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Investor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {investorFindUniqueOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends investorFindUniqueOrThrowArgs>(args: SelectSubset<T, investorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Investor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorFindFirstArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends investorFindFirstArgs>(args?: SelectSubset<T, investorFindFirstArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Investor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorFindFirstOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends investorFindFirstOrThrowArgs>(args?: SelectSubset<T, investorFindFirstOrThrowArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Investors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investors
     * const investors = await prisma.investor.findMany()
     * 
     * // Get first 10 Investors
     * const investors = await prisma.investor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorWithIdOnly = await prisma.investor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends investorFindManyArgs>(args?: SelectSubset<T, investorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Investor.
     * @param {investorCreateArgs} args - Arguments to create a Investor.
     * @example
     * // Create one Investor
     * const Investor = await prisma.investor.create({
     *   data: {
     *     // ... data to create a Investor
     *   }
     * })
     * 
     */
    create<T extends investorCreateArgs>(args: SelectSubset<T, investorCreateArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Investors.
     * @param {investorCreateManyArgs} args - Arguments to create many Investors.
     * @example
     * // Create many Investors
     * const investor = await prisma.investor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends investorCreateManyArgs>(args?: SelectSubset<T, investorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investor.
     * @param {investorDeleteArgs} args - Arguments to delete one Investor.
     * @example
     * // Delete one Investor
     * const Investor = await prisma.investor.delete({
     *   where: {
     *     // ... filter to delete one Investor
     *   }
     * })
     * 
     */
    delete<T extends investorDeleteArgs>(args: SelectSubset<T, investorDeleteArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Investor.
     * @param {investorUpdateArgs} args - Arguments to update one Investor.
     * @example
     * // Update one Investor
     * const investor = await prisma.investor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends investorUpdateArgs>(args: SelectSubset<T, investorUpdateArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Investors.
     * @param {investorDeleteManyArgs} args - Arguments to filter Investors to delete.
     * @example
     * // Delete a few Investors
     * const { count } = await prisma.investor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends investorDeleteManyArgs>(args?: SelectSubset<T, investorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends investorUpdateManyArgs>(args: SelectSubset<T, investorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investor.
     * @param {investorUpsertArgs} args - Arguments to update or create a Investor.
     * @example
     * // Update or create a Investor
     * const investor = await prisma.investor.upsert({
     *   create: {
     *     // ... data to create a Investor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investor we want to update
     *   }
     * })
     */
    upsert<T extends investorUpsertArgs>(args: SelectSubset<T, investorUpsertArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorCountArgs} args - Arguments to filter Investors to count.
     * @example
     * // Count the number of Investors
     * const count = await prisma.investor.count({
     *   where: {
     *     // ... the filter for the Investors we want to count
     *   }
     * })
    **/
    count<T extends investorCountArgs>(
      args?: Subset<T, investorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorAggregateArgs>(args: Subset<T, InvestorAggregateArgs>): Prisma.PrismaPromise<GetInvestorAggregateType<T>>

    /**
     * Group by Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends investorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: investorGroupByArgs['orderBy'] }
        : { orderBy?: investorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, investorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the investor model
   */
  readonly fields: investorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for investor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__investorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the investor model
   */ 
  interface investorFieldRefs {
    readonly id: FieldRef<"investor", 'Int'>
    readonly user_id: FieldRef<"investor", 'Int'>
    readonly investor_type: FieldRef<"investor", 'String'>
    readonly accreditation_status: FieldRef<"investor", 'String'>
    readonly accreditation_date: FieldRef<"investor", 'DateTime'>
    readonly kyc_documents: FieldRef<"investor", 'Json'>
    readonly aml_documents: FieldRef<"investor", 'Json'>
    readonly kyc_verified: FieldRef<"investor", 'Boolean'>
    readonly aml_verified: FieldRef<"investor", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * investor findUnique
   */
  export type investorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investor to fetch.
     */
    where: investorWhereUniqueInput
  }

  /**
   * investor findUniqueOrThrow
   */
  export type investorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investor to fetch.
     */
    where: investorWhereUniqueInput
  }

  /**
   * investor findFirst
   */
  export type investorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investor to fetch.
     */
    where?: investorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investors to fetch.
     */
    orderBy?: investorOrderByWithRelationInput | investorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investors.
     */
    cursor?: investorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * investor findFirstOrThrow
   */
  export type investorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investor to fetch.
     */
    where?: investorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investors to fetch.
     */
    orderBy?: investorOrderByWithRelationInput | investorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investors.
     */
    cursor?: investorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * investor findMany
   */
  export type investorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investors to fetch.
     */
    where?: investorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investors to fetch.
     */
    orderBy?: investorOrderByWithRelationInput | investorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing investors.
     */
    cursor?: investorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investors.
     */
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * investor create
   */
  export type investorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * The data needed to create a investor.
     */
    data: XOR<investorCreateInput, investorUncheckedCreateInput>
  }

  /**
   * investor createMany
   */
  export type investorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many investors.
     */
    data: investorCreateManyInput | investorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * investor update
   */
  export type investorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * The data needed to update a investor.
     */
    data: XOR<investorUpdateInput, investorUncheckedUpdateInput>
    /**
     * Choose, which investor to update.
     */
    where: investorWhereUniqueInput
  }

  /**
   * investor updateMany
   */
  export type investorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update investors.
     */
    data: XOR<investorUpdateManyMutationInput, investorUncheckedUpdateManyInput>
    /**
     * Filter which investors to update
     */
    where?: investorWhereInput
  }

  /**
   * investor upsert
   */
  export type investorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * The filter to search for the investor to update in case it exists.
     */
    where: investorWhereUniqueInput
    /**
     * In case the investor found by the `where` argument doesn't exist, create a new investor with this data.
     */
    create: XOR<investorCreateInput, investorUncheckedCreateInput>
    /**
     * In case the investor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<investorUpdateInput, investorUncheckedUpdateInput>
  }

  /**
   * investor delete
   */
  export type investorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter which investor to delete.
     */
    where: investorWhereUniqueInput
  }

  /**
   * investor deleteMany
   */
  export type investorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investors to delete
     */
    where?: investorWhereInput
  }

  /**
   * investor without action
   */
  export type investorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
  }


  /**
   * Model issuer
   */

  export type AggregateIssuer = {
    _count: IssuerCountAggregateOutputType | null
    _avg: IssuerAvgAggregateOutputType | null
    _sum: IssuerSumAggregateOutputType | null
    _min: IssuerMinAggregateOutputType | null
    _max: IssuerMaxAggregateOutputType | null
  }

  export type IssuerAvgAggregateOutputType = {
    user_id: number | null
  }

  export type IssuerSumAggregateOutputType = {
    user_id: number | null
  }

  export type IssuerMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    company_name: string | null
    company_registration_number: string | null
    jurisdiction: string | null
    verification_status: boolean | null
    verification_date: Date | null
    is_active: boolean | null
    is_kyb_completed: boolean | null
    mobile_number: string | null
    platform_client_id: string | null
    registration_date: Date | null
    sumsub_applicant_id: string | null
    sumsub_correlation_id: string | null
    sumsub_external_id: string | null
    sumsub_inspection_id: string | null
    did: string | null
    did_created_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type IssuerMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    company_name: string | null
    company_registration_number: string | null
    jurisdiction: string | null
    verification_status: boolean | null
    verification_date: Date | null
    is_active: boolean | null
    is_kyb_completed: boolean | null
    mobile_number: string | null
    platform_client_id: string | null
    registration_date: Date | null
    sumsub_applicant_id: string | null
    sumsub_correlation_id: string | null
    sumsub_external_id: string | null
    sumsub_inspection_id: string | null
    did: string | null
    did_created_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type IssuerCountAggregateOutputType = {
    id: number
    user_id: number
    company_name: number
    company_registration_number: number
    jurisdiction: number
    verification_status: number
    verification_date: number
    company_documents: number
    is_active: number
    is_kyb_completed: number
    mobile_number: number
    platform_client_id: number
    registration_date: number
    sumsub_applicant_id: number
    sumsub_correlation_id: number
    sumsub_external_id: number
    sumsub_inspection_id: number
    did: number
    did_created_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type IssuerAvgAggregateInputType = {
    user_id?: true
  }

  export type IssuerSumAggregateInputType = {
    user_id?: true
  }

  export type IssuerMinAggregateInputType = {
    id?: true
    user_id?: true
    company_name?: true
    company_registration_number?: true
    jurisdiction?: true
    verification_status?: true
    verification_date?: true
    is_active?: true
    is_kyb_completed?: true
    mobile_number?: true
    platform_client_id?: true
    registration_date?: true
    sumsub_applicant_id?: true
    sumsub_correlation_id?: true
    sumsub_external_id?: true
    sumsub_inspection_id?: true
    did?: true
    did_created_at?: true
    created_at?: true
    updated_at?: true
  }

  export type IssuerMaxAggregateInputType = {
    id?: true
    user_id?: true
    company_name?: true
    company_registration_number?: true
    jurisdiction?: true
    verification_status?: true
    verification_date?: true
    is_active?: true
    is_kyb_completed?: true
    mobile_number?: true
    platform_client_id?: true
    registration_date?: true
    sumsub_applicant_id?: true
    sumsub_correlation_id?: true
    sumsub_external_id?: true
    sumsub_inspection_id?: true
    did?: true
    did_created_at?: true
    created_at?: true
    updated_at?: true
  }

  export type IssuerCountAggregateInputType = {
    id?: true
    user_id?: true
    company_name?: true
    company_registration_number?: true
    jurisdiction?: true
    verification_status?: true
    verification_date?: true
    company_documents?: true
    is_active?: true
    is_kyb_completed?: true
    mobile_number?: true
    platform_client_id?: true
    registration_date?: true
    sumsub_applicant_id?: true
    sumsub_correlation_id?: true
    sumsub_external_id?: true
    sumsub_inspection_id?: true
    did?: true
    did_created_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type IssuerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which issuer to aggregate.
     */
    where?: issuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuers to fetch.
     */
    orderBy?: issuerOrderByWithRelationInput | issuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: issuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned issuers
    **/
    _count?: true | IssuerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IssuerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IssuerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssuerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssuerMaxAggregateInputType
  }

  export type GetIssuerAggregateType<T extends IssuerAggregateArgs> = {
        [P in keyof T & keyof AggregateIssuer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssuer[P]>
      : GetScalarType<T[P], AggregateIssuer[P]>
  }




  export type issuerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: issuerWhereInput
    orderBy?: issuerOrderByWithAggregationInput | issuerOrderByWithAggregationInput[]
    by: IssuerScalarFieldEnum[] | IssuerScalarFieldEnum
    having?: issuerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssuerCountAggregateInputType | true
    _avg?: IssuerAvgAggregateInputType
    _sum?: IssuerSumAggregateInputType
    _min?: IssuerMinAggregateInputType
    _max?: IssuerMaxAggregateInputType
  }

  export type IssuerGroupByOutputType = {
    id: string
    user_id: number
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status: boolean
    verification_date: Date | null
    company_documents: JsonValue | null
    is_active: boolean
    is_kyb_completed: boolean
    mobile_number: string | null
    platform_client_id: string | null
    registration_date: Date
    sumsub_applicant_id: string | null
    sumsub_correlation_id: string | null
    sumsub_external_id: string | null
    sumsub_inspection_id: string | null
    did: string | null
    did_created_at: Date | null
    created_at: Date
    updated_at: Date
    _count: IssuerCountAggregateOutputType | null
    _avg: IssuerAvgAggregateOutputType | null
    _sum: IssuerSumAggregateOutputType | null
    _min: IssuerMinAggregateOutputType | null
    _max: IssuerMaxAggregateOutputType | null
  }

  type GetIssuerGroupByPayload<T extends issuerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssuerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssuerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssuerGroupByOutputType[P]>
            : GetScalarType<T[P], IssuerGroupByOutputType[P]>
        }
      >
    >


  export type issuerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    company_name?: boolean
    company_registration_number?: boolean
    jurisdiction?: boolean
    verification_status?: boolean
    verification_date?: boolean
    company_documents?: boolean
    is_active?: boolean
    is_kyb_completed?: boolean
    mobile_number?: boolean
    platform_client_id?: boolean
    registration_date?: boolean
    sumsub_applicant_id?: boolean
    sumsub_correlation_id?: boolean
    sumsub_external_id?: boolean
    sumsub_inspection_id?: boolean
    did?: boolean
    did_created_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    wallet?: boolean | issuer$walletArgs<ExtArgs>
  }, ExtArgs["result"]["issuer"]>


  export type issuerSelectScalar = {
    id?: boolean
    user_id?: boolean
    company_name?: boolean
    company_registration_number?: boolean
    jurisdiction?: boolean
    verification_status?: boolean
    verification_date?: boolean
    company_documents?: boolean
    is_active?: boolean
    is_kyb_completed?: boolean
    mobile_number?: boolean
    platform_client_id?: boolean
    registration_date?: boolean
    sumsub_applicant_id?: boolean
    sumsub_correlation_id?: boolean
    sumsub_external_id?: boolean
    sumsub_inspection_id?: boolean
    did?: boolean
    did_created_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type issuerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    wallet?: boolean | issuer$walletArgs<ExtArgs>
  }

  export type $issuerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "issuer"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      wallet: Prisma.$walletPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: number
      company_name: string
      company_registration_number: string
      jurisdiction: string
      verification_status: boolean
      verification_date: Date | null
      company_documents: Prisma.JsonValue | null
      is_active: boolean
      is_kyb_completed: boolean
      mobile_number: string | null
      platform_client_id: string | null
      registration_date: Date
      sumsub_applicant_id: string | null
      sumsub_correlation_id: string | null
      sumsub_external_id: string | null
      sumsub_inspection_id: string | null
      did: string | null
      did_created_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["issuer"]>
    composites: {}
  }

  type issuerGetPayload<S extends boolean | null | undefined | issuerDefaultArgs> = $Result.GetResult<Prisma.$issuerPayload, S>

  type issuerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<issuerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IssuerCountAggregateInputType | true
    }

  export interface issuerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['issuer'], meta: { name: 'issuer' } }
    /**
     * Find zero or one Issuer that matches the filter.
     * @param {issuerFindUniqueArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends issuerFindUniqueArgs>(args: SelectSubset<T, issuerFindUniqueArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Issuer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {issuerFindUniqueOrThrowArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends issuerFindUniqueOrThrowArgs>(args: SelectSubset<T, issuerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Issuer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerFindFirstArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends issuerFindFirstArgs>(args?: SelectSubset<T, issuerFindFirstArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Issuer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerFindFirstOrThrowArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends issuerFindFirstOrThrowArgs>(args?: SelectSubset<T, issuerFindFirstOrThrowArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Issuers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Issuers
     * const issuers = await prisma.issuer.findMany()
     * 
     * // Get first 10 Issuers
     * const issuers = await prisma.issuer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issuerWithIdOnly = await prisma.issuer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends issuerFindManyArgs>(args?: SelectSubset<T, issuerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Issuer.
     * @param {issuerCreateArgs} args - Arguments to create a Issuer.
     * @example
     * // Create one Issuer
     * const Issuer = await prisma.issuer.create({
     *   data: {
     *     // ... data to create a Issuer
     *   }
     * })
     * 
     */
    create<T extends issuerCreateArgs>(args: SelectSubset<T, issuerCreateArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Issuers.
     * @param {issuerCreateManyArgs} args - Arguments to create many Issuers.
     * @example
     * // Create many Issuers
     * const issuer = await prisma.issuer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends issuerCreateManyArgs>(args?: SelectSubset<T, issuerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Issuer.
     * @param {issuerDeleteArgs} args - Arguments to delete one Issuer.
     * @example
     * // Delete one Issuer
     * const Issuer = await prisma.issuer.delete({
     *   where: {
     *     // ... filter to delete one Issuer
     *   }
     * })
     * 
     */
    delete<T extends issuerDeleteArgs>(args: SelectSubset<T, issuerDeleteArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Issuer.
     * @param {issuerUpdateArgs} args - Arguments to update one Issuer.
     * @example
     * // Update one Issuer
     * const issuer = await prisma.issuer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends issuerUpdateArgs>(args: SelectSubset<T, issuerUpdateArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Issuers.
     * @param {issuerDeleteManyArgs} args - Arguments to filter Issuers to delete.
     * @example
     * // Delete a few Issuers
     * const { count } = await prisma.issuer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends issuerDeleteManyArgs>(args?: SelectSubset<T, issuerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issuers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Issuers
     * const issuer = await prisma.issuer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends issuerUpdateManyArgs>(args: SelectSubset<T, issuerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Issuer.
     * @param {issuerUpsertArgs} args - Arguments to update or create a Issuer.
     * @example
     * // Update or create a Issuer
     * const issuer = await prisma.issuer.upsert({
     *   create: {
     *     // ... data to create a Issuer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Issuer we want to update
     *   }
     * })
     */
    upsert<T extends issuerUpsertArgs>(args: SelectSubset<T, issuerUpsertArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Issuers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerCountArgs} args - Arguments to filter Issuers to count.
     * @example
     * // Count the number of Issuers
     * const count = await prisma.issuer.count({
     *   where: {
     *     // ... the filter for the Issuers we want to count
     *   }
     * })
    **/
    count<T extends issuerCountArgs>(
      args?: Subset<T, issuerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssuerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Issuer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssuerAggregateArgs>(args: Subset<T, IssuerAggregateArgs>): Prisma.PrismaPromise<GetIssuerAggregateType<T>>

    /**
     * Group by Issuer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends issuerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: issuerGroupByArgs['orderBy'] }
        : { orderBy?: issuerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, issuerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssuerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the issuer model
   */
  readonly fields: issuerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for issuer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__issuerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    wallet<T extends issuer$walletArgs<ExtArgs> = {}>(args?: Subset<T, issuer$walletArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the issuer model
   */ 
  interface issuerFieldRefs {
    readonly id: FieldRef<"issuer", 'String'>
    readonly user_id: FieldRef<"issuer", 'Int'>
    readonly company_name: FieldRef<"issuer", 'String'>
    readonly company_registration_number: FieldRef<"issuer", 'String'>
    readonly jurisdiction: FieldRef<"issuer", 'String'>
    readonly verification_status: FieldRef<"issuer", 'Boolean'>
    readonly verification_date: FieldRef<"issuer", 'DateTime'>
    readonly company_documents: FieldRef<"issuer", 'Json'>
    readonly is_active: FieldRef<"issuer", 'Boolean'>
    readonly is_kyb_completed: FieldRef<"issuer", 'Boolean'>
    readonly mobile_number: FieldRef<"issuer", 'String'>
    readonly platform_client_id: FieldRef<"issuer", 'String'>
    readonly registration_date: FieldRef<"issuer", 'DateTime'>
    readonly sumsub_applicant_id: FieldRef<"issuer", 'String'>
    readonly sumsub_correlation_id: FieldRef<"issuer", 'String'>
    readonly sumsub_external_id: FieldRef<"issuer", 'String'>
    readonly sumsub_inspection_id: FieldRef<"issuer", 'String'>
    readonly did: FieldRef<"issuer", 'String'>
    readonly did_created_at: FieldRef<"issuer", 'DateTime'>
    readonly created_at: FieldRef<"issuer", 'DateTime'>
    readonly updated_at: FieldRef<"issuer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * issuer findUnique
   */
  export type issuerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuer to fetch.
     */
    where: issuerWhereUniqueInput
  }

  /**
   * issuer findUniqueOrThrow
   */
  export type issuerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuer to fetch.
     */
    where: issuerWhereUniqueInput
  }

  /**
   * issuer findFirst
   */
  export type issuerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuer to fetch.
     */
    where?: issuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuers to fetch.
     */
    orderBy?: issuerOrderByWithRelationInput | issuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issuers.
     */
    cursor?: issuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issuers.
     */
    distinct?: IssuerScalarFieldEnum | IssuerScalarFieldEnum[]
  }

  /**
   * issuer findFirstOrThrow
   */
  export type issuerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuer to fetch.
     */
    where?: issuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuers to fetch.
     */
    orderBy?: issuerOrderByWithRelationInput | issuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issuers.
     */
    cursor?: issuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issuers.
     */
    distinct?: IssuerScalarFieldEnum | IssuerScalarFieldEnum[]
  }

  /**
   * issuer findMany
   */
  export type issuerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuers to fetch.
     */
    where?: issuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuers to fetch.
     */
    orderBy?: issuerOrderByWithRelationInput | issuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing issuers.
     */
    cursor?: issuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuers.
     */
    skip?: number
    distinct?: IssuerScalarFieldEnum | IssuerScalarFieldEnum[]
  }

  /**
   * issuer create
   */
  export type issuerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * The data needed to create a issuer.
     */
    data: XOR<issuerCreateInput, issuerUncheckedCreateInput>
  }

  /**
   * issuer createMany
   */
  export type issuerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many issuers.
     */
    data: issuerCreateManyInput | issuerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * issuer update
   */
  export type issuerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * The data needed to update a issuer.
     */
    data: XOR<issuerUpdateInput, issuerUncheckedUpdateInput>
    /**
     * Choose, which issuer to update.
     */
    where: issuerWhereUniqueInput
  }

  /**
   * issuer updateMany
   */
  export type issuerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update issuers.
     */
    data: XOR<issuerUpdateManyMutationInput, issuerUncheckedUpdateManyInput>
    /**
     * Filter which issuers to update
     */
    where?: issuerWhereInput
  }

  /**
   * issuer upsert
   */
  export type issuerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * The filter to search for the issuer to update in case it exists.
     */
    where: issuerWhereUniqueInput
    /**
     * In case the issuer found by the `where` argument doesn't exist, create a new issuer with this data.
     */
    create: XOR<issuerCreateInput, issuerUncheckedCreateInput>
    /**
     * In case the issuer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<issuerUpdateInput, issuerUncheckedUpdateInput>
  }

  /**
   * issuer delete
   */
  export type issuerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter which issuer to delete.
     */
    where: issuerWhereUniqueInput
  }

  /**
   * issuer deleteMany
   */
  export type issuerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which issuers to delete
     */
    where?: issuerWhereInput
  }

  /**
   * issuer.wallet
   */
  export type issuer$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    where?: walletWhereInput
  }

  /**
   * issuer without action
   */
  export type issuerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
  }


  /**
   * Model kyc_address_info
   */

  export type AggregateKyc_address_info = {
    _count: Kyc_address_infoCountAggregateOutputType | null
    _avg: Kyc_address_infoAvgAggregateOutputType | null
    _sum: Kyc_address_infoSumAggregateOutputType | null
    _min: Kyc_address_infoMinAggregateOutputType | null
    _max: Kyc_address_infoMaxAggregateOutputType | null
  }

  export type Kyc_address_infoAvgAggregateOutputType = {
    id: number | null
  }

  export type Kyc_address_infoSumAggregateOutputType = {
    id: number | null
  }

  export type Kyc_address_infoMinAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    address_type: string | null
    is_primary: boolean | null
    street: string | null
    street_line2: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_verified: boolean | null
    verification_method: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Kyc_address_infoMaxAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    address_type: string | null
    is_primary: boolean | null
    street: string | null
    street_line2: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_verified: boolean | null
    verification_method: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Kyc_address_infoCountAggregateOutputType = {
    id: number
    applicant_id: number
    address_type: number
    is_primary: number
    street: number
    street_line2: number
    city: number
    state: number
    postal_code: number
    country: number
    is_verified: number
    verification_method: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Kyc_address_infoAvgAggregateInputType = {
    id?: true
  }

  export type Kyc_address_infoSumAggregateInputType = {
    id?: true
  }

  export type Kyc_address_infoMinAggregateInputType = {
    id?: true
    applicant_id?: true
    address_type?: true
    is_primary?: true
    street?: true
    street_line2?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_verified?: true
    verification_method?: true
    created_at?: true
    updated_at?: true
  }

  export type Kyc_address_infoMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    address_type?: true
    is_primary?: true
    street?: true
    street_line2?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_verified?: true
    verification_method?: true
    created_at?: true
    updated_at?: true
  }

  export type Kyc_address_infoCountAggregateInputType = {
    id?: true
    applicant_id?: true
    address_type?: true
    is_primary?: true
    street?: true
    street_line2?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_verified?: true
    verification_method?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Kyc_address_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_address_info to aggregate.
     */
    where?: kyc_address_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_address_infos to fetch.
     */
    orderBy?: kyc_address_infoOrderByWithRelationInput | kyc_address_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kyc_address_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_address_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_address_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kyc_address_infos
    **/
    _count?: true | Kyc_address_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kyc_address_infoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kyc_address_infoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kyc_address_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kyc_address_infoMaxAggregateInputType
  }

  export type GetKyc_address_infoAggregateType<T extends Kyc_address_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc_address_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc_address_info[P]>
      : GetScalarType<T[P], AggregateKyc_address_info[P]>
  }




  export type kyc_address_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_address_infoWhereInput
    orderBy?: kyc_address_infoOrderByWithAggregationInput | kyc_address_infoOrderByWithAggregationInput[]
    by: Kyc_address_infoScalarFieldEnum[] | Kyc_address_infoScalarFieldEnum
    having?: kyc_address_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kyc_address_infoCountAggregateInputType | true
    _avg?: Kyc_address_infoAvgAggregateInputType
    _sum?: Kyc_address_infoSumAggregateInputType
    _min?: Kyc_address_infoMinAggregateInputType
    _max?: Kyc_address_infoMaxAggregateInputType
  }

  export type Kyc_address_infoGroupByOutputType = {
    id: number
    applicant_id: string
    address_type: string
    is_primary: boolean
    street: string | null
    street_line2: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_verified: boolean
    verification_method: string | null
    created_at: Date
    updated_at: Date
    _count: Kyc_address_infoCountAggregateOutputType | null
    _avg: Kyc_address_infoAvgAggregateOutputType | null
    _sum: Kyc_address_infoSumAggregateOutputType | null
    _min: Kyc_address_infoMinAggregateOutputType | null
    _max: Kyc_address_infoMaxAggregateOutputType | null
  }

  type GetKyc_address_infoGroupByPayload<T extends kyc_address_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kyc_address_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kyc_address_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kyc_address_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Kyc_address_infoGroupByOutputType[P]>
        }
      >
    >


  export type kyc_address_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicant_id?: boolean
    address_type?: boolean
    is_primary?: boolean
    street?: boolean
    street_line2?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_verified?: boolean
    verification_method?: boolean
    created_at?: boolean
    updated_at?: boolean
    kyc_applicants?: boolean | kyc_applicantsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc_address_info"]>


  export type kyc_address_infoSelectScalar = {
    id?: boolean
    applicant_id?: boolean
    address_type?: boolean
    is_primary?: boolean
    street?: boolean
    street_line2?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_verified?: boolean
    verification_method?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type kyc_address_infoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_applicants?: boolean | kyc_applicantsDefaultArgs<ExtArgs>
  }

  export type $kyc_address_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kyc_address_info"
    objects: {
      kyc_applicants: Prisma.$kyc_applicantsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicant_id: string
      address_type: string
      is_primary: boolean
      street: string | null
      street_line2: string | null
      city: string | null
      state: string | null
      postal_code: string | null
      country: string | null
      is_verified: boolean
      verification_method: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["kyc_address_info"]>
    composites: {}
  }

  type kyc_address_infoGetPayload<S extends boolean | null | undefined | kyc_address_infoDefaultArgs> = $Result.GetResult<Prisma.$kyc_address_infoPayload, S>

  type kyc_address_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kyc_address_infoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kyc_address_infoCountAggregateInputType | true
    }

  export interface kyc_address_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kyc_address_info'], meta: { name: 'kyc_address_info' } }
    /**
     * Find zero or one Kyc_address_info that matches the filter.
     * @param {kyc_address_infoFindUniqueArgs} args - Arguments to find a Kyc_address_info
     * @example
     * // Get one Kyc_address_info
     * const kyc_address_info = await prisma.kyc_address_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kyc_address_infoFindUniqueArgs>(args: SelectSubset<T, kyc_address_infoFindUniqueArgs<ExtArgs>>): Prisma__kyc_address_infoClient<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kyc_address_info that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kyc_address_infoFindUniqueOrThrowArgs} args - Arguments to find a Kyc_address_info
     * @example
     * // Get one Kyc_address_info
     * const kyc_address_info = await prisma.kyc_address_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kyc_address_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, kyc_address_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kyc_address_infoClient<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kyc_address_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_address_infoFindFirstArgs} args - Arguments to find a Kyc_address_info
     * @example
     * // Get one Kyc_address_info
     * const kyc_address_info = await prisma.kyc_address_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kyc_address_infoFindFirstArgs>(args?: SelectSubset<T, kyc_address_infoFindFirstArgs<ExtArgs>>): Prisma__kyc_address_infoClient<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kyc_address_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_address_infoFindFirstOrThrowArgs} args - Arguments to find a Kyc_address_info
     * @example
     * // Get one Kyc_address_info
     * const kyc_address_info = await prisma.kyc_address_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kyc_address_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, kyc_address_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__kyc_address_infoClient<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kyc_address_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_address_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kyc_address_infos
     * const kyc_address_infos = await prisma.kyc_address_info.findMany()
     * 
     * // Get first 10 Kyc_address_infos
     * const kyc_address_infos = await prisma.kyc_address_info.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kyc_address_infoWithIdOnly = await prisma.kyc_address_info.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kyc_address_infoFindManyArgs>(args?: SelectSubset<T, kyc_address_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kyc_address_info.
     * @param {kyc_address_infoCreateArgs} args - Arguments to create a Kyc_address_info.
     * @example
     * // Create one Kyc_address_info
     * const Kyc_address_info = await prisma.kyc_address_info.create({
     *   data: {
     *     // ... data to create a Kyc_address_info
     *   }
     * })
     * 
     */
    create<T extends kyc_address_infoCreateArgs>(args: SelectSubset<T, kyc_address_infoCreateArgs<ExtArgs>>): Prisma__kyc_address_infoClient<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kyc_address_infos.
     * @param {kyc_address_infoCreateManyArgs} args - Arguments to create many Kyc_address_infos.
     * @example
     * // Create many Kyc_address_infos
     * const kyc_address_info = await prisma.kyc_address_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kyc_address_infoCreateManyArgs>(args?: SelectSubset<T, kyc_address_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kyc_address_info.
     * @param {kyc_address_infoDeleteArgs} args - Arguments to delete one Kyc_address_info.
     * @example
     * // Delete one Kyc_address_info
     * const Kyc_address_info = await prisma.kyc_address_info.delete({
     *   where: {
     *     // ... filter to delete one Kyc_address_info
     *   }
     * })
     * 
     */
    delete<T extends kyc_address_infoDeleteArgs>(args: SelectSubset<T, kyc_address_infoDeleteArgs<ExtArgs>>): Prisma__kyc_address_infoClient<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kyc_address_info.
     * @param {kyc_address_infoUpdateArgs} args - Arguments to update one Kyc_address_info.
     * @example
     * // Update one Kyc_address_info
     * const kyc_address_info = await prisma.kyc_address_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kyc_address_infoUpdateArgs>(args: SelectSubset<T, kyc_address_infoUpdateArgs<ExtArgs>>): Prisma__kyc_address_infoClient<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kyc_address_infos.
     * @param {kyc_address_infoDeleteManyArgs} args - Arguments to filter Kyc_address_infos to delete.
     * @example
     * // Delete a few Kyc_address_infos
     * const { count } = await prisma.kyc_address_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kyc_address_infoDeleteManyArgs>(args?: SelectSubset<T, kyc_address_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kyc_address_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_address_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kyc_address_infos
     * const kyc_address_info = await prisma.kyc_address_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kyc_address_infoUpdateManyArgs>(args: SelectSubset<T, kyc_address_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kyc_address_info.
     * @param {kyc_address_infoUpsertArgs} args - Arguments to update or create a Kyc_address_info.
     * @example
     * // Update or create a Kyc_address_info
     * const kyc_address_info = await prisma.kyc_address_info.upsert({
     *   create: {
     *     // ... data to create a Kyc_address_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc_address_info we want to update
     *   }
     * })
     */
    upsert<T extends kyc_address_infoUpsertArgs>(args: SelectSubset<T, kyc_address_infoUpsertArgs<ExtArgs>>): Prisma__kyc_address_infoClient<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kyc_address_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_address_infoCountArgs} args - Arguments to filter Kyc_address_infos to count.
     * @example
     * // Count the number of Kyc_address_infos
     * const count = await prisma.kyc_address_info.count({
     *   where: {
     *     // ... the filter for the Kyc_address_infos we want to count
     *   }
     * })
    **/
    count<T extends kyc_address_infoCountArgs>(
      args?: Subset<T, kyc_address_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kyc_address_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc_address_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kyc_address_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kyc_address_infoAggregateArgs>(args: Subset<T, Kyc_address_infoAggregateArgs>): Prisma.PrismaPromise<GetKyc_address_infoAggregateType<T>>

    /**
     * Group by Kyc_address_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_address_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kyc_address_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kyc_address_infoGroupByArgs['orderBy'] }
        : { orderBy?: kyc_address_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kyc_address_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKyc_address_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kyc_address_info model
   */
  readonly fields: kyc_address_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kyc_address_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kyc_address_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_applicants<T extends kyc_applicantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicantsDefaultArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kyc_address_info model
   */ 
  interface kyc_address_infoFieldRefs {
    readonly id: FieldRef<"kyc_address_info", 'Int'>
    readonly applicant_id: FieldRef<"kyc_address_info", 'String'>
    readonly address_type: FieldRef<"kyc_address_info", 'String'>
    readonly is_primary: FieldRef<"kyc_address_info", 'Boolean'>
    readonly street: FieldRef<"kyc_address_info", 'String'>
    readonly street_line2: FieldRef<"kyc_address_info", 'String'>
    readonly city: FieldRef<"kyc_address_info", 'String'>
    readonly state: FieldRef<"kyc_address_info", 'String'>
    readonly postal_code: FieldRef<"kyc_address_info", 'String'>
    readonly country: FieldRef<"kyc_address_info", 'String'>
    readonly is_verified: FieldRef<"kyc_address_info", 'Boolean'>
    readonly verification_method: FieldRef<"kyc_address_info", 'String'>
    readonly created_at: FieldRef<"kyc_address_info", 'DateTime'>
    readonly updated_at: FieldRef<"kyc_address_info", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * kyc_address_info findUnique
   */
  export type kyc_address_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_address_info to fetch.
     */
    where: kyc_address_infoWhereUniqueInput
  }

  /**
   * kyc_address_info findUniqueOrThrow
   */
  export type kyc_address_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_address_info to fetch.
     */
    where: kyc_address_infoWhereUniqueInput
  }

  /**
   * kyc_address_info findFirst
   */
  export type kyc_address_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_address_info to fetch.
     */
    where?: kyc_address_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_address_infos to fetch.
     */
    orderBy?: kyc_address_infoOrderByWithRelationInput | kyc_address_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_address_infos.
     */
    cursor?: kyc_address_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_address_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_address_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_address_infos.
     */
    distinct?: Kyc_address_infoScalarFieldEnum | Kyc_address_infoScalarFieldEnum[]
  }

  /**
   * kyc_address_info findFirstOrThrow
   */
  export type kyc_address_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_address_info to fetch.
     */
    where?: kyc_address_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_address_infos to fetch.
     */
    orderBy?: kyc_address_infoOrderByWithRelationInput | kyc_address_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_address_infos.
     */
    cursor?: kyc_address_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_address_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_address_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_address_infos.
     */
    distinct?: Kyc_address_infoScalarFieldEnum | Kyc_address_infoScalarFieldEnum[]
  }

  /**
   * kyc_address_info findMany
   */
  export type kyc_address_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_address_infos to fetch.
     */
    where?: kyc_address_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_address_infos to fetch.
     */
    orderBy?: kyc_address_infoOrderByWithRelationInput | kyc_address_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kyc_address_infos.
     */
    cursor?: kyc_address_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_address_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_address_infos.
     */
    skip?: number
    distinct?: Kyc_address_infoScalarFieldEnum | Kyc_address_infoScalarFieldEnum[]
  }

  /**
   * kyc_address_info create
   */
  export type kyc_address_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    /**
     * The data needed to create a kyc_address_info.
     */
    data: XOR<kyc_address_infoCreateInput, kyc_address_infoUncheckedCreateInput>
  }

  /**
   * kyc_address_info createMany
   */
  export type kyc_address_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kyc_address_infos.
     */
    data: kyc_address_infoCreateManyInput | kyc_address_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kyc_address_info update
   */
  export type kyc_address_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    /**
     * The data needed to update a kyc_address_info.
     */
    data: XOR<kyc_address_infoUpdateInput, kyc_address_infoUncheckedUpdateInput>
    /**
     * Choose, which kyc_address_info to update.
     */
    where: kyc_address_infoWhereUniqueInput
  }

  /**
   * kyc_address_info updateMany
   */
  export type kyc_address_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kyc_address_infos.
     */
    data: XOR<kyc_address_infoUpdateManyMutationInput, kyc_address_infoUncheckedUpdateManyInput>
    /**
     * Filter which kyc_address_infos to update
     */
    where?: kyc_address_infoWhereInput
  }

  /**
   * kyc_address_info upsert
   */
  export type kyc_address_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    /**
     * The filter to search for the kyc_address_info to update in case it exists.
     */
    where: kyc_address_infoWhereUniqueInput
    /**
     * In case the kyc_address_info found by the `where` argument doesn't exist, create a new kyc_address_info with this data.
     */
    create: XOR<kyc_address_infoCreateInput, kyc_address_infoUncheckedCreateInput>
    /**
     * In case the kyc_address_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kyc_address_infoUpdateInput, kyc_address_infoUncheckedUpdateInput>
  }

  /**
   * kyc_address_info delete
   */
  export type kyc_address_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    /**
     * Filter which kyc_address_info to delete.
     */
    where: kyc_address_infoWhereUniqueInput
  }

  /**
   * kyc_address_info deleteMany
   */
  export type kyc_address_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_address_infos to delete
     */
    where?: kyc_address_infoWhereInput
  }

  /**
   * kyc_address_info without action
   */
  export type kyc_address_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
  }


  /**
   * Model kyc_addresses
   */

  export type AggregateKyc_addresses = {
    _count: Kyc_addressesCountAggregateOutputType | null
    _avg: Kyc_addressesAvgAggregateOutputType | null
    _sum: Kyc_addressesSumAggregateOutputType | null
    _min: Kyc_addressesMinAggregateOutputType | null
    _max: Kyc_addressesMaxAggregateOutputType | null
  }

  export type Kyc_addressesAvgAggregateOutputType = {
    id: number | null
    record_id: number | null
  }

  export type Kyc_addressesSumAggregateOutputType = {
    id: number | null
    record_id: number | null
  }

  export type Kyc_addressesMinAggregateOutputType = {
    id: number | null
    record_id: number | null
    address_type: string | null
    is_primary: boolean | null
    street: string | null
    street_line_2: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_verified: boolean | null
    updated_at: Date | null
    created_at: Date | null
  }

  export type Kyc_addressesMaxAggregateOutputType = {
    id: number | null
    record_id: number | null
    address_type: string | null
    is_primary: boolean | null
    street: string | null
    street_line_2: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_verified: boolean | null
    updated_at: Date | null
    created_at: Date | null
  }

  export type Kyc_addressesCountAggregateOutputType = {
    id: number
    record_id: number
    address_type: number
    is_primary: number
    street: number
    street_line_2: number
    city: number
    state: number
    postal_code: number
    country: number
    is_verified: number
    updated_at: number
    created_at: number
    _all: number
  }


  export type Kyc_addressesAvgAggregateInputType = {
    id?: true
    record_id?: true
  }

  export type Kyc_addressesSumAggregateInputType = {
    id?: true
    record_id?: true
  }

  export type Kyc_addressesMinAggregateInputType = {
    id?: true
    record_id?: true
    address_type?: true
    is_primary?: true
    street?: true
    street_line_2?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_verified?: true
    updated_at?: true
    created_at?: true
  }

  export type Kyc_addressesMaxAggregateInputType = {
    id?: true
    record_id?: true
    address_type?: true
    is_primary?: true
    street?: true
    street_line_2?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_verified?: true
    updated_at?: true
    created_at?: true
  }

  export type Kyc_addressesCountAggregateInputType = {
    id?: true
    record_id?: true
    address_type?: true
    is_primary?: true
    street?: true
    street_line_2?: true
    city?: true
    state?: true
    postal_code?: true
    country?: true
    is_verified?: true
    updated_at?: true
    created_at?: true
    _all?: true
  }

  export type Kyc_addressesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_addresses to aggregate.
     */
    where?: kyc_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_addresses to fetch.
     */
    orderBy?: kyc_addressesOrderByWithRelationInput | kyc_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kyc_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kyc_addresses
    **/
    _count?: true | Kyc_addressesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kyc_addressesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kyc_addressesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kyc_addressesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kyc_addressesMaxAggregateInputType
  }

  export type GetKyc_addressesAggregateType<T extends Kyc_addressesAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc_addresses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc_addresses[P]>
      : GetScalarType<T[P], AggregateKyc_addresses[P]>
  }




  export type kyc_addressesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_addressesWhereInput
    orderBy?: kyc_addressesOrderByWithAggregationInput | kyc_addressesOrderByWithAggregationInput[]
    by: Kyc_addressesScalarFieldEnum[] | Kyc_addressesScalarFieldEnum
    having?: kyc_addressesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kyc_addressesCountAggregateInputType | true
    _avg?: Kyc_addressesAvgAggregateInputType
    _sum?: Kyc_addressesSumAggregateInputType
    _min?: Kyc_addressesMinAggregateInputType
    _max?: Kyc_addressesMaxAggregateInputType
  }

  export type Kyc_addressesGroupByOutputType = {
    id: number
    record_id: number
    address_type: string
    is_primary: boolean
    street: string | null
    street_line_2: string | null
    city: string | null
    state: string | null
    postal_code: string | null
    country: string | null
    is_verified: boolean
    updated_at: Date
    created_at: Date
    _count: Kyc_addressesCountAggregateOutputType | null
    _avg: Kyc_addressesAvgAggregateOutputType | null
    _sum: Kyc_addressesSumAggregateOutputType | null
    _min: Kyc_addressesMinAggregateOutputType | null
    _max: Kyc_addressesMaxAggregateOutputType | null
  }

  type GetKyc_addressesGroupByPayload<T extends kyc_addressesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kyc_addressesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kyc_addressesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kyc_addressesGroupByOutputType[P]>
            : GetScalarType<T[P], Kyc_addressesGroupByOutputType[P]>
        }
      >
    >


  export type kyc_addressesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    address_type?: boolean
    is_primary?: boolean
    street?: boolean
    street_line_2?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_verified?: boolean
    updated_at?: boolean
    created_at?: boolean
    kyc_complete_records?: boolean | kyc_complete_recordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc_addresses"]>


  export type kyc_addressesSelectScalar = {
    id?: boolean
    record_id?: boolean
    address_type?: boolean
    is_primary?: boolean
    street?: boolean
    street_line_2?: boolean
    city?: boolean
    state?: boolean
    postal_code?: boolean
    country?: boolean
    is_verified?: boolean
    updated_at?: boolean
    created_at?: boolean
  }

  export type kyc_addressesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_complete_records?: boolean | kyc_complete_recordsDefaultArgs<ExtArgs>
  }

  export type $kyc_addressesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kyc_addresses"
    objects: {
      kyc_complete_records: Prisma.$kyc_complete_recordsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      record_id: number
      address_type: string
      is_primary: boolean
      street: string | null
      street_line_2: string | null
      city: string | null
      state: string | null
      postal_code: string | null
      country: string | null
      is_verified: boolean
      updated_at: Date
      created_at: Date
    }, ExtArgs["result"]["kyc_addresses"]>
    composites: {}
  }

  type kyc_addressesGetPayload<S extends boolean | null | undefined | kyc_addressesDefaultArgs> = $Result.GetResult<Prisma.$kyc_addressesPayload, S>

  type kyc_addressesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kyc_addressesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kyc_addressesCountAggregateInputType | true
    }

  export interface kyc_addressesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kyc_addresses'], meta: { name: 'kyc_addresses' } }
    /**
     * Find zero or one Kyc_addresses that matches the filter.
     * @param {kyc_addressesFindUniqueArgs} args - Arguments to find a Kyc_addresses
     * @example
     * // Get one Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kyc_addressesFindUniqueArgs>(args: SelectSubset<T, kyc_addressesFindUniqueArgs<ExtArgs>>): Prisma__kyc_addressesClient<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kyc_addresses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kyc_addressesFindUniqueOrThrowArgs} args - Arguments to find a Kyc_addresses
     * @example
     * // Get one Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kyc_addressesFindUniqueOrThrowArgs>(args: SelectSubset<T, kyc_addressesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kyc_addressesClient<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kyc_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_addressesFindFirstArgs} args - Arguments to find a Kyc_addresses
     * @example
     * // Get one Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kyc_addressesFindFirstArgs>(args?: SelectSubset<T, kyc_addressesFindFirstArgs<ExtArgs>>): Prisma__kyc_addressesClient<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kyc_addresses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_addressesFindFirstOrThrowArgs} args - Arguments to find a Kyc_addresses
     * @example
     * // Get one Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kyc_addressesFindFirstOrThrowArgs>(args?: SelectSubset<T, kyc_addressesFindFirstOrThrowArgs<ExtArgs>>): Prisma__kyc_addressesClient<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kyc_addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_addressesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.findMany()
     * 
     * // Get first 10 Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kyc_addressesWithIdOnly = await prisma.kyc_addresses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kyc_addressesFindManyArgs>(args?: SelectSubset<T, kyc_addressesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kyc_addresses.
     * @param {kyc_addressesCreateArgs} args - Arguments to create a Kyc_addresses.
     * @example
     * // Create one Kyc_addresses
     * const Kyc_addresses = await prisma.kyc_addresses.create({
     *   data: {
     *     // ... data to create a Kyc_addresses
     *   }
     * })
     * 
     */
    create<T extends kyc_addressesCreateArgs>(args: SelectSubset<T, kyc_addressesCreateArgs<ExtArgs>>): Prisma__kyc_addressesClient<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kyc_addresses.
     * @param {kyc_addressesCreateManyArgs} args - Arguments to create many Kyc_addresses.
     * @example
     * // Create many Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kyc_addressesCreateManyArgs>(args?: SelectSubset<T, kyc_addressesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kyc_addresses.
     * @param {kyc_addressesDeleteArgs} args - Arguments to delete one Kyc_addresses.
     * @example
     * // Delete one Kyc_addresses
     * const Kyc_addresses = await prisma.kyc_addresses.delete({
     *   where: {
     *     // ... filter to delete one Kyc_addresses
     *   }
     * })
     * 
     */
    delete<T extends kyc_addressesDeleteArgs>(args: SelectSubset<T, kyc_addressesDeleteArgs<ExtArgs>>): Prisma__kyc_addressesClient<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kyc_addresses.
     * @param {kyc_addressesUpdateArgs} args - Arguments to update one Kyc_addresses.
     * @example
     * // Update one Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kyc_addressesUpdateArgs>(args: SelectSubset<T, kyc_addressesUpdateArgs<ExtArgs>>): Prisma__kyc_addressesClient<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kyc_addresses.
     * @param {kyc_addressesDeleteManyArgs} args - Arguments to filter Kyc_addresses to delete.
     * @example
     * // Delete a few Kyc_addresses
     * const { count } = await prisma.kyc_addresses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kyc_addressesDeleteManyArgs>(args?: SelectSubset<T, kyc_addressesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kyc_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_addressesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kyc_addressesUpdateManyArgs>(args: SelectSubset<T, kyc_addressesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kyc_addresses.
     * @param {kyc_addressesUpsertArgs} args - Arguments to update or create a Kyc_addresses.
     * @example
     * // Update or create a Kyc_addresses
     * const kyc_addresses = await prisma.kyc_addresses.upsert({
     *   create: {
     *     // ... data to create a Kyc_addresses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc_addresses we want to update
     *   }
     * })
     */
    upsert<T extends kyc_addressesUpsertArgs>(args: SelectSubset<T, kyc_addressesUpsertArgs<ExtArgs>>): Prisma__kyc_addressesClient<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kyc_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_addressesCountArgs} args - Arguments to filter Kyc_addresses to count.
     * @example
     * // Count the number of Kyc_addresses
     * const count = await prisma.kyc_addresses.count({
     *   where: {
     *     // ... the filter for the Kyc_addresses we want to count
     *   }
     * })
    **/
    count<T extends kyc_addressesCountArgs>(
      args?: Subset<T, kyc_addressesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kyc_addressesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kyc_addressesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kyc_addressesAggregateArgs>(args: Subset<T, Kyc_addressesAggregateArgs>): Prisma.PrismaPromise<GetKyc_addressesAggregateType<T>>

    /**
     * Group by Kyc_addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_addressesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kyc_addressesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kyc_addressesGroupByArgs['orderBy'] }
        : { orderBy?: kyc_addressesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kyc_addressesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKyc_addressesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kyc_addresses model
   */
  readonly fields: kyc_addressesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kyc_addresses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kyc_addressesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_complete_records<T extends kyc_complete_recordsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kyc_complete_recordsDefaultArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kyc_addresses model
   */ 
  interface kyc_addressesFieldRefs {
    readonly id: FieldRef<"kyc_addresses", 'Int'>
    readonly record_id: FieldRef<"kyc_addresses", 'Int'>
    readonly address_type: FieldRef<"kyc_addresses", 'String'>
    readonly is_primary: FieldRef<"kyc_addresses", 'Boolean'>
    readonly street: FieldRef<"kyc_addresses", 'String'>
    readonly street_line_2: FieldRef<"kyc_addresses", 'String'>
    readonly city: FieldRef<"kyc_addresses", 'String'>
    readonly state: FieldRef<"kyc_addresses", 'String'>
    readonly postal_code: FieldRef<"kyc_addresses", 'String'>
    readonly country: FieldRef<"kyc_addresses", 'String'>
    readonly is_verified: FieldRef<"kyc_addresses", 'Boolean'>
    readonly updated_at: FieldRef<"kyc_addresses", 'DateTime'>
    readonly created_at: FieldRef<"kyc_addresses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * kyc_addresses findUnique
   */
  export type kyc_addressesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    /**
     * Filter, which kyc_addresses to fetch.
     */
    where: kyc_addressesWhereUniqueInput
  }

  /**
   * kyc_addresses findUniqueOrThrow
   */
  export type kyc_addressesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    /**
     * Filter, which kyc_addresses to fetch.
     */
    where: kyc_addressesWhereUniqueInput
  }

  /**
   * kyc_addresses findFirst
   */
  export type kyc_addressesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    /**
     * Filter, which kyc_addresses to fetch.
     */
    where?: kyc_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_addresses to fetch.
     */
    orderBy?: kyc_addressesOrderByWithRelationInput | kyc_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_addresses.
     */
    cursor?: kyc_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_addresses.
     */
    distinct?: Kyc_addressesScalarFieldEnum | Kyc_addressesScalarFieldEnum[]
  }

  /**
   * kyc_addresses findFirstOrThrow
   */
  export type kyc_addressesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    /**
     * Filter, which kyc_addresses to fetch.
     */
    where?: kyc_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_addresses to fetch.
     */
    orderBy?: kyc_addressesOrderByWithRelationInput | kyc_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_addresses.
     */
    cursor?: kyc_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_addresses.
     */
    distinct?: Kyc_addressesScalarFieldEnum | Kyc_addressesScalarFieldEnum[]
  }

  /**
   * kyc_addresses findMany
   */
  export type kyc_addressesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    /**
     * Filter, which kyc_addresses to fetch.
     */
    where?: kyc_addressesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_addresses to fetch.
     */
    orderBy?: kyc_addressesOrderByWithRelationInput | kyc_addressesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kyc_addresses.
     */
    cursor?: kyc_addressesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_addresses.
     */
    skip?: number
    distinct?: Kyc_addressesScalarFieldEnum | Kyc_addressesScalarFieldEnum[]
  }

  /**
   * kyc_addresses create
   */
  export type kyc_addressesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    /**
     * The data needed to create a kyc_addresses.
     */
    data: XOR<kyc_addressesCreateInput, kyc_addressesUncheckedCreateInput>
  }

  /**
   * kyc_addresses createMany
   */
  export type kyc_addressesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kyc_addresses.
     */
    data: kyc_addressesCreateManyInput | kyc_addressesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kyc_addresses update
   */
  export type kyc_addressesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    /**
     * The data needed to update a kyc_addresses.
     */
    data: XOR<kyc_addressesUpdateInput, kyc_addressesUncheckedUpdateInput>
    /**
     * Choose, which kyc_addresses to update.
     */
    where: kyc_addressesWhereUniqueInput
  }

  /**
   * kyc_addresses updateMany
   */
  export type kyc_addressesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kyc_addresses.
     */
    data: XOR<kyc_addressesUpdateManyMutationInput, kyc_addressesUncheckedUpdateManyInput>
    /**
     * Filter which kyc_addresses to update
     */
    where?: kyc_addressesWhereInput
  }

  /**
   * kyc_addresses upsert
   */
  export type kyc_addressesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    /**
     * The filter to search for the kyc_addresses to update in case it exists.
     */
    where: kyc_addressesWhereUniqueInput
    /**
     * In case the kyc_addresses found by the `where` argument doesn't exist, create a new kyc_addresses with this data.
     */
    create: XOR<kyc_addressesCreateInput, kyc_addressesUncheckedCreateInput>
    /**
     * In case the kyc_addresses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kyc_addressesUpdateInput, kyc_addressesUncheckedUpdateInput>
  }

  /**
   * kyc_addresses delete
   */
  export type kyc_addressesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    /**
     * Filter which kyc_addresses to delete.
     */
    where: kyc_addressesWhereUniqueInput
  }

  /**
   * kyc_addresses deleteMany
   */
  export type kyc_addressesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_addresses to delete
     */
    where?: kyc_addressesWhereInput
  }

  /**
   * kyc_addresses without action
   */
  export type kyc_addressesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
  }


  /**
   * Model kyc_applicants
   */

  export type AggregateKyc_applicants = {
    _count: Kyc_applicantsCountAggregateOutputType | null
    _avg: Kyc_applicantsAvgAggregateOutputType | null
    _sum: Kyc_applicantsSumAggregateOutputType | null
    _min: Kyc_applicantsMinAggregateOutputType | null
    _max: Kyc_applicantsMaxAggregateOutputType | null
  }

  export type Kyc_applicantsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    personal_info_id: number | null
  }

  export type Kyc_applicantsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    personal_info_id: number | null
  }

  export type Kyc_applicantsMinAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    user_id: number | null
    external_user_id: string | null
    inspection_id: string | null
    correlation_id: string | null
    status: string | null
    result: string | null
    id_doc_status: string | null
    created_at: Date | null
    updated_at: Date | null
    sandbox_mode: boolean | null
    personal_info_id: number | null
  }

  export type Kyc_applicantsMaxAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    user_id: number | null
    external_user_id: string | null
    inspection_id: string | null
    correlation_id: string | null
    status: string | null
    result: string | null
    id_doc_status: string | null
    created_at: Date | null
    updated_at: Date | null
    sandbox_mode: boolean | null
    personal_info_id: number | null
  }

  export type Kyc_applicantsCountAggregateOutputType = {
    id: number
    applicant_id: number
    user_id: number
    external_user_id: number
    inspection_id: number
    correlation_id: number
    status: number
    result: number
    id_doc_status: number
    created_at: number
    updated_at: number
    sandbox_mode: number
    personal_info_id: number
    _all: number
  }


  export type Kyc_applicantsAvgAggregateInputType = {
    id?: true
    user_id?: true
    personal_info_id?: true
  }

  export type Kyc_applicantsSumAggregateInputType = {
    id?: true
    user_id?: true
    personal_info_id?: true
  }

  export type Kyc_applicantsMinAggregateInputType = {
    id?: true
    applicant_id?: true
    user_id?: true
    external_user_id?: true
    inspection_id?: true
    correlation_id?: true
    status?: true
    result?: true
    id_doc_status?: true
    created_at?: true
    updated_at?: true
    sandbox_mode?: true
    personal_info_id?: true
  }

  export type Kyc_applicantsMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    user_id?: true
    external_user_id?: true
    inspection_id?: true
    correlation_id?: true
    status?: true
    result?: true
    id_doc_status?: true
    created_at?: true
    updated_at?: true
    sandbox_mode?: true
    personal_info_id?: true
  }

  export type Kyc_applicantsCountAggregateInputType = {
    id?: true
    applicant_id?: true
    user_id?: true
    external_user_id?: true
    inspection_id?: true
    correlation_id?: true
    status?: true
    result?: true
    id_doc_status?: true
    created_at?: true
    updated_at?: true
    sandbox_mode?: true
    personal_info_id?: true
    _all?: true
  }

  export type Kyc_applicantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_applicants to aggregate.
     */
    where?: kyc_applicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_applicants to fetch.
     */
    orderBy?: kyc_applicantsOrderByWithRelationInput | kyc_applicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kyc_applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kyc_applicants
    **/
    _count?: true | Kyc_applicantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kyc_applicantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kyc_applicantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kyc_applicantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kyc_applicantsMaxAggregateInputType
  }

  export type GetKyc_applicantsAggregateType<T extends Kyc_applicantsAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc_applicants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc_applicants[P]>
      : GetScalarType<T[P], AggregateKyc_applicants[P]>
  }




  export type kyc_applicantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_applicantsWhereInput
    orderBy?: kyc_applicantsOrderByWithAggregationInput | kyc_applicantsOrderByWithAggregationInput[]
    by: Kyc_applicantsScalarFieldEnum[] | Kyc_applicantsScalarFieldEnum
    having?: kyc_applicantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kyc_applicantsCountAggregateInputType | true
    _avg?: Kyc_applicantsAvgAggregateInputType
    _sum?: Kyc_applicantsSumAggregateInputType
    _min?: Kyc_applicantsMinAggregateInputType
    _max?: Kyc_applicantsMaxAggregateInputType
  }

  export type Kyc_applicantsGroupByOutputType = {
    id: number
    applicant_id: string
    user_id: number | null
    external_user_id: string | null
    inspection_id: string | null
    correlation_id: string | null
    status: string
    result: string | null
    id_doc_status: string | null
    created_at: Date
    updated_at: Date
    sandbox_mode: boolean
    personal_info_id: number | null
    _count: Kyc_applicantsCountAggregateOutputType | null
    _avg: Kyc_applicantsAvgAggregateOutputType | null
    _sum: Kyc_applicantsSumAggregateOutputType | null
    _min: Kyc_applicantsMinAggregateOutputType | null
    _max: Kyc_applicantsMaxAggregateOutputType | null
  }

  type GetKyc_applicantsGroupByPayload<T extends kyc_applicantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kyc_applicantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kyc_applicantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kyc_applicantsGroupByOutputType[P]>
            : GetScalarType<T[P], Kyc_applicantsGroupByOutputType[P]>
        }
      >
    >


  export type kyc_applicantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicant_id?: boolean
    user_id?: boolean
    external_user_id?: boolean
    inspection_id?: boolean
    correlation_id?: boolean
    status?: boolean
    result?: boolean
    id_doc_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    sandbox_mode?: boolean
    personal_info_id?: boolean
    kyc_address_info?: boolean | kyc_applicants$kyc_address_infoArgs<ExtArgs>
    kyc_personal_info?: boolean | kyc_applicants$kyc_personal_infoArgs<ExtArgs>
    users?: boolean | kyc_applicants$usersArgs<ExtArgs>
    kyc_audit_log?: boolean | kyc_applicants$kyc_audit_logArgs<ExtArgs>
    kyc_raw_data?: boolean | kyc_applicants$kyc_raw_dataArgs<ExtArgs>
    kyc_verification_history?: boolean | kyc_applicants$kyc_verification_historyArgs<ExtArgs>
    _count?: boolean | Kyc_applicantsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc_applicants"]>


  export type kyc_applicantsSelectScalar = {
    id?: boolean
    applicant_id?: boolean
    user_id?: boolean
    external_user_id?: boolean
    inspection_id?: boolean
    correlation_id?: boolean
    status?: boolean
    result?: boolean
    id_doc_status?: boolean
    created_at?: boolean
    updated_at?: boolean
    sandbox_mode?: boolean
    personal_info_id?: boolean
  }

  export type kyc_applicantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_address_info?: boolean | kyc_applicants$kyc_address_infoArgs<ExtArgs>
    kyc_personal_info?: boolean | kyc_applicants$kyc_personal_infoArgs<ExtArgs>
    users?: boolean | kyc_applicants$usersArgs<ExtArgs>
    kyc_audit_log?: boolean | kyc_applicants$kyc_audit_logArgs<ExtArgs>
    kyc_raw_data?: boolean | kyc_applicants$kyc_raw_dataArgs<ExtArgs>
    kyc_verification_history?: boolean | kyc_applicants$kyc_verification_historyArgs<ExtArgs>
    _count?: boolean | Kyc_applicantsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $kyc_applicantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kyc_applicants"
    objects: {
      kyc_address_info: Prisma.$kyc_address_infoPayload<ExtArgs>[]
      kyc_personal_info: Prisma.$kyc_personal_infoPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
      kyc_audit_log: Prisma.$kyc_audit_logPayload<ExtArgs>[]
      kyc_raw_data: Prisma.$kyc_raw_dataPayload<ExtArgs>[]
      kyc_verification_history: Prisma.$kyc_verification_historyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicant_id: string
      user_id: number | null
      external_user_id: string | null
      inspection_id: string | null
      correlation_id: string | null
      status: string
      result: string | null
      id_doc_status: string | null
      created_at: Date
      updated_at: Date
      sandbox_mode: boolean
      personal_info_id: number | null
    }, ExtArgs["result"]["kyc_applicants"]>
    composites: {}
  }

  type kyc_applicantsGetPayload<S extends boolean | null | undefined | kyc_applicantsDefaultArgs> = $Result.GetResult<Prisma.$kyc_applicantsPayload, S>

  type kyc_applicantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kyc_applicantsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kyc_applicantsCountAggregateInputType | true
    }

  export interface kyc_applicantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kyc_applicants'], meta: { name: 'kyc_applicants' } }
    /**
     * Find zero or one Kyc_applicants that matches the filter.
     * @param {kyc_applicantsFindUniqueArgs} args - Arguments to find a Kyc_applicants
     * @example
     * // Get one Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kyc_applicantsFindUniqueArgs>(args: SelectSubset<T, kyc_applicantsFindUniqueArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kyc_applicants that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kyc_applicantsFindUniqueOrThrowArgs} args - Arguments to find a Kyc_applicants
     * @example
     * // Get one Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kyc_applicantsFindUniqueOrThrowArgs>(args: SelectSubset<T, kyc_applicantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kyc_applicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_applicantsFindFirstArgs} args - Arguments to find a Kyc_applicants
     * @example
     * // Get one Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kyc_applicantsFindFirstArgs>(args?: SelectSubset<T, kyc_applicantsFindFirstArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kyc_applicants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_applicantsFindFirstOrThrowArgs} args - Arguments to find a Kyc_applicants
     * @example
     * // Get one Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kyc_applicantsFindFirstOrThrowArgs>(args?: SelectSubset<T, kyc_applicantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kyc_applicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_applicantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.findMany()
     * 
     * // Get first 10 Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kyc_applicantsWithIdOnly = await prisma.kyc_applicants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kyc_applicantsFindManyArgs>(args?: SelectSubset<T, kyc_applicantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kyc_applicants.
     * @param {kyc_applicantsCreateArgs} args - Arguments to create a Kyc_applicants.
     * @example
     * // Create one Kyc_applicants
     * const Kyc_applicants = await prisma.kyc_applicants.create({
     *   data: {
     *     // ... data to create a Kyc_applicants
     *   }
     * })
     * 
     */
    create<T extends kyc_applicantsCreateArgs>(args: SelectSubset<T, kyc_applicantsCreateArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kyc_applicants.
     * @param {kyc_applicantsCreateManyArgs} args - Arguments to create many Kyc_applicants.
     * @example
     * // Create many Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kyc_applicantsCreateManyArgs>(args?: SelectSubset<T, kyc_applicantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kyc_applicants.
     * @param {kyc_applicantsDeleteArgs} args - Arguments to delete one Kyc_applicants.
     * @example
     * // Delete one Kyc_applicants
     * const Kyc_applicants = await prisma.kyc_applicants.delete({
     *   where: {
     *     // ... filter to delete one Kyc_applicants
     *   }
     * })
     * 
     */
    delete<T extends kyc_applicantsDeleteArgs>(args: SelectSubset<T, kyc_applicantsDeleteArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kyc_applicants.
     * @param {kyc_applicantsUpdateArgs} args - Arguments to update one Kyc_applicants.
     * @example
     * // Update one Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kyc_applicantsUpdateArgs>(args: SelectSubset<T, kyc_applicantsUpdateArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kyc_applicants.
     * @param {kyc_applicantsDeleteManyArgs} args - Arguments to filter Kyc_applicants to delete.
     * @example
     * // Delete a few Kyc_applicants
     * const { count } = await prisma.kyc_applicants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kyc_applicantsDeleteManyArgs>(args?: SelectSubset<T, kyc_applicantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kyc_applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_applicantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kyc_applicantsUpdateManyArgs>(args: SelectSubset<T, kyc_applicantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kyc_applicants.
     * @param {kyc_applicantsUpsertArgs} args - Arguments to update or create a Kyc_applicants.
     * @example
     * // Update or create a Kyc_applicants
     * const kyc_applicants = await prisma.kyc_applicants.upsert({
     *   create: {
     *     // ... data to create a Kyc_applicants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc_applicants we want to update
     *   }
     * })
     */
    upsert<T extends kyc_applicantsUpsertArgs>(args: SelectSubset<T, kyc_applicantsUpsertArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kyc_applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_applicantsCountArgs} args - Arguments to filter Kyc_applicants to count.
     * @example
     * // Count the number of Kyc_applicants
     * const count = await prisma.kyc_applicants.count({
     *   where: {
     *     // ... the filter for the Kyc_applicants we want to count
     *   }
     * })
    **/
    count<T extends kyc_applicantsCountArgs>(
      args?: Subset<T, kyc_applicantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kyc_applicantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc_applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kyc_applicantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kyc_applicantsAggregateArgs>(args: Subset<T, Kyc_applicantsAggregateArgs>): Prisma.PrismaPromise<GetKyc_applicantsAggregateType<T>>

    /**
     * Group by Kyc_applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_applicantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kyc_applicantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kyc_applicantsGroupByArgs['orderBy'] }
        : { orderBy?: kyc_applicantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kyc_applicantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKyc_applicantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kyc_applicants model
   */
  readonly fields: kyc_applicantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kyc_applicants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kyc_applicantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_address_info<T extends kyc_applicants$kyc_address_infoArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicants$kyc_address_infoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_address_infoPayload<ExtArgs>, T, "findMany"> | Null>
    kyc_personal_info<T extends kyc_applicants$kyc_personal_infoArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicants$kyc_personal_infoArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    users<T extends kyc_applicants$usersArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicants$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    kyc_audit_log<T extends kyc_applicants$kyc_audit_logArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicants$kyc_audit_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "findMany"> | Null>
    kyc_raw_data<T extends kyc_applicants$kyc_raw_dataArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicants$kyc_raw_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "findMany"> | Null>
    kyc_verification_history<T extends kyc_applicants$kyc_verification_historyArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicants$kyc_verification_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kyc_applicants model
   */ 
  interface kyc_applicantsFieldRefs {
    readonly id: FieldRef<"kyc_applicants", 'Int'>
    readonly applicant_id: FieldRef<"kyc_applicants", 'String'>
    readonly user_id: FieldRef<"kyc_applicants", 'Int'>
    readonly external_user_id: FieldRef<"kyc_applicants", 'String'>
    readonly inspection_id: FieldRef<"kyc_applicants", 'String'>
    readonly correlation_id: FieldRef<"kyc_applicants", 'String'>
    readonly status: FieldRef<"kyc_applicants", 'String'>
    readonly result: FieldRef<"kyc_applicants", 'String'>
    readonly id_doc_status: FieldRef<"kyc_applicants", 'String'>
    readonly created_at: FieldRef<"kyc_applicants", 'DateTime'>
    readonly updated_at: FieldRef<"kyc_applicants", 'DateTime'>
    readonly sandbox_mode: FieldRef<"kyc_applicants", 'Boolean'>
    readonly personal_info_id: FieldRef<"kyc_applicants", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * kyc_applicants findUnique
   */
  export type kyc_applicantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_applicants to fetch.
     */
    where: kyc_applicantsWhereUniqueInput
  }

  /**
   * kyc_applicants findUniqueOrThrow
   */
  export type kyc_applicantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_applicants to fetch.
     */
    where: kyc_applicantsWhereUniqueInput
  }

  /**
   * kyc_applicants findFirst
   */
  export type kyc_applicantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_applicants to fetch.
     */
    where?: kyc_applicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_applicants to fetch.
     */
    orderBy?: kyc_applicantsOrderByWithRelationInput | kyc_applicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_applicants.
     */
    cursor?: kyc_applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_applicants.
     */
    distinct?: Kyc_applicantsScalarFieldEnum | Kyc_applicantsScalarFieldEnum[]
  }

  /**
   * kyc_applicants findFirstOrThrow
   */
  export type kyc_applicantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_applicants to fetch.
     */
    where?: kyc_applicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_applicants to fetch.
     */
    orderBy?: kyc_applicantsOrderByWithRelationInput | kyc_applicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_applicants.
     */
    cursor?: kyc_applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_applicants.
     */
    distinct?: Kyc_applicantsScalarFieldEnum | Kyc_applicantsScalarFieldEnum[]
  }

  /**
   * kyc_applicants findMany
   */
  export type kyc_applicantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_applicants to fetch.
     */
    where?: kyc_applicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_applicants to fetch.
     */
    orderBy?: kyc_applicantsOrderByWithRelationInput | kyc_applicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kyc_applicants.
     */
    cursor?: kyc_applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_applicants.
     */
    skip?: number
    distinct?: Kyc_applicantsScalarFieldEnum | Kyc_applicantsScalarFieldEnum[]
  }

  /**
   * kyc_applicants create
   */
  export type kyc_applicantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    /**
     * The data needed to create a kyc_applicants.
     */
    data: XOR<kyc_applicantsCreateInput, kyc_applicantsUncheckedCreateInput>
  }

  /**
   * kyc_applicants createMany
   */
  export type kyc_applicantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kyc_applicants.
     */
    data: kyc_applicantsCreateManyInput | kyc_applicantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kyc_applicants update
   */
  export type kyc_applicantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    /**
     * The data needed to update a kyc_applicants.
     */
    data: XOR<kyc_applicantsUpdateInput, kyc_applicantsUncheckedUpdateInput>
    /**
     * Choose, which kyc_applicants to update.
     */
    where: kyc_applicantsWhereUniqueInput
  }

  /**
   * kyc_applicants updateMany
   */
  export type kyc_applicantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kyc_applicants.
     */
    data: XOR<kyc_applicantsUpdateManyMutationInput, kyc_applicantsUncheckedUpdateManyInput>
    /**
     * Filter which kyc_applicants to update
     */
    where?: kyc_applicantsWhereInput
  }

  /**
   * kyc_applicants upsert
   */
  export type kyc_applicantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    /**
     * The filter to search for the kyc_applicants to update in case it exists.
     */
    where: kyc_applicantsWhereUniqueInput
    /**
     * In case the kyc_applicants found by the `where` argument doesn't exist, create a new kyc_applicants with this data.
     */
    create: XOR<kyc_applicantsCreateInput, kyc_applicantsUncheckedCreateInput>
    /**
     * In case the kyc_applicants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kyc_applicantsUpdateInput, kyc_applicantsUncheckedUpdateInput>
  }

  /**
   * kyc_applicants delete
   */
  export type kyc_applicantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    /**
     * Filter which kyc_applicants to delete.
     */
    where: kyc_applicantsWhereUniqueInput
  }

  /**
   * kyc_applicants deleteMany
   */
  export type kyc_applicantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_applicants to delete
     */
    where?: kyc_applicantsWhereInput
  }

  /**
   * kyc_applicants.kyc_address_info
   */
  export type kyc_applicants$kyc_address_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_address_info
     */
    select?: kyc_address_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_address_infoInclude<ExtArgs> | null
    where?: kyc_address_infoWhereInput
    orderBy?: kyc_address_infoOrderByWithRelationInput | kyc_address_infoOrderByWithRelationInput[]
    cursor?: kyc_address_infoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kyc_address_infoScalarFieldEnum | Kyc_address_infoScalarFieldEnum[]
  }

  /**
   * kyc_applicants.kyc_personal_info
   */
  export type kyc_applicants$kyc_personal_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    where?: kyc_personal_infoWhereInput
  }

  /**
   * kyc_applicants.users
   */
  export type kyc_applicants$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * kyc_applicants.kyc_audit_log
   */
  export type kyc_applicants$kyc_audit_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    where?: kyc_audit_logWhereInput
    orderBy?: kyc_audit_logOrderByWithRelationInput | kyc_audit_logOrderByWithRelationInput[]
    cursor?: kyc_audit_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kyc_audit_logScalarFieldEnum | Kyc_audit_logScalarFieldEnum[]
  }

  /**
   * kyc_applicants.kyc_raw_data
   */
  export type kyc_applicants$kyc_raw_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    where?: kyc_raw_dataWhereInput
    orderBy?: kyc_raw_dataOrderByWithRelationInput | kyc_raw_dataOrderByWithRelationInput[]
    cursor?: kyc_raw_dataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kyc_raw_dataScalarFieldEnum | Kyc_raw_dataScalarFieldEnum[]
  }

  /**
   * kyc_applicants.kyc_verification_history
   */
  export type kyc_applicants$kyc_verification_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    where?: kyc_verification_historyWhereInput
    orderBy?: kyc_verification_historyOrderByWithRelationInput | kyc_verification_historyOrderByWithRelationInput[]
    cursor?: kyc_verification_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kyc_verification_historyScalarFieldEnum | Kyc_verification_historyScalarFieldEnum[]
  }

  /**
   * kyc_applicants without action
   */
  export type kyc_applicantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
  }


  /**
   * Model kyc_audit_log
   */

  export type AggregateKyc_audit_log = {
    _count: Kyc_audit_logCountAggregateOutputType | null
    _avg: Kyc_audit_logAvgAggregateOutputType | null
    _sum: Kyc_audit_logSumAggregateOutputType | null
    _min: Kyc_audit_logMinAggregateOutputType | null
    _max: Kyc_audit_logMaxAggregateOutputType | null
  }

  export type Kyc_audit_logAvgAggregateOutputType = {
    id: number | null
  }

  export type Kyc_audit_logSumAggregateOutputType = {
    id: number | null
  }

  export type Kyc_audit_logMinAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    action: string | null
    performed_by: string | null
    details: string | null
    timestamp: Date | null
  }

  export type Kyc_audit_logMaxAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    action: string | null
    performed_by: string | null
    details: string | null
    timestamp: Date | null
  }

  export type Kyc_audit_logCountAggregateOutputType = {
    id: number
    applicant_id: number
    action: number
    performed_by: number
    details: number
    timestamp: number
    _all: number
  }


  export type Kyc_audit_logAvgAggregateInputType = {
    id?: true
  }

  export type Kyc_audit_logSumAggregateInputType = {
    id?: true
  }

  export type Kyc_audit_logMinAggregateInputType = {
    id?: true
    applicant_id?: true
    action?: true
    performed_by?: true
    details?: true
    timestamp?: true
  }

  export type Kyc_audit_logMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    action?: true
    performed_by?: true
    details?: true
    timestamp?: true
  }

  export type Kyc_audit_logCountAggregateInputType = {
    id?: true
    applicant_id?: true
    action?: true
    performed_by?: true
    details?: true
    timestamp?: true
    _all?: true
  }

  export type Kyc_audit_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_audit_log to aggregate.
     */
    where?: kyc_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_audit_logs to fetch.
     */
    orderBy?: kyc_audit_logOrderByWithRelationInput | kyc_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kyc_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kyc_audit_logs
    **/
    _count?: true | Kyc_audit_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kyc_audit_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kyc_audit_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kyc_audit_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kyc_audit_logMaxAggregateInputType
  }

  export type GetKyc_audit_logAggregateType<T extends Kyc_audit_logAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc_audit_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc_audit_log[P]>
      : GetScalarType<T[P], AggregateKyc_audit_log[P]>
  }




  export type kyc_audit_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_audit_logWhereInput
    orderBy?: kyc_audit_logOrderByWithAggregationInput | kyc_audit_logOrderByWithAggregationInput[]
    by: Kyc_audit_logScalarFieldEnum[] | Kyc_audit_logScalarFieldEnum
    having?: kyc_audit_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kyc_audit_logCountAggregateInputType | true
    _avg?: Kyc_audit_logAvgAggregateInputType
    _sum?: Kyc_audit_logSumAggregateInputType
    _min?: Kyc_audit_logMinAggregateInputType
    _max?: Kyc_audit_logMaxAggregateInputType
  }

  export type Kyc_audit_logGroupByOutputType = {
    id: number
    applicant_id: string
    action: string
    performed_by: string | null
    details: string | null
    timestamp: Date
    _count: Kyc_audit_logCountAggregateOutputType | null
    _avg: Kyc_audit_logAvgAggregateOutputType | null
    _sum: Kyc_audit_logSumAggregateOutputType | null
    _min: Kyc_audit_logMinAggregateOutputType | null
    _max: Kyc_audit_logMaxAggregateOutputType | null
  }

  type GetKyc_audit_logGroupByPayload<T extends kyc_audit_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kyc_audit_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kyc_audit_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kyc_audit_logGroupByOutputType[P]>
            : GetScalarType<T[P], Kyc_audit_logGroupByOutputType[P]>
        }
      >
    >


  export type kyc_audit_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicant_id?: boolean
    action?: boolean
    performed_by?: boolean
    details?: boolean
    timestamp?: boolean
    kyc_applicants?: boolean | kyc_applicantsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc_audit_log"]>


  export type kyc_audit_logSelectScalar = {
    id?: boolean
    applicant_id?: boolean
    action?: boolean
    performed_by?: boolean
    details?: boolean
    timestamp?: boolean
  }

  export type kyc_audit_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_applicants?: boolean | kyc_applicantsDefaultArgs<ExtArgs>
  }

  export type $kyc_audit_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kyc_audit_log"
    objects: {
      kyc_applicants: Prisma.$kyc_applicantsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicant_id: string
      action: string
      performed_by: string | null
      details: string | null
      timestamp: Date
    }, ExtArgs["result"]["kyc_audit_log"]>
    composites: {}
  }

  type kyc_audit_logGetPayload<S extends boolean | null | undefined | kyc_audit_logDefaultArgs> = $Result.GetResult<Prisma.$kyc_audit_logPayload, S>

  type kyc_audit_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kyc_audit_logFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kyc_audit_logCountAggregateInputType | true
    }

  export interface kyc_audit_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kyc_audit_log'], meta: { name: 'kyc_audit_log' } }
    /**
     * Find zero or one Kyc_audit_log that matches the filter.
     * @param {kyc_audit_logFindUniqueArgs} args - Arguments to find a Kyc_audit_log
     * @example
     * // Get one Kyc_audit_log
     * const kyc_audit_log = await prisma.kyc_audit_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kyc_audit_logFindUniqueArgs>(args: SelectSubset<T, kyc_audit_logFindUniqueArgs<ExtArgs>>): Prisma__kyc_audit_logClient<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kyc_audit_log that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kyc_audit_logFindUniqueOrThrowArgs} args - Arguments to find a Kyc_audit_log
     * @example
     * // Get one Kyc_audit_log
     * const kyc_audit_log = await prisma.kyc_audit_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kyc_audit_logFindUniqueOrThrowArgs>(args: SelectSubset<T, kyc_audit_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kyc_audit_logClient<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kyc_audit_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_audit_logFindFirstArgs} args - Arguments to find a Kyc_audit_log
     * @example
     * // Get one Kyc_audit_log
     * const kyc_audit_log = await prisma.kyc_audit_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kyc_audit_logFindFirstArgs>(args?: SelectSubset<T, kyc_audit_logFindFirstArgs<ExtArgs>>): Prisma__kyc_audit_logClient<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kyc_audit_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_audit_logFindFirstOrThrowArgs} args - Arguments to find a Kyc_audit_log
     * @example
     * // Get one Kyc_audit_log
     * const kyc_audit_log = await prisma.kyc_audit_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kyc_audit_logFindFirstOrThrowArgs>(args?: SelectSubset<T, kyc_audit_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__kyc_audit_logClient<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kyc_audit_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_audit_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kyc_audit_logs
     * const kyc_audit_logs = await prisma.kyc_audit_log.findMany()
     * 
     * // Get first 10 Kyc_audit_logs
     * const kyc_audit_logs = await prisma.kyc_audit_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kyc_audit_logWithIdOnly = await prisma.kyc_audit_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kyc_audit_logFindManyArgs>(args?: SelectSubset<T, kyc_audit_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kyc_audit_log.
     * @param {kyc_audit_logCreateArgs} args - Arguments to create a Kyc_audit_log.
     * @example
     * // Create one Kyc_audit_log
     * const Kyc_audit_log = await prisma.kyc_audit_log.create({
     *   data: {
     *     // ... data to create a Kyc_audit_log
     *   }
     * })
     * 
     */
    create<T extends kyc_audit_logCreateArgs>(args: SelectSubset<T, kyc_audit_logCreateArgs<ExtArgs>>): Prisma__kyc_audit_logClient<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kyc_audit_logs.
     * @param {kyc_audit_logCreateManyArgs} args - Arguments to create many Kyc_audit_logs.
     * @example
     * // Create many Kyc_audit_logs
     * const kyc_audit_log = await prisma.kyc_audit_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kyc_audit_logCreateManyArgs>(args?: SelectSubset<T, kyc_audit_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kyc_audit_log.
     * @param {kyc_audit_logDeleteArgs} args - Arguments to delete one Kyc_audit_log.
     * @example
     * // Delete one Kyc_audit_log
     * const Kyc_audit_log = await prisma.kyc_audit_log.delete({
     *   where: {
     *     // ... filter to delete one Kyc_audit_log
     *   }
     * })
     * 
     */
    delete<T extends kyc_audit_logDeleteArgs>(args: SelectSubset<T, kyc_audit_logDeleteArgs<ExtArgs>>): Prisma__kyc_audit_logClient<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kyc_audit_log.
     * @param {kyc_audit_logUpdateArgs} args - Arguments to update one Kyc_audit_log.
     * @example
     * // Update one Kyc_audit_log
     * const kyc_audit_log = await prisma.kyc_audit_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kyc_audit_logUpdateArgs>(args: SelectSubset<T, kyc_audit_logUpdateArgs<ExtArgs>>): Prisma__kyc_audit_logClient<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kyc_audit_logs.
     * @param {kyc_audit_logDeleteManyArgs} args - Arguments to filter Kyc_audit_logs to delete.
     * @example
     * // Delete a few Kyc_audit_logs
     * const { count } = await prisma.kyc_audit_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kyc_audit_logDeleteManyArgs>(args?: SelectSubset<T, kyc_audit_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kyc_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_audit_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kyc_audit_logs
     * const kyc_audit_log = await prisma.kyc_audit_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kyc_audit_logUpdateManyArgs>(args: SelectSubset<T, kyc_audit_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kyc_audit_log.
     * @param {kyc_audit_logUpsertArgs} args - Arguments to update or create a Kyc_audit_log.
     * @example
     * // Update or create a Kyc_audit_log
     * const kyc_audit_log = await prisma.kyc_audit_log.upsert({
     *   create: {
     *     // ... data to create a Kyc_audit_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc_audit_log we want to update
     *   }
     * })
     */
    upsert<T extends kyc_audit_logUpsertArgs>(args: SelectSubset<T, kyc_audit_logUpsertArgs<ExtArgs>>): Prisma__kyc_audit_logClient<$Result.GetResult<Prisma.$kyc_audit_logPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kyc_audit_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_audit_logCountArgs} args - Arguments to filter Kyc_audit_logs to count.
     * @example
     * // Count the number of Kyc_audit_logs
     * const count = await prisma.kyc_audit_log.count({
     *   where: {
     *     // ... the filter for the Kyc_audit_logs we want to count
     *   }
     * })
    **/
    count<T extends kyc_audit_logCountArgs>(
      args?: Subset<T, kyc_audit_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kyc_audit_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc_audit_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kyc_audit_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kyc_audit_logAggregateArgs>(args: Subset<T, Kyc_audit_logAggregateArgs>): Prisma.PrismaPromise<GetKyc_audit_logAggregateType<T>>

    /**
     * Group by Kyc_audit_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_audit_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kyc_audit_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kyc_audit_logGroupByArgs['orderBy'] }
        : { orderBy?: kyc_audit_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kyc_audit_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKyc_audit_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kyc_audit_log model
   */
  readonly fields: kyc_audit_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kyc_audit_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kyc_audit_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_applicants<T extends kyc_applicantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicantsDefaultArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kyc_audit_log model
   */ 
  interface kyc_audit_logFieldRefs {
    readonly id: FieldRef<"kyc_audit_log", 'Int'>
    readonly applicant_id: FieldRef<"kyc_audit_log", 'String'>
    readonly action: FieldRef<"kyc_audit_log", 'String'>
    readonly performed_by: FieldRef<"kyc_audit_log", 'String'>
    readonly details: FieldRef<"kyc_audit_log", 'String'>
    readonly timestamp: FieldRef<"kyc_audit_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * kyc_audit_log findUnique
   */
  export type kyc_audit_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which kyc_audit_log to fetch.
     */
    where: kyc_audit_logWhereUniqueInput
  }

  /**
   * kyc_audit_log findUniqueOrThrow
   */
  export type kyc_audit_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which kyc_audit_log to fetch.
     */
    where: kyc_audit_logWhereUniqueInput
  }

  /**
   * kyc_audit_log findFirst
   */
  export type kyc_audit_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which kyc_audit_log to fetch.
     */
    where?: kyc_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_audit_logs to fetch.
     */
    orderBy?: kyc_audit_logOrderByWithRelationInput | kyc_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_audit_logs.
     */
    cursor?: kyc_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_audit_logs.
     */
    distinct?: Kyc_audit_logScalarFieldEnum | Kyc_audit_logScalarFieldEnum[]
  }

  /**
   * kyc_audit_log findFirstOrThrow
   */
  export type kyc_audit_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which kyc_audit_log to fetch.
     */
    where?: kyc_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_audit_logs to fetch.
     */
    orderBy?: kyc_audit_logOrderByWithRelationInput | kyc_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_audit_logs.
     */
    cursor?: kyc_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_audit_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_audit_logs.
     */
    distinct?: Kyc_audit_logScalarFieldEnum | Kyc_audit_logScalarFieldEnum[]
  }

  /**
   * kyc_audit_log findMany
   */
  export type kyc_audit_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    /**
     * Filter, which kyc_audit_logs to fetch.
     */
    where?: kyc_audit_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_audit_logs to fetch.
     */
    orderBy?: kyc_audit_logOrderByWithRelationInput | kyc_audit_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kyc_audit_logs.
     */
    cursor?: kyc_audit_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_audit_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_audit_logs.
     */
    skip?: number
    distinct?: Kyc_audit_logScalarFieldEnum | Kyc_audit_logScalarFieldEnum[]
  }

  /**
   * kyc_audit_log create
   */
  export type kyc_audit_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    /**
     * The data needed to create a kyc_audit_log.
     */
    data: XOR<kyc_audit_logCreateInput, kyc_audit_logUncheckedCreateInput>
  }

  /**
   * kyc_audit_log createMany
   */
  export type kyc_audit_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kyc_audit_logs.
     */
    data: kyc_audit_logCreateManyInput | kyc_audit_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kyc_audit_log update
   */
  export type kyc_audit_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    /**
     * The data needed to update a kyc_audit_log.
     */
    data: XOR<kyc_audit_logUpdateInput, kyc_audit_logUncheckedUpdateInput>
    /**
     * Choose, which kyc_audit_log to update.
     */
    where: kyc_audit_logWhereUniqueInput
  }

  /**
   * kyc_audit_log updateMany
   */
  export type kyc_audit_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kyc_audit_logs.
     */
    data: XOR<kyc_audit_logUpdateManyMutationInput, kyc_audit_logUncheckedUpdateManyInput>
    /**
     * Filter which kyc_audit_logs to update
     */
    where?: kyc_audit_logWhereInput
  }

  /**
   * kyc_audit_log upsert
   */
  export type kyc_audit_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    /**
     * The filter to search for the kyc_audit_log to update in case it exists.
     */
    where: kyc_audit_logWhereUniqueInput
    /**
     * In case the kyc_audit_log found by the `where` argument doesn't exist, create a new kyc_audit_log with this data.
     */
    create: XOR<kyc_audit_logCreateInput, kyc_audit_logUncheckedCreateInput>
    /**
     * In case the kyc_audit_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kyc_audit_logUpdateInput, kyc_audit_logUncheckedUpdateInput>
  }

  /**
   * kyc_audit_log delete
   */
  export type kyc_audit_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
    /**
     * Filter which kyc_audit_log to delete.
     */
    where: kyc_audit_logWhereUniqueInput
  }

  /**
   * kyc_audit_log deleteMany
   */
  export type kyc_audit_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_audit_logs to delete
     */
    where?: kyc_audit_logWhereInput
  }

  /**
   * kyc_audit_log without action
   */
  export type kyc_audit_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_audit_log
     */
    select?: kyc_audit_logSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_audit_logInclude<ExtArgs> | null
  }


  /**
   * Model kyc_complete_records
   */

  export type AggregateKyc_complete_records = {
    _count: Kyc_complete_recordsCountAggregateOutputType | null
    _avg: Kyc_complete_recordsAvgAggregateOutputType | null
    _sum: Kyc_complete_recordsSumAggregateOutputType | null
    _min: Kyc_complete_recordsMinAggregateOutputType | null
    _max: Kyc_complete_recordsMaxAggregateOutputType | null
  }

  export type Kyc_complete_recordsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Kyc_complete_recordsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Kyc_complete_recordsMinAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    user_id: number | null
    status: string | null
    result: string | null
    collected_at: Date | null
    updated_at: Date | null
    created_at: Date | null
  }

  export type Kyc_complete_recordsMaxAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    user_id: number | null
    status: string | null
    result: string | null
    collected_at: Date | null
    updated_at: Date | null
    created_at: Date | null
  }

  export type Kyc_complete_recordsCountAggregateOutputType = {
    id: number
    applicant_id: number
    user_id: number
    status: number
    result: number
    complete_data: number
    collected_at: number
    updated_at: number
    created_at: number
    _all: number
  }


  export type Kyc_complete_recordsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Kyc_complete_recordsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Kyc_complete_recordsMinAggregateInputType = {
    id?: true
    applicant_id?: true
    user_id?: true
    status?: true
    result?: true
    collected_at?: true
    updated_at?: true
    created_at?: true
  }

  export type Kyc_complete_recordsMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    user_id?: true
    status?: true
    result?: true
    collected_at?: true
    updated_at?: true
    created_at?: true
  }

  export type Kyc_complete_recordsCountAggregateInputType = {
    id?: true
    applicant_id?: true
    user_id?: true
    status?: true
    result?: true
    complete_data?: true
    collected_at?: true
    updated_at?: true
    created_at?: true
    _all?: true
  }

  export type Kyc_complete_recordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_complete_records to aggregate.
     */
    where?: kyc_complete_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_complete_records to fetch.
     */
    orderBy?: kyc_complete_recordsOrderByWithRelationInput | kyc_complete_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kyc_complete_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_complete_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_complete_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kyc_complete_records
    **/
    _count?: true | Kyc_complete_recordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kyc_complete_recordsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kyc_complete_recordsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kyc_complete_recordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kyc_complete_recordsMaxAggregateInputType
  }

  export type GetKyc_complete_recordsAggregateType<T extends Kyc_complete_recordsAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc_complete_records]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc_complete_records[P]>
      : GetScalarType<T[P], AggregateKyc_complete_records[P]>
  }




  export type kyc_complete_recordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_complete_recordsWhereInput
    orderBy?: kyc_complete_recordsOrderByWithAggregationInput | kyc_complete_recordsOrderByWithAggregationInput[]
    by: Kyc_complete_recordsScalarFieldEnum[] | Kyc_complete_recordsScalarFieldEnum
    having?: kyc_complete_recordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kyc_complete_recordsCountAggregateInputType | true
    _avg?: Kyc_complete_recordsAvgAggregateInputType
    _sum?: Kyc_complete_recordsSumAggregateInputType
    _min?: Kyc_complete_recordsMinAggregateInputType
    _max?: Kyc_complete_recordsMaxAggregateInputType
  }

  export type Kyc_complete_recordsGroupByOutputType = {
    id: number
    applicant_id: string
    user_id: number | null
    status: string
    result: string | null
    complete_data: JsonValue | null
    collected_at: Date
    updated_at: Date
    created_at: Date
    _count: Kyc_complete_recordsCountAggregateOutputType | null
    _avg: Kyc_complete_recordsAvgAggregateOutputType | null
    _sum: Kyc_complete_recordsSumAggregateOutputType | null
    _min: Kyc_complete_recordsMinAggregateOutputType | null
    _max: Kyc_complete_recordsMaxAggregateOutputType | null
  }

  type GetKyc_complete_recordsGroupByPayload<T extends kyc_complete_recordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kyc_complete_recordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kyc_complete_recordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kyc_complete_recordsGroupByOutputType[P]>
            : GetScalarType<T[P], Kyc_complete_recordsGroupByOutputType[P]>
        }
      >
    >


  export type kyc_complete_recordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicant_id?: boolean
    user_id?: boolean
    status?: boolean
    result?: boolean
    complete_data?: boolean
    collected_at?: boolean
    updated_at?: boolean
    created_at?: boolean
    kyc_addresses?: boolean | kyc_complete_records$kyc_addressesArgs<ExtArgs>
    users?: boolean | kyc_complete_records$usersArgs<ExtArgs>
    kyc_documents?: boolean | kyc_complete_records$kyc_documentsArgs<ExtArgs>
    kyc_personal_info?: boolean | kyc_complete_records$kyc_personal_infoArgs<ExtArgs>
    kyc_verification_events?: boolean | kyc_complete_records$kyc_verification_eventsArgs<ExtArgs>
    _count?: boolean | Kyc_complete_recordsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc_complete_records"]>


  export type kyc_complete_recordsSelectScalar = {
    id?: boolean
    applicant_id?: boolean
    user_id?: boolean
    status?: boolean
    result?: boolean
    complete_data?: boolean
    collected_at?: boolean
    updated_at?: boolean
    created_at?: boolean
  }

  export type kyc_complete_recordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_addresses?: boolean | kyc_complete_records$kyc_addressesArgs<ExtArgs>
    users?: boolean | kyc_complete_records$usersArgs<ExtArgs>
    kyc_documents?: boolean | kyc_complete_records$kyc_documentsArgs<ExtArgs>
    kyc_personal_info?: boolean | kyc_complete_records$kyc_personal_infoArgs<ExtArgs>
    kyc_verification_events?: boolean | kyc_complete_records$kyc_verification_eventsArgs<ExtArgs>
    _count?: boolean | Kyc_complete_recordsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $kyc_complete_recordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kyc_complete_records"
    objects: {
      kyc_addresses: Prisma.$kyc_addressesPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs> | null
      kyc_documents: Prisma.$KycDocumentPayload<ExtArgs>[]
      kyc_personal_info: Prisma.$kyc_personal_infoPayload<ExtArgs> | null
      kyc_verification_events: Prisma.$kyc_verification_eventsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicant_id: string
      user_id: number | null
      status: string
      result: string | null
      complete_data: Prisma.JsonValue | null
      collected_at: Date
      updated_at: Date
      created_at: Date
    }, ExtArgs["result"]["kyc_complete_records"]>
    composites: {}
  }

  type kyc_complete_recordsGetPayload<S extends boolean | null | undefined | kyc_complete_recordsDefaultArgs> = $Result.GetResult<Prisma.$kyc_complete_recordsPayload, S>

  type kyc_complete_recordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kyc_complete_recordsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kyc_complete_recordsCountAggregateInputType | true
    }

  export interface kyc_complete_recordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kyc_complete_records'], meta: { name: 'kyc_complete_records' } }
    /**
     * Find zero or one Kyc_complete_records that matches the filter.
     * @param {kyc_complete_recordsFindUniqueArgs} args - Arguments to find a Kyc_complete_records
     * @example
     * // Get one Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kyc_complete_recordsFindUniqueArgs>(args: SelectSubset<T, kyc_complete_recordsFindUniqueArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kyc_complete_records that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kyc_complete_recordsFindUniqueOrThrowArgs} args - Arguments to find a Kyc_complete_records
     * @example
     * // Get one Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kyc_complete_recordsFindUniqueOrThrowArgs>(args: SelectSubset<T, kyc_complete_recordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kyc_complete_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_complete_recordsFindFirstArgs} args - Arguments to find a Kyc_complete_records
     * @example
     * // Get one Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kyc_complete_recordsFindFirstArgs>(args?: SelectSubset<T, kyc_complete_recordsFindFirstArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kyc_complete_records that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_complete_recordsFindFirstOrThrowArgs} args - Arguments to find a Kyc_complete_records
     * @example
     * // Get one Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kyc_complete_recordsFindFirstOrThrowArgs>(args?: SelectSubset<T, kyc_complete_recordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kyc_complete_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_complete_recordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.findMany()
     * 
     * // Get first 10 Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kyc_complete_recordsWithIdOnly = await prisma.kyc_complete_records.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kyc_complete_recordsFindManyArgs>(args?: SelectSubset<T, kyc_complete_recordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kyc_complete_records.
     * @param {kyc_complete_recordsCreateArgs} args - Arguments to create a Kyc_complete_records.
     * @example
     * // Create one Kyc_complete_records
     * const Kyc_complete_records = await prisma.kyc_complete_records.create({
     *   data: {
     *     // ... data to create a Kyc_complete_records
     *   }
     * })
     * 
     */
    create<T extends kyc_complete_recordsCreateArgs>(args: SelectSubset<T, kyc_complete_recordsCreateArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kyc_complete_records.
     * @param {kyc_complete_recordsCreateManyArgs} args - Arguments to create many Kyc_complete_records.
     * @example
     * // Create many Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kyc_complete_recordsCreateManyArgs>(args?: SelectSubset<T, kyc_complete_recordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kyc_complete_records.
     * @param {kyc_complete_recordsDeleteArgs} args - Arguments to delete one Kyc_complete_records.
     * @example
     * // Delete one Kyc_complete_records
     * const Kyc_complete_records = await prisma.kyc_complete_records.delete({
     *   where: {
     *     // ... filter to delete one Kyc_complete_records
     *   }
     * })
     * 
     */
    delete<T extends kyc_complete_recordsDeleteArgs>(args: SelectSubset<T, kyc_complete_recordsDeleteArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kyc_complete_records.
     * @param {kyc_complete_recordsUpdateArgs} args - Arguments to update one Kyc_complete_records.
     * @example
     * // Update one Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kyc_complete_recordsUpdateArgs>(args: SelectSubset<T, kyc_complete_recordsUpdateArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kyc_complete_records.
     * @param {kyc_complete_recordsDeleteManyArgs} args - Arguments to filter Kyc_complete_records to delete.
     * @example
     * // Delete a few Kyc_complete_records
     * const { count } = await prisma.kyc_complete_records.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kyc_complete_recordsDeleteManyArgs>(args?: SelectSubset<T, kyc_complete_recordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kyc_complete_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_complete_recordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kyc_complete_recordsUpdateManyArgs>(args: SelectSubset<T, kyc_complete_recordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kyc_complete_records.
     * @param {kyc_complete_recordsUpsertArgs} args - Arguments to update or create a Kyc_complete_records.
     * @example
     * // Update or create a Kyc_complete_records
     * const kyc_complete_records = await prisma.kyc_complete_records.upsert({
     *   create: {
     *     // ... data to create a Kyc_complete_records
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc_complete_records we want to update
     *   }
     * })
     */
    upsert<T extends kyc_complete_recordsUpsertArgs>(args: SelectSubset<T, kyc_complete_recordsUpsertArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kyc_complete_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_complete_recordsCountArgs} args - Arguments to filter Kyc_complete_records to count.
     * @example
     * // Count the number of Kyc_complete_records
     * const count = await prisma.kyc_complete_records.count({
     *   where: {
     *     // ... the filter for the Kyc_complete_records we want to count
     *   }
     * })
    **/
    count<T extends kyc_complete_recordsCountArgs>(
      args?: Subset<T, kyc_complete_recordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kyc_complete_recordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc_complete_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kyc_complete_recordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kyc_complete_recordsAggregateArgs>(args: Subset<T, Kyc_complete_recordsAggregateArgs>): Prisma.PrismaPromise<GetKyc_complete_recordsAggregateType<T>>

    /**
     * Group by Kyc_complete_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_complete_recordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kyc_complete_recordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kyc_complete_recordsGroupByArgs['orderBy'] }
        : { orderBy?: kyc_complete_recordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kyc_complete_recordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKyc_complete_recordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kyc_complete_records model
   */
  readonly fields: kyc_complete_recordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kyc_complete_records.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kyc_complete_recordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_addresses<T extends kyc_complete_records$kyc_addressesArgs<ExtArgs> = {}>(args?: Subset<T, kyc_complete_records$kyc_addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_addressesPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends kyc_complete_records$usersArgs<ExtArgs> = {}>(args?: Subset<T, kyc_complete_records$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    kyc_documents<T extends kyc_complete_records$kyc_documentsArgs<ExtArgs> = {}>(args?: Subset<T, kyc_complete_records$kyc_documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    kyc_personal_info<T extends kyc_complete_records$kyc_personal_infoArgs<ExtArgs> = {}>(args?: Subset<T, kyc_complete_records$kyc_personal_infoArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    kyc_verification_events<T extends kyc_complete_records$kyc_verification_eventsArgs<ExtArgs> = {}>(args?: Subset<T, kyc_complete_records$kyc_verification_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kyc_complete_records model
   */ 
  interface kyc_complete_recordsFieldRefs {
    readonly id: FieldRef<"kyc_complete_records", 'Int'>
    readonly applicant_id: FieldRef<"kyc_complete_records", 'String'>
    readonly user_id: FieldRef<"kyc_complete_records", 'Int'>
    readonly status: FieldRef<"kyc_complete_records", 'String'>
    readonly result: FieldRef<"kyc_complete_records", 'String'>
    readonly complete_data: FieldRef<"kyc_complete_records", 'Json'>
    readonly collected_at: FieldRef<"kyc_complete_records", 'DateTime'>
    readonly updated_at: FieldRef<"kyc_complete_records", 'DateTime'>
    readonly created_at: FieldRef<"kyc_complete_records", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * kyc_complete_records findUnique
   */
  export type kyc_complete_recordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_complete_records to fetch.
     */
    where: kyc_complete_recordsWhereUniqueInput
  }

  /**
   * kyc_complete_records findUniqueOrThrow
   */
  export type kyc_complete_recordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_complete_records to fetch.
     */
    where: kyc_complete_recordsWhereUniqueInput
  }

  /**
   * kyc_complete_records findFirst
   */
  export type kyc_complete_recordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_complete_records to fetch.
     */
    where?: kyc_complete_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_complete_records to fetch.
     */
    orderBy?: kyc_complete_recordsOrderByWithRelationInput | kyc_complete_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_complete_records.
     */
    cursor?: kyc_complete_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_complete_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_complete_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_complete_records.
     */
    distinct?: Kyc_complete_recordsScalarFieldEnum | Kyc_complete_recordsScalarFieldEnum[]
  }

  /**
   * kyc_complete_records findFirstOrThrow
   */
  export type kyc_complete_recordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_complete_records to fetch.
     */
    where?: kyc_complete_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_complete_records to fetch.
     */
    orderBy?: kyc_complete_recordsOrderByWithRelationInput | kyc_complete_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_complete_records.
     */
    cursor?: kyc_complete_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_complete_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_complete_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_complete_records.
     */
    distinct?: Kyc_complete_recordsScalarFieldEnum | Kyc_complete_recordsScalarFieldEnum[]
  }

  /**
   * kyc_complete_records findMany
   */
  export type kyc_complete_recordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_complete_records to fetch.
     */
    where?: kyc_complete_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_complete_records to fetch.
     */
    orderBy?: kyc_complete_recordsOrderByWithRelationInput | kyc_complete_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kyc_complete_records.
     */
    cursor?: kyc_complete_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_complete_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_complete_records.
     */
    skip?: number
    distinct?: Kyc_complete_recordsScalarFieldEnum | Kyc_complete_recordsScalarFieldEnum[]
  }

  /**
   * kyc_complete_records create
   */
  export type kyc_complete_recordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    /**
     * The data needed to create a kyc_complete_records.
     */
    data: XOR<kyc_complete_recordsCreateInput, kyc_complete_recordsUncheckedCreateInput>
  }

  /**
   * kyc_complete_records createMany
   */
  export type kyc_complete_recordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kyc_complete_records.
     */
    data: kyc_complete_recordsCreateManyInput | kyc_complete_recordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kyc_complete_records update
   */
  export type kyc_complete_recordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    /**
     * The data needed to update a kyc_complete_records.
     */
    data: XOR<kyc_complete_recordsUpdateInput, kyc_complete_recordsUncheckedUpdateInput>
    /**
     * Choose, which kyc_complete_records to update.
     */
    where: kyc_complete_recordsWhereUniqueInput
  }

  /**
   * kyc_complete_records updateMany
   */
  export type kyc_complete_recordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kyc_complete_records.
     */
    data: XOR<kyc_complete_recordsUpdateManyMutationInput, kyc_complete_recordsUncheckedUpdateManyInput>
    /**
     * Filter which kyc_complete_records to update
     */
    where?: kyc_complete_recordsWhereInput
  }

  /**
   * kyc_complete_records upsert
   */
  export type kyc_complete_recordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    /**
     * The filter to search for the kyc_complete_records to update in case it exists.
     */
    where: kyc_complete_recordsWhereUniqueInput
    /**
     * In case the kyc_complete_records found by the `where` argument doesn't exist, create a new kyc_complete_records with this data.
     */
    create: XOR<kyc_complete_recordsCreateInput, kyc_complete_recordsUncheckedCreateInput>
    /**
     * In case the kyc_complete_records was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kyc_complete_recordsUpdateInput, kyc_complete_recordsUncheckedUpdateInput>
  }

  /**
   * kyc_complete_records delete
   */
  export type kyc_complete_recordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    /**
     * Filter which kyc_complete_records to delete.
     */
    where: kyc_complete_recordsWhereUniqueInput
  }

  /**
   * kyc_complete_records deleteMany
   */
  export type kyc_complete_recordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_complete_records to delete
     */
    where?: kyc_complete_recordsWhereInput
  }

  /**
   * kyc_complete_records.kyc_addresses
   */
  export type kyc_complete_records$kyc_addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_addresses
     */
    select?: kyc_addressesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_addressesInclude<ExtArgs> | null
    where?: kyc_addressesWhereInput
    orderBy?: kyc_addressesOrderByWithRelationInput | kyc_addressesOrderByWithRelationInput[]
    cursor?: kyc_addressesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kyc_addressesScalarFieldEnum | Kyc_addressesScalarFieldEnum[]
  }

  /**
   * kyc_complete_records.users
   */
  export type kyc_complete_records$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * kyc_complete_records.kyc_documents
   */
  export type kyc_complete_records$kyc_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    where?: KycDocumentWhereInput
    orderBy?: KycDocumentOrderByWithRelationInput | KycDocumentOrderByWithRelationInput[]
    cursor?: KycDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KycDocumentScalarFieldEnum | KycDocumentScalarFieldEnum[]
  }

  /**
   * kyc_complete_records.kyc_personal_info
   */
  export type kyc_complete_records$kyc_personal_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    where?: kyc_personal_infoWhereInput
  }

  /**
   * kyc_complete_records.kyc_verification_events
   */
  export type kyc_complete_records$kyc_verification_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    where?: kyc_verification_eventsWhereInput
    orderBy?: kyc_verification_eventsOrderByWithRelationInput | kyc_verification_eventsOrderByWithRelationInput[]
    cursor?: kyc_verification_eventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kyc_verification_eventsScalarFieldEnum | Kyc_verification_eventsScalarFieldEnum[]
  }

  /**
   * kyc_complete_records without action
   */
  export type kyc_complete_recordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
  }


  /**
   * Model kyc_personal_info
   */

  export type AggregateKyc_personal_info = {
    _count: Kyc_personal_infoCountAggregateOutputType | null
    _avg: Kyc_personal_infoAvgAggregateOutputType | null
    _sum: Kyc_personal_infoSumAggregateOutputType | null
    _min: Kyc_personal_infoMinAggregateOutputType | null
    _max: Kyc_personal_infoMaxAggregateOutputType | null
  }

  export type Kyc_personal_infoAvgAggregateOutputType = {
    id: number | null
    record_id: number | null
  }

  export type Kyc_personal_infoSumAggregateOutputType = {
    id: number | null
    record_id: number | null
  }

  export type Kyc_personal_infoMinAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    record_id: number | null
    first_name: string | null
    last_name: string | null
    middle_name: string | null
    full_name: string | null
    legal_name: string | null
    gender: string | null
    date_of_birth: Date | null
    place_of_birth: string | null
    country_of_birth: string | null
    state_of_birth: string | null
    nationality: string | null
    phone: string | null
    email: string | null
    country: string | null
    tax_residence_country: string | null
    tax_identification_number: string | null
    id_number: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Kyc_personal_infoMaxAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    record_id: number | null
    first_name: string | null
    last_name: string | null
    middle_name: string | null
    full_name: string | null
    legal_name: string | null
    gender: string | null
    date_of_birth: Date | null
    place_of_birth: string | null
    country_of_birth: string | null
    state_of_birth: string | null
    nationality: string | null
    phone: string | null
    email: string | null
    country: string | null
    tax_residence_country: string | null
    tax_identification_number: string | null
    id_number: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Kyc_personal_infoCountAggregateOutputType = {
    id: number
    applicant_id: number
    record_id: number
    first_name: number
    last_name: number
    middle_name: number
    full_name: number
    legal_name: number
    gender: number
    date_of_birth: number
    place_of_birth: number
    country_of_birth: number
    state_of_birth: number
    nationality: number
    phone: number
    email: number
    country: number
    tax_residence_country: number
    tax_identification_number: number
    id_number: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Kyc_personal_infoAvgAggregateInputType = {
    id?: true
    record_id?: true
  }

  export type Kyc_personal_infoSumAggregateInputType = {
    id?: true
    record_id?: true
  }

  export type Kyc_personal_infoMinAggregateInputType = {
    id?: true
    applicant_id?: true
    record_id?: true
    first_name?: true
    last_name?: true
    middle_name?: true
    full_name?: true
    legal_name?: true
    gender?: true
    date_of_birth?: true
    place_of_birth?: true
    country_of_birth?: true
    state_of_birth?: true
    nationality?: true
    phone?: true
    email?: true
    country?: true
    tax_residence_country?: true
    tax_identification_number?: true
    id_number?: true
    created_at?: true
    updated_at?: true
  }

  export type Kyc_personal_infoMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    record_id?: true
    first_name?: true
    last_name?: true
    middle_name?: true
    full_name?: true
    legal_name?: true
    gender?: true
    date_of_birth?: true
    place_of_birth?: true
    country_of_birth?: true
    state_of_birth?: true
    nationality?: true
    phone?: true
    email?: true
    country?: true
    tax_residence_country?: true
    tax_identification_number?: true
    id_number?: true
    created_at?: true
    updated_at?: true
  }

  export type Kyc_personal_infoCountAggregateInputType = {
    id?: true
    applicant_id?: true
    record_id?: true
    first_name?: true
    last_name?: true
    middle_name?: true
    full_name?: true
    legal_name?: true
    gender?: true
    date_of_birth?: true
    place_of_birth?: true
    country_of_birth?: true
    state_of_birth?: true
    nationality?: true
    phone?: true
    email?: true
    country?: true
    tax_residence_country?: true
    tax_identification_number?: true
    id_number?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Kyc_personal_infoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_personal_info to aggregate.
     */
    where?: kyc_personal_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_personal_infos to fetch.
     */
    orderBy?: kyc_personal_infoOrderByWithRelationInput | kyc_personal_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kyc_personal_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_personal_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_personal_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kyc_personal_infos
    **/
    _count?: true | Kyc_personal_infoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kyc_personal_infoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kyc_personal_infoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kyc_personal_infoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kyc_personal_infoMaxAggregateInputType
  }

  export type GetKyc_personal_infoAggregateType<T extends Kyc_personal_infoAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc_personal_info]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc_personal_info[P]>
      : GetScalarType<T[P], AggregateKyc_personal_info[P]>
  }




  export type kyc_personal_infoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_personal_infoWhereInput
    orderBy?: kyc_personal_infoOrderByWithAggregationInput | kyc_personal_infoOrderByWithAggregationInput[]
    by: Kyc_personal_infoScalarFieldEnum[] | Kyc_personal_infoScalarFieldEnum
    having?: kyc_personal_infoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kyc_personal_infoCountAggregateInputType | true
    _avg?: Kyc_personal_infoAvgAggregateInputType
    _sum?: Kyc_personal_infoSumAggregateInputType
    _min?: Kyc_personal_infoMinAggregateInputType
    _max?: Kyc_personal_infoMaxAggregateInputType
  }

  export type Kyc_personal_infoGroupByOutputType = {
    id: number
    applicant_id: string | null
    record_id: number | null
    first_name: string | null
    last_name: string | null
    middle_name: string | null
    full_name: string | null
    legal_name: string | null
    gender: string | null
    date_of_birth: Date | null
    place_of_birth: string | null
    country_of_birth: string | null
    state_of_birth: string | null
    nationality: string | null
    phone: string | null
    email: string | null
    country: string | null
    tax_residence_country: string | null
    tax_identification_number: string | null
    id_number: string | null
    created_at: Date
    updated_at: Date
    _count: Kyc_personal_infoCountAggregateOutputType | null
    _avg: Kyc_personal_infoAvgAggregateOutputType | null
    _sum: Kyc_personal_infoSumAggregateOutputType | null
    _min: Kyc_personal_infoMinAggregateOutputType | null
    _max: Kyc_personal_infoMaxAggregateOutputType | null
  }

  type GetKyc_personal_infoGroupByPayload<T extends kyc_personal_infoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kyc_personal_infoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kyc_personal_infoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kyc_personal_infoGroupByOutputType[P]>
            : GetScalarType<T[P], Kyc_personal_infoGroupByOutputType[P]>
        }
      >
    >


  export type kyc_personal_infoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicant_id?: boolean
    record_id?: boolean
    first_name?: boolean
    last_name?: boolean
    middle_name?: boolean
    full_name?: boolean
    legal_name?: boolean
    gender?: boolean
    date_of_birth?: boolean
    place_of_birth?: boolean
    country_of_birth?: boolean
    state_of_birth?: boolean
    nationality?: boolean
    phone?: boolean
    email?: boolean
    country?: boolean
    tax_residence_country?: boolean
    tax_identification_number?: boolean
    id_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    kyc_applicants?: boolean | kyc_personal_info$kyc_applicantsArgs<ExtArgs>
    kyc_complete_records?: boolean | kyc_personal_info$kyc_complete_recordsArgs<ExtArgs>
  }, ExtArgs["result"]["kyc_personal_info"]>


  export type kyc_personal_infoSelectScalar = {
    id?: boolean
    applicant_id?: boolean
    record_id?: boolean
    first_name?: boolean
    last_name?: boolean
    middle_name?: boolean
    full_name?: boolean
    legal_name?: boolean
    gender?: boolean
    date_of_birth?: boolean
    place_of_birth?: boolean
    country_of_birth?: boolean
    state_of_birth?: boolean
    nationality?: boolean
    phone?: boolean
    email?: boolean
    country?: boolean
    tax_residence_country?: boolean
    tax_identification_number?: boolean
    id_number?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type kyc_personal_infoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_applicants?: boolean | kyc_personal_info$kyc_applicantsArgs<ExtArgs>
    kyc_complete_records?: boolean | kyc_personal_info$kyc_complete_recordsArgs<ExtArgs>
  }

  export type $kyc_personal_infoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kyc_personal_info"
    objects: {
      kyc_applicants: Prisma.$kyc_applicantsPayload<ExtArgs> | null
      kyc_complete_records: Prisma.$kyc_complete_recordsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicant_id: string | null
      record_id: number | null
      first_name: string | null
      last_name: string | null
      middle_name: string | null
      full_name: string | null
      legal_name: string | null
      gender: string | null
      date_of_birth: Date | null
      place_of_birth: string | null
      country_of_birth: string | null
      state_of_birth: string | null
      nationality: string | null
      phone: string | null
      email: string | null
      country: string | null
      tax_residence_country: string | null
      tax_identification_number: string | null
      id_number: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["kyc_personal_info"]>
    composites: {}
  }

  type kyc_personal_infoGetPayload<S extends boolean | null | undefined | kyc_personal_infoDefaultArgs> = $Result.GetResult<Prisma.$kyc_personal_infoPayload, S>

  type kyc_personal_infoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kyc_personal_infoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kyc_personal_infoCountAggregateInputType | true
    }

  export interface kyc_personal_infoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kyc_personal_info'], meta: { name: 'kyc_personal_info' } }
    /**
     * Find zero or one Kyc_personal_info that matches the filter.
     * @param {kyc_personal_infoFindUniqueArgs} args - Arguments to find a Kyc_personal_info
     * @example
     * // Get one Kyc_personal_info
     * const kyc_personal_info = await prisma.kyc_personal_info.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kyc_personal_infoFindUniqueArgs>(args: SelectSubset<T, kyc_personal_infoFindUniqueArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kyc_personal_info that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kyc_personal_infoFindUniqueOrThrowArgs} args - Arguments to find a Kyc_personal_info
     * @example
     * // Get one Kyc_personal_info
     * const kyc_personal_info = await prisma.kyc_personal_info.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kyc_personal_infoFindUniqueOrThrowArgs>(args: SelectSubset<T, kyc_personal_infoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kyc_personal_info that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_personal_infoFindFirstArgs} args - Arguments to find a Kyc_personal_info
     * @example
     * // Get one Kyc_personal_info
     * const kyc_personal_info = await prisma.kyc_personal_info.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kyc_personal_infoFindFirstArgs>(args?: SelectSubset<T, kyc_personal_infoFindFirstArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kyc_personal_info that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_personal_infoFindFirstOrThrowArgs} args - Arguments to find a Kyc_personal_info
     * @example
     * // Get one Kyc_personal_info
     * const kyc_personal_info = await prisma.kyc_personal_info.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kyc_personal_infoFindFirstOrThrowArgs>(args?: SelectSubset<T, kyc_personal_infoFindFirstOrThrowArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kyc_personal_infos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_personal_infoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kyc_personal_infos
     * const kyc_personal_infos = await prisma.kyc_personal_info.findMany()
     * 
     * // Get first 10 Kyc_personal_infos
     * const kyc_personal_infos = await prisma.kyc_personal_info.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kyc_personal_infoWithIdOnly = await prisma.kyc_personal_info.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kyc_personal_infoFindManyArgs>(args?: SelectSubset<T, kyc_personal_infoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kyc_personal_info.
     * @param {kyc_personal_infoCreateArgs} args - Arguments to create a Kyc_personal_info.
     * @example
     * // Create one Kyc_personal_info
     * const Kyc_personal_info = await prisma.kyc_personal_info.create({
     *   data: {
     *     // ... data to create a Kyc_personal_info
     *   }
     * })
     * 
     */
    create<T extends kyc_personal_infoCreateArgs>(args: SelectSubset<T, kyc_personal_infoCreateArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kyc_personal_infos.
     * @param {kyc_personal_infoCreateManyArgs} args - Arguments to create many Kyc_personal_infos.
     * @example
     * // Create many Kyc_personal_infos
     * const kyc_personal_info = await prisma.kyc_personal_info.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kyc_personal_infoCreateManyArgs>(args?: SelectSubset<T, kyc_personal_infoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kyc_personal_info.
     * @param {kyc_personal_infoDeleteArgs} args - Arguments to delete one Kyc_personal_info.
     * @example
     * // Delete one Kyc_personal_info
     * const Kyc_personal_info = await prisma.kyc_personal_info.delete({
     *   where: {
     *     // ... filter to delete one Kyc_personal_info
     *   }
     * })
     * 
     */
    delete<T extends kyc_personal_infoDeleteArgs>(args: SelectSubset<T, kyc_personal_infoDeleteArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kyc_personal_info.
     * @param {kyc_personal_infoUpdateArgs} args - Arguments to update one Kyc_personal_info.
     * @example
     * // Update one Kyc_personal_info
     * const kyc_personal_info = await prisma.kyc_personal_info.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kyc_personal_infoUpdateArgs>(args: SelectSubset<T, kyc_personal_infoUpdateArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kyc_personal_infos.
     * @param {kyc_personal_infoDeleteManyArgs} args - Arguments to filter Kyc_personal_infos to delete.
     * @example
     * // Delete a few Kyc_personal_infos
     * const { count } = await prisma.kyc_personal_info.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kyc_personal_infoDeleteManyArgs>(args?: SelectSubset<T, kyc_personal_infoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kyc_personal_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_personal_infoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kyc_personal_infos
     * const kyc_personal_info = await prisma.kyc_personal_info.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kyc_personal_infoUpdateManyArgs>(args: SelectSubset<T, kyc_personal_infoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kyc_personal_info.
     * @param {kyc_personal_infoUpsertArgs} args - Arguments to update or create a Kyc_personal_info.
     * @example
     * // Update or create a Kyc_personal_info
     * const kyc_personal_info = await prisma.kyc_personal_info.upsert({
     *   create: {
     *     // ... data to create a Kyc_personal_info
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc_personal_info we want to update
     *   }
     * })
     */
    upsert<T extends kyc_personal_infoUpsertArgs>(args: SelectSubset<T, kyc_personal_infoUpsertArgs<ExtArgs>>): Prisma__kyc_personal_infoClient<$Result.GetResult<Prisma.$kyc_personal_infoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kyc_personal_infos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_personal_infoCountArgs} args - Arguments to filter Kyc_personal_infos to count.
     * @example
     * // Count the number of Kyc_personal_infos
     * const count = await prisma.kyc_personal_info.count({
     *   where: {
     *     // ... the filter for the Kyc_personal_infos we want to count
     *   }
     * })
    **/
    count<T extends kyc_personal_infoCountArgs>(
      args?: Subset<T, kyc_personal_infoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kyc_personal_infoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc_personal_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kyc_personal_infoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kyc_personal_infoAggregateArgs>(args: Subset<T, Kyc_personal_infoAggregateArgs>): Prisma.PrismaPromise<GetKyc_personal_infoAggregateType<T>>

    /**
     * Group by Kyc_personal_info.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_personal_infoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kyc_personal_infoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kyc_personal_infoGroupByArgs['orderBy'] }
        : { orderBy?: kyc_personal_infoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kyc_personal_infoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKyc_personal_infoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kyc_personal_info model
   */
  readonly fields: kyc_personal_infoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kyc_personal_info.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kyc_personal_infoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_applicants<T extends kyc_personal_info$kyc_applicantsArgs<ExtArgs> = {}>(args?: Subset<T, kyc_personal_info$kyc_applicantsArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    kyc_complete_records<T extends kyc_personal_info$kyc_complete_recordsArgs<ExtArgs> = {}>(args?: Subset<T, kyc_personal_info$kyc_complete_recordsArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kyc_personal_info model
   */ 
  interface kyc_personal_infoFieldRefs {
    readonly id: FieldRef<"kyc_personal_info", 'Int'>
    readonly applicant_id: FieldRef<"kyc_personal_info", 'String'>
    readonly record_id: FieldRef<"kyc_personal_info", 'Int'>
    readonly first_name: FieldRef<"kyc_personal_info", 'String'>
    readonly last_name: FieldRef<"kyc_personal_info", 'String'>
    readonly middle_name: FieldRef<"kyc_personal_info", 'String'>
    readonly full_name: FieldRef<"kyc_personal_info", 'String'>
    readonly legal_name: FieldRef<"kyc_personal_info", 'String'>
    readonly gender: FieldRef<"kyc_personal_info", 'String'>
    readonly date_of_birth: FieldRef<"kyc_personal_info", 'DateTime'>
    readonly place_of_birth: FieldRef<"kyc_personal_info", 'String'>
    readonly country_of_birth: FieldRef<"kyc_personal_info", 'String'>
    readonly state_of_birth: FieldRef<"kyc_personal_info", 'String'>
    readonly nationality: FieldRef<"kyc_personal_info", 'String'>
    readonly phone: FieldRef<"kyc_personal_info", 'String'>
    readonly email: FieldRef<"kyc_personal_info", 'String'>
    readonly country: FieldRef<"kyc_personal_info", 'String'>
    readonly tax_residence_country: FieldRef<"kyc_personal_info", 'String'>
    readonly tax_identification_number: FieldRef<"kyc_personal_info", 'String'>
    readonly id_number: FieldRef<"kyc_personal_info", 'String'>
    readonly created_at: FieldRef<"kyc_personal_info", 'DateTime'>
    readonly updated_at: FieldRef<"kyc_personal_info", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * kyc_personal_info findUnique
   */
  export type kyc_personal_infoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_personal_info to fetch.
     */
    where: kyc_personal_infoWhereUniqueInput
  }

  /**
   * kyc_personal_info findUniqueOrThrow
   */
  export type kyc_personal_infoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_personal_info to fetch.
     */
    where: kyc_personal_infoWhereUniqueInput
  }

  /**
   * kyc_personal_info findFirst
   */
  export type kyc_personal_infoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_personal_info to fetch.
     */
    where?: kyc_personal_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_personal_infos to fetch.
     */
    orderBy?: kyc_personal_infoOrderByWithRelationInput | kyc_personal_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_personal_infos.
     */
    cursor?: kyc_personal_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_personal_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_personal_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_personal_infos.
     */
    distinct?: Kyc_personal_infoScalarFieldEnum | Kyc_personal_infoScalarFieldEnum[]
  }

  /**
   * kyc_personal_info findFirstOrThrow
   */
  export type kyc_personal_infoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_personal_info to fetch.
     */
    where?: kyc_personal_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_personal_infos to fetch.
     */
    orderBy?: kyc_personal_infoOrderByWithRelationInput | kyc_personal_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_personal_infos.
     */
    cursor?: kyc_personal_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_personal_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_personal_infos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_personal_infos.
     */
    distinct?: Kyc_personal_infoScalarFieldEnum | Kyc_personal_infoScalarFieldEnum[]
  }

  /**
   * kyc_personal_info findMany
   */
  export type kyc_personal_infoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    /**
     * Filter, which kyc_personal_infos to fetch.
     */
    where?: kyc_personal_infoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_personal_infos to fetch.
     */
    orderBy?: kyc_personal_infoOrderByWithRelationInput | kyc_personal_infoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kyc_personal_infos.
     */
    cursor?: kyc_personal_infoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_personal_infos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_personal_infos.
     */
    skip?: number
    distinct?: Kyc_personal_infoScalarFieldEnum | Kyc_personal_infoScalarFieldEnum[]
  }

  /**
   * kyc_personal_info create
   */
  export type kyc_personal_infoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    /**
     * The data needed to create a kyc_personal_info.
     */
    data: XOR<kyc_personal_infoCreateInput, kyc_personal_infoUncheckedCreateInput>
  }

  /**
   * kyc_personal_info createMany
   */
  export type kyc_personal_infoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kyc_personal_infos.
     */
    data: kyc_personal_infoCreateManyInput | kyc_personal_infoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kyc_personal_info update
   */
  export type kyc_personal_infoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    /**
     * The data needed to update a kyc_personal_info.
     */
    data: XOR<kyc_personal_infoUpdateInput, kyc_personal_infoUncheckedUpdateInput>
    /**
     * Choose, which kyc_personal_info to update.
     */
    where: kyc_personal_infoWhereUniqueInput
  }

  /**
   * kyc_personal_info updateMany
   */
  export type kyc_personal_infoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kyc_personal_infos.
     */
    data: XOR<kyc_personal_infoUpdateManyMutationInput, kyc_personal_infoUncheckedUpdateManyInput>
    /**
     * Filter which kyc_personal_infos to update
     */
    where?: kyc_personal_infoWhereInput
  }

  /**
   * kyc_personal_info upsert
   */
  export type kyc_personal_infoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    /**
     * The filter to search for the kyc_personal_info to update in case it exists.
     */
    where: kyc_personal_infoWhereUniqueInput
    /**
     * In case the kyc_personal_info found by the `where` argument doesn't exist, create a new kyc_personal_info with this data.
     */
    create: XOR<kyc_personal_infoCreateInput, kyc_personal_infoUncheckedCreateInput>
    /**
     * In case the kyc_personal_info was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kyc_personal_infoUpdateInput, kyc_personal_infoUncheckedUpdateInput>
  }

  /**
   * kyc_personal_info delete
   */
  export type kyc_personal_infoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
    /**
     * Filter which kyc_personal_info to delete.
     */
    where: kyc_personal_infoWhereUniqueInput
  }

  /**
   * kyc_personal_info deleteMany
   */
  export type kyc_personal_infoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_personal_infos to delete
     */
    where?: kyc_personal_infoWhereInput
  }

  /**
   * kyc_personal_info.kyc_applicants
   */
  export type kyc_personal_info$kyc_applicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    where?: kyc_applicantsWhereInput
  }

  /**
   * kyc_personal_info.kyc_complete_records
   */
  export type kyc_personal_info$kyc_complete_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    where?: kyc_complete_recordsWhereInput
  }

  /**
   * kyc_personal_info without action
   */
  export type kyc_personal_infoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_personal_info
     */
    select?: kyc_personal_infoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_personal_infoInclude<ExtArgs> | null
  }


  /**
   * Model kyc_raw_data
   */

  export type AggregateKyc_raw_data = {
    _count: Kyc_raw_dataCountAggregateOutputType | null
    _avg: Kyc_raw_dataAvgAggregateOutputType | null
    _sum: Kyc_raw_dataSumAggregateOutputType | null
    _min: Kyc_raw_dataMinAggregateOutputType | null
    _max: Kyc_raw_dataMaxAggregateOutputType | null
  }

  export type Kyc_raw_dataAvgAggregateOutputType = {
    id: number | null
  }

  export type Kyc_raw_dataSumAggregateOutputType = {
    id: number | null
  }

  export type Kyc_raw_dataMinAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    data_type: string | null
    source: string | null
    raw_data: string | null
    created_at: Date | null
  }

  export type Kyc_raw_dataMaxAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    data_type: string | null
    source: string | null
    raw_data: string | null
    created_at: Date | null
  }

  export type Kyc_raw_dataCountAggregateOutputType = {
    id: number
    applicant_id: number
    data_type: number
    source: number
    raw_data: number
    created_at: number
    _all: number
  }


  export type Kyc_raw_dataAvgAggregateInputType = {
    id?: true
  }

  export type Kyc_raw_dataSumAggregateInputType = {
    id?: true
  }

  export type Kyc_raw_dataMinAggregateInputType = {
    id?: true
    applicant_id?: true
    data_type?: true
    source?: true
    raw_data?: true
    created_at?: true
  }

  export type Kyc_raw_dataMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    data_type?: true
    source?: true
    raw_data?: true
    created_at?: true
  }

  export type Kyc_raw_dataCountAggregateInputType = {
    id?: true
    applicant_id?: true
    data_type?: true
    source?: true
    raw_data?: true
    created_at?: true
    _all?: true
  }

  export type Kyc_raw_dataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_raw_data to aggregate.
     */
    where?: kyc_raw_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_raw_data to fetch.
     */
    orderBy?: kyc_raw_dataOrderByWithRelationInput | kyc_raw_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kyc_raw_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_raw_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_raw_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kyc_raw_data
    **/
    _count?: true | Kyc_raw_dataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kyc_raw_dataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kyc_raw_dataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kyc_raw_dataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kyc_raw_dataMaxAggregateInputType
  }

  export type GetKyc_raw_dataAggregateType<T extends Kyc_raw_dataAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc_raw_data]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc_raw_data[P]>
      : GetScalarType<T[P], AggregateKyc_raw_data[P]>
  }




  export type kyc_raw_dataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_raw_dataWhereInput
    orderBy?: kyc_raw_dataOrderByWithAggregationInput | kyc_raw_dataOrderByWithAggregationInput[]
    by: Kyc_raw_dataScalarFieldEnum[] | Kyc_raw_dataScalarFieldEnum
    having?: kyc_raw_dataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kyc_raw_dataCountAggregateInputType | true
    _avg?: Kyc_raw_dataAvgAggregateInputType
    _sum?: Kyc_raw_dataSumAggregateInputType
    _min?: Kyc_raw_dataMinAggregateInputType
    _max?: Kyc_raw_dataMaxAggregateInputType
  }

  export type Kyc_raw_dataGroupByOutputType = {
    id: number
    applicant_id: string
    data_type: string
    source: string
    raw_data: string
    created_at: Date
    _count: Kyc_raw_dataCountAggregateOutputType | null
    _avg: Kyc_raw_dataAvgAggregateOutputType | null
    _sum: Kyc_raw_dataSumAggregateOutputType | null
    _min: Kyc_raw_dataMinAggregateOutputType | null
    _max: Kyc_raw_dataMaxAggregateOutputType | null
  }

  type GetKyc_raw_dataGroupByPayload<T extends kyc_raw_dataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kyc_raw_dataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kyc_raw_dataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kyc_raw_dataGroupByOutputType[P]>
            : GetScalarType<T[P], Kyc_raw_dataGroupByOutputType[P]>
        }
      >
    >


  export type kyc_raw_dataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicant_id?: boolean
    data_type?: boolean
    source?: boolean
    raw_data?: boolean
    created_at?: boolean
    kyc_applicants?: boolean | kyc_applicantsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc_raw_data"]>


  export type kyc_raw_dataSelectScalar = {
    id?: boolean
    applicant_id?: boolean
    data_type?: boolean
    source?: boolean
    raw_data?: boolean
    created_at?: boolean
  }

  export type kyc_raw_dataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_applicants?: boolean | kyc_applicantsDefaultArgs<ExtArgs>
  }

  export type $kyc_raw_dataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kyc_raw_data"
    objects: {
      kyc_applicants: Prisma.$kyc_applicantsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicant_id: string
      data_type: string
      source: string
      raw_data: string
      created_at: Date
    }, ExtArgs["result"]["kyc_raw_data"]>
    composites: {}
  }

  type kyc_raw_dataGetPayload<S extends boolean | null | undefined | kyc_raw_dataDefaultArgs> = $Result.GetResult<Prisma.$kyc_raw_dataPayload, S>

  type kyc_raw_dataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kyc_raw_dataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kyc_raw_dataCountAggregateInputType | true
    }

  export interface kyc_raw_dataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kyc_raw_data'], meta: { name: 'kyc_raw_data' } }
    /**
     * Find zero or one Kyc_raw_data that matches the filter.
     * @param {kyc_raw_dataFindUniqueArgs} args - Arguments to find a Kyc_raw_data
     * @example
     * // Get one Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kyc_raw_dataFindUniqueArgs>(args: SelectSubset<T, kyc_raw_dataFindUniqueArgs<ExtArgs>>): Prisma__kyc_raw_dataClient<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kyc_raw_data that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kyc_raw_dataFindUniqueOrThrowArgs} args - Arguments to find a Kyc_raw_data
     * @example
     * // Get one Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kyc_raw_dataFindUniqueOrThrowArgs>(args: SelectSubset<T, kyc_raw_dataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kyc_raw_dataClient<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kyc_raw_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_raw_dataFindFirstArgs} args - Arguments to find a Kyc_raw_data
     * @example
     * // Get one Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kyc_raw_dataFindFirstArgs>(args?: SelectSubset<T, kyc_raw_dataFindFirstArgs<ExtArgs>>): Prisma__kyc_raw_dataClient<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kyc_raw_data that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_raw_dataFindFirstOrThrowArgs} args - Arguments to find a Kyc_raw_data
     * @example
     * // Get one Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kyc_raw_dataFindFirstOrThrowArgs>(args?: SelectSubset<T, kyc_raw_dataFindFirstOrThrowArgs<ExtArgs>>): Prisma__kyc_raw_dataClient<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kyc_raw_data that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_raw_dataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.findMany()
     * 
     * // Get first 10 Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kyc_raw_dataWithIdOnly = await prisma.kyc_raw_data.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kyc_raw_dataFindManyArgs>(args?: SelectSubset<T, kyc_raw_dataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kyc_raw_data.
     * @param {kyc_raw_dataCreateArgs} args - Arguments to create a Kyc_raw_data.
     * @example
     * // Create one Kyc_raw_data
     * const Kyc_raw_data = await prisma.kyc_raw_data.create({
     *   data: {
     *     // ... data to create a Kyc_raw_data
     *   }
     * })
     * 
     */
    create<T extends kyc_raw_dataCreateArgs>(args: SelectSubset<T, kyc_raw_dataCreateArgs<ExtArgs>>): Prisma__kyc_raw_dataClient<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kyc_raw_data.
     * @param {kyc_raw_dataCreateManyArgs} args - Arguments to create many Kyc_raw_data.
     * @example
     * // Create many Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kyc_raw_dataCreateManyArgs>(args?: SelectSubset<T, kyc_raw_dataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kyc_raw_data.
     * @param {kyc_raw_dataDeleteArgs} args - Arguments to delete one Kyc_raw_data.
     * @example
     * // Delete one Kyc_raw_data
     * const Kyc_raw_data = await prisma.kyc_raw_data.delete({
     *   where: {
     *     // ... filter to delete one Kyc_raw_data
     *   }
     * })
     * 
     */
    delete<T extends kyc_raw_dataDeleteArgs>(args: SelectSubset<T, kyc_raw_dataDeleteArgs<ExtArgs>>): Prisma__kyc_raw_dataClient<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kyc_raw_data.
     * @param {kyc_raw_dataUpdateArgs} args - Arguments to update one Kyc_raw_data.
     * @example
     * // Update one Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kyc_raw_dataUpdateArgs>(args: SelectSubset<T, kyc_raw_dataUpdateArgs<ExtArgs>>): Prisma__kyc_raw_dataClient<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kyc_raw_data.
     * @param {kyc_raw_dataDeleteManyArgs} args - Arguments to filter Kyc_raw_data to delete.
     * @example
     * // Delete a few Kyc_raw_data
     * const { count } = await prisma.kyc_raw_data.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kyc_raw_dataDeleteManyArgs>(args?: SelectSubset<T, kyc_raw_dataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kyc_raw_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_raw_dataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kyc_raw_dataUpdateManyArgs>(args: SelectSubset<T, kyc_raw_dataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kyc_raw_data.
     * @param {kyc_raw_dataUpsertArgs} args - Arguments to update or create a Kyc_raw_data.
     * @example
     * // Update or create a Kyc_raw_data
     * const kyc_raw_data = await prisma.kyc_raw_data.upsert({
     *   create: {
     *     // ... data to create a Kyc_raw_data
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc_raw_data we want to update
     *   }
     * })
     */
    upsert<T extends kyc_raw_dataUpsertArgs>(args: SelectSubset<T, kyc_raw_dataUpsertArgs<ExtArgs>>): Prisma__kyc_raw_dataClient<$Result.GetResult<Prisma.$kyc_raw_dataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kyc_raw_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_raw_dataCountArgs} args - Arguments to filter Kyc_raw_data to count.
     * @example
     * // Count the number of Kyc_raw_data
     * const count = await prisma.kyc_raw_data.count({
     *   where: {
     *     // ... the filter for the Kyc_raw_data we want to count
     *   }
     * })
    **/
    count<T extends kyc_raw_dataCountArgs>(
      args?: Subset<T, kyc_raw_dataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kyc_raw_dataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc_raw_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kyc_raw_dataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kyc_raw_dataAggregateArgs>(args: Subset<T, Kyc_raw_dataAggregateArgs>): Prisma.PrismaPromise<GetKyc_raw_dataAggregateType<T>>

    /**
     * Group by Kyc_raw_data.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_raw_dataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kyc_raw_dataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kyc_raw_dataGroupByArgs['orderBy'] }
        : { orderBy?: kyc_raw_dataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kyc_raw_dataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKyc_raw_dataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kyc_raw_data model
   */
  readonly fields: kyc_raw_dataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kyc_raw_data.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kyc_raw_dataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_applicants<T extends kyc_applicantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicantsDefaultArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kyc_raw_data model
   */ 
  interface kyc_raw_dataFieldRefs {
    readonly id: FieldRef<"kyc_raw_data", 'Int'>
    readonly applicant_id: FieldRef<"kyc_raw_data", 'String'>
    readonly data_type: FieldRef<"kyc_raw_data", 'String'>
    readonly source: FieldRef<"kyc_raw_data", 'String'>
    readonly raw_data: FieldRef<"kyc_raw_data", 'String'>
    readonly created_at: FieldRef<"kyc_raw_data", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * kyc_raw_data findUnique
   */
  export type kyc_raw_dataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    /**
     * Filter, which kyc_raw_data to fetch.
     */
    where: kyc_raw_dataWhereUniqueInput
  }

  /**
   * kyc_raw_data findUniqueOrThrow
   */
  export type kyc_raw_dataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    /**
     * Filter, which kyc_raw_data to fetch.
     */
    where: kyc_raw_dataWhereUniqueInput
  }

  /**
   * kyc_raw_data findFirst
   */
  export type kyc_raw_dataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    /**
     * Filter, which kyc_raw_data to fetch.
     */
    where?: kyc_raw_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_raw_data to fetch.
     */
    orderBy?: kyc_raw_dataOrderByWithRelationInput | kyc_raw_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_raw_data.
     */
    cursor?: kyc_raw_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_raw_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_raw_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_raw_data.
     */
    distinct?: Kyc_raw_dataScalarFieldEnum | Kyc_raw_dataScalarFieldEnum[]
  }

  /**
   * kyc_raw_data findFirstOrThrow
   */
  export type kyc_raw_dataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    /**
     * Filter, which kyc_raw_data to fetch.
     */
    where?: kyc_raw_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_raw_data to fetch.
     */
    orderBy?: kyc_raw_dataOrderByWithRelationInput | kyc_raw_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_raw_data.
     */
    cursor?: kyc_raw_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_raw_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_raw_data.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_raw_data.
     */
    distinct?: Kyc_raw_dataScalarFieldEnum | Kyc_raw_dataScalarFieldEnum[]
  }

  /**
   * kyc_raw_data findMany
   */
  export type kyc_raw_dataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    /**
     * Filter, which kyc_raw_data to fetch.
     */
    where?: kyc_raw_dataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_raw_data to fetch.
     */
    orderBy?: kyc_raw_dataOrderByWithRelationInput | kyc_raw_dataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kyc_raw_data.
     */
    cursor?: kyc_raw_dataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_raw_data from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_raw_data.
     */
    skip?: number
    distinct?: Kyc_raw_dataScalarFieldEnum | Kyc_raw_dataScalarFieldEnum[]
  }

  /**
   * kyc_raw_data create
   */
  export type kyc_raw_dataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    /**
     * The data needed to create a kyc_raw_data.
     */
    data: XOR<kyc_raw_dataCreateInput, kyc_raw_dataUncheckedCreateInput>
  }

  /**
   * kyc_raw_data createMany
   */
  export type kyc_raw_dataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kyc_raw_data.
     */
    data: kyc_raw_dataCreateManyInput | kyc_raw_dataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kyc_raw_data update
   */
  export type kyc_raw_dataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    /**
     * The data needed to update a kyc_raw_data.
     */
    data: XOR<kyc_raw_dataUpdateInput, kyc_raw_dataUncheckedUpdateInput>
    /**
     * Choose, which kyc_raw_data to update.
     */
    where: kyc_raw_dataWhereUniqueInput
  }

  /**
   * kyc_raw_data updateMany
   */
  export type kyc_raw_dataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kyc_raw_data.
     */
    data: XOR<kyc_raw_dataUpdateManyMutationInput, kyc_raw_dataUncheckedUpdateManyInput>
    /**
     * Filter which kyc_raw_data to update
     */
    where?: kyc_raw_dataWhereInput
  }

  /**
   * kyc_raw_data upsert
   */
  export type kyc_raw_dataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    /**
     * The filter to search for the kyc_raw_data to update in case it exists.
     */
    where: kyc_raw_dataWhereUniqueInput
    /**
     * In case the kyc_raw_data found by the `where` argument doesn't exist, create a new kyc_raw_data with this data.
     */
    create: XOR<kyc_raw_dataCreateInput, kyc_raw_dataUncheckedCreateInput>
    /**
     * In case the kyc_raw_data was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kyc_raw_dataUpdateInput, kyc_raw_dataUncheckedUpdateInput>
  }

  /**
   * kyc_raw_data delete
   */
  export type kyc_raw_dataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
    /**
     * Filter which kyc_raw_data to delete.
     */
    where: kyc_raw_dataWhereUniqueInput
  }

  /**
   * kyc_raw_data deleteMany
   */
  export type kyc_raw_dataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_raw_data to delete
     */
    where?: kyc_raw_dataWhereInput
  }

  /**
   * kyc_raw_data without action
   */
  export type kyc_raw_dataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_raw_data
     */
    select?: kyc_raw_dataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_raw_dataInclude<ExtArgs> | null
  }


  /**
   * Model kyc_verification_events
   */

  export type AggregateKyc_verification_events = {
    _count: Kyc_verification_eventsCountAggregateOutputType | null
    _avg: Kyc_verification_eventsAvgAggregateOutputType | null
    _sum: Kyc_verification_eventsSumAggregateOutputType | null
    _min: Kyc_verification_eventsMinAggregateOutputType | null
    _max: Kyc_verification_eventsMaxAggregateOutputType | null
  }

  export type Kyc_verification_eventsAvgAggregateOutputType = {
    id: number | null
    record_id: number | null
  }

  export type Kyc_verification_eventsSumAggregateOutputType = {
    id: number | null
    record_id: number | null
  }

  export type Kyc_verification_eventsMinAggregateOutputType = {
    id: number | null
    record_id: number | null
    type: string | null
    review_status: string | null
    review_result: string | null
    inspection_id: string | null
    event_timestamp: Date | null
    created_at: Date | null
  }

  export type Kyc_verification_eventsMaxAggregateOutputType = {
    id: number | null
    record_id: number | null
    type: string | null
    review_status: string | null
    review_result: string | null
    inspection_id: string | null
    event_timestamp: Date | null
    created_at: Date | null
  }

  export type Kyc_verification_eventsCountAggregateOutputType = {
    id: number
    record_id: number
    type: number
    review_status: number
    review_result: number
    inspection_id: number
    event_data: number
    event_timestamp: number
    created_at: number
    _all: number
  }


  export type Kyc_verification_eventsAvgAggregateInputType = {
    id?: true
    record_id?: true
  }

  export type Kyc_verification_eventsSumAggregateInputType = {
    id?: true
    record_id?: true
  }

  export type Kyc_verification_eventsMinAggregateInputType = {
    id?: true
    record_id?: true
    type?: true
    review_status?: true
    review_result?: true
    inspection_id?: true
    event_timestamp?: true
    created_at?: true
  }

  export type Kyc_verification_eventsMaxAggregateInputType = {
    id?: true
    record_id?: true
    type?: true
    review_status?: true
    review_result?: true
    inspection_id?: true
    event_timestamp?: true
    created_at?: true
  }

  export type Kyc_verification_eventsCountAggregateInputType = {
    id?: true
    record_id?: true
    type?: true
    review_status?: true
    review_result?: true
    inspection_id?: true
    event_data?: true
    event_timestamp?: true
    created_at?: true
    _all?: true
  }

  export type Kyc_verification_eventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_verification_events to aggregate.
     */
    where?: kyc_verification_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_verification_events to fetch.
     */
    orderBy?: kyc_verification_eventsOrderByWithRelationInput | kyc_verification_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kyc_verification_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_verification_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_verification_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kyc_verification_events
    **/
    _count?: true | Kyc_verification_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kyc_verification_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kyc_verification_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kyc_verification_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kyc_verification_eventsMaxAggregateInputType
  }

  export type GetKyc_verification_eventsAggregateType<T extends Kyc_verification_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc_verification_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc_verification_events[P]>
      : GetScalarType<T[P], AggregateKyc_verification_events[P]>
  }




  export type kyc_verification_eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_verification_eventsWhereInput
    orderBy?: kyc_verification_eventsOrderByWithAggregationInput | kyc_verification_eventsOrderByWithAggregationInput[]
    by: Kyc_verification_eventsScalarFieldEnum[] | Kyc_verification_eventsScalarFieldEnum
    having?: kyc_verification_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kyc_verification_eventsCountAggregateInputType | true
    _avg?: Kyc_verification_eventsAvgAggregateInputType
    _sum?: Kyc_verification_eventsSumAggregateInputType
    _min?: Kyc_verification_eventsMinAggregateInputType
    _max?: Kyc_verification_eventsMaxAggregateInputType
  }

  export type Kyc_verification_eventsGroupByOutputType = {
    id: number
    record_id: number
    type: string
    review_status: string | null
    review_result: string | null
    inspection_id: string | null
    event_data: JsonValue | null
    event_timestamp: Date
    created_at: Date
    _count: Kyc_verification_eventsCountAggregateOutputType | null
    _avg: Kyc_verification_eventsAvgAggregateOutputType | null
    _sum: Kyc_verification_eventsSumAggregateOutputType | null
    _min: Kyc_verification_eventsMinAggregateOutputType | null
    _max: Kyc_verification_eventsMaxAggregateOutputType | null
  }

  type GetKyc_verification_eventsGroupByPayload<T extends kyc_verification_eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kyc_verification_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kyc_verification_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kyc_verification_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Kyc_verification_eventsGroupByOutputType[P]>
        }
      >
    >


  export type kyc_verification_eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    type?: boolean
    review_status?: boolean
    review_result?: boolean
    inspection_id?: boolean
    event_data?: boolean
    event_timestamp?: boolean
    created_at?: boolean
    kyc_complete_records?: boolean | kyc_complete_recordsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc_verification_events"]>


  export type kyc_verification_eventsSelectScalar = {
    id?: boolean
    record_id?: boolean
    type?: boolean
    review_status?: boolean
    review_result?: boolean
    inspection_id?: boolean
    event_data?: boolean
    event_timestamp?: boolean
    created_at?: boolean
  }

  export type kyc_verification_eventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_complete_records?: boolean | kyc_complete_recordsDefaultArgs<ExtArgs>
  }

  export type $kyc_verification_eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kyc_verification_events"
    objects: {
      kyc_complete_records: Prisma.$kyc_complete_recordsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      record_id: number
      type: string
      review_status: string | null
      review_result: string | null
      inspection_id: string | null
      event_data: Prisma.JsonValue | null
      event_timestamp: Date
      created_at: Date
    }, ExtArgs["result"]["kyc_verification_events"]>
    composites: {}
  }

  type kyc_verification_eventsGetPayload<S extends boolean | null | undefined | kyc_verification_eventsDefaultArgs> = $Result.GetResult<Prisma.$kyc_verification_eventsPayload, S>

  type kyc_verification_eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kyc_verification_eventsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kyc_verification_eventsCountAggregateInputType | true
    }

  export interface kyc_verification_eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kyc_verification_events'], meta: { name: 'kyc_verification_events' } }
    /**
     * Find zero or one Kyc_verification_events that matches the filter.
     * @param {kyc_verification_eventsFindUniqueArgs} args - Arguments to find a Kyc_verification_events
     * @example
     * // Get one Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kyc_verification_eventsFindUniqueArgs>(args: SelectSubset<T, kyc_verification_eventsFindUniqueArgs<ExtArgs>>): Prisma__kyc_verification_eventsClient<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kyc_verification_events that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kyc_verification_eventsFindUniqueOrThrowArgs} args - Arguments to find a Kyc_verification_events
     * @example
     * // Get one Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kyc_verification_eventsFindUniqueOrThrowArgs>(args: SelectSubset<T, kyc_verification_eventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kyc_verification_eventsClient<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kyc_verification_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_eventsFindFirstArgs} args - Arguments to find a Kyc_verification_events
     * @example
     * // Get one Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kyc_verification_eventsFindFirstArgs>(args?: SelectSubset<T, kyc_verification_eventsFindFirstArgs<ExtArgs>>): Prisma__kyc_verification_eventsClient<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kyc_verification_events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_eventsFindFirstOrThrowArgs} args - Arguments to find a Kyc_verification_events
     * @example
     * // Get one Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kyc_verification_eventsFindFirstOrThrowArgs>(args?: SelectSubset<T, kyc_verification_eventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__kyc_verification_eventsClient<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kyc_verification_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_eventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.findMany()
     * 
     * // Get first 10 Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kyc_verification_eventsWithIdOnly = await prisma.kyc_verification_events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kyc_verification_eventsFindManyArgs>(args?: SelectSubset<T, kyc_verification_eventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kyc_verification_events.
     * @param {kyc_verification_eventsCreateArgs} args - Arguments to create a Kyc_verification_events.
     * @example
     * // Create one Kyc_verification_events
     * const Kyc_verification_events = await prisma.kyc_verification_events.create({
     *   data: {
     *     // ... data to create a Kyc_verification_events
     *   }
     * })
     * 
     */
    create<T extends kyc_verification_eventsCreateArgs>(args: SelectSubset<T, kyc_verification_eventsCreateArgs<ExtArgs>>): Prisma__kyc_verification_eventsClient<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kyc_verification_events.
     * @param {kyc_verification_eventsCreateManyArgs} args - Arguments to create many Kyc_verification_events.
     * @example
     * // Create many Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kyc_verification_eventsCreateManyArgs>(args?: SelectSubset<T, kyc_verification_eventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kyc_verification_events.
     * @param {kyc_verification_eventsDeleteArgs} args - Arguments to delete one Kyc_verification_events.
     * @example
     * // Delete one Kyc_verification_events
     * const Kyc_verification_events = await prisma.kyc_verification_events.delete({
     *   where: {
     *     // ... filter to delete one Kyc_verification_events
     *   }
     * })
     * 
     */
    delete<T extends kyc_verification_eventsDeleteArgs>(args: SelectSubset<T, kyc_verification_eventsDeleteArgs<ExtArgs>>): Prisma__kyc_verification_eventsClient<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kyc_verification_events.
     * @param {kyc_verification_eventsUpdateArgs} args - Arguments to update one Kyc_verification_events.
     * @example
     * // Update one Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kyc_verification_eventsUpdateArgs>(args: SelectSubset<T, kyc_verification_eventsUpdateArgs<ExtArgs>>): Prisma__kyc_verification_eventsClient<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kyc_verification_events.
     * @param {kyc_verification_eventsDeleteManyArgs} args - Arguments to filter Kyc_verification_events to delete.
     * @example
     * // Delete a few Kyc_verification_events
     * const { count } = await prisma.kyc_verification_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kyc_verification_eventsDeleteManyArgs>(args?: SelectSubset<T, kyc_verification_eventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kyc_verification_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kyc_verification_eventsUpdateManyArgs>(args: SelectSubset<T, kyc_verification_eventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kyc_verification_events.
     * @param {kyc_verification_eventsUpsertArgs} args - Arguments to update or create a Kyc_verification_events.
     * @example
     * // Update or create a Kyc_verification_events
     * const kyc_verification_events = await prisma.kyc_verification_events.upsert({
     *   create: {
     *     // ... data to create a Kyc_verification_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc_verification_events we want to update
     *   }
     * })
     */
    upsert<T extends kyc_verification_eventsUpsertArgs>(args: SelectSubset<T, kyc_verification_eventsUpsertArgs<ExtArgs>>): Prisma__kyc_verification_eventsClient<$Result.GetResult<Prisma.$kyc_verification_eventsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kyc_verification_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_eventsCountArgs} args - Arguments to filter Kyc_verification_events to count.
     * @example
     * // Count the number of Kyc_verification_events
     * const count = await prisma.kyc_verification_events.count({
     *   where: {
     *     // ... the filter for the Kyc_verification_events we want to count
     *   }
     * })
    **/
    count<T extends kyc_verification_eventsCountArgs>(
      args?: Subset<T, kyc_verification_eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kyc_verification_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc_verification_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kyc_verification_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kyc_verification_eventsAggregateArgs>(args: Subset<T, Kyc_verification_eventsAggregateArgs>): Prisma.PrismaPromise<GetKyc_verification_eventsAggregateType<T>>

    /**
     * Group by Kyc_verification_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kyc_verification_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kyc_verification_eventsGroupByArgs['orderBy'] }
        : { orderBy?: kyc_verification_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kyc_verification_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKyc_verification_eventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kyc_verification_events model
   */
  readonly fields: kyc_verification_eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kyc_verification_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kyc_verification_eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_complete_records<T extends kyc_complete_recordsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kyc_complete_recordsDefaultArgs<ExtArgs>>): Prisma__kyc_complete_recordsClient<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kyc_verification_events model
   */ 
  interface kyc_verification_eventsFieldRefs {
    readonly id: FieldRef<"kyc_verification_events", 'Int'>
    readonly record_id: FieldRef<"kyc_verification_events", 'Int'>
    readonly type: FieldRef<"kyc_verification_events", 'String'>
    readonly review_status: FieldRef<"kyc_verification_events", 'String'>
    readonly review_result: FieldRef<"kyc_verification_events", 'String'>
    readonly inspection_id: FieldRef<"kyc_verification_events", 'String'>
    readonly event_data: FieldRef<"kyc_verification_events", 'Json'>
    readonly event_timestamp: FieldRef<"kyc_verification_events", 'DateTime'>
    readonly created_at: FieldRef<"kyc_verification_events", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * kyc_verification_events findUnique
   */
  export type kyc_verification_eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_events to fetch.
     */
    where: kyc_verification_eventsWhereUniqueInput
  }

  /**
   * kyc_verification_events findUniqueOrThrow
   */
  export type kyc_verification_eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_events to fetch.
     */
    where: kyc_verification_eventsWhereUniqueInput
  }

  /**
   * kyc_verification_events findFirst
   */
  export type kyc_verification_eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_events to fetch.
     */
    where?: kyc_verification_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_verification_events to fetch.
     */
    orderBy?: kyc_verification_eventsOrderByWithRelationInput | kyc_verification_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_verification_events.
     */
    cursor?: kyc_verification_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_verification_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_verification_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_verification_events.
     */
    distinct?: Kyc_verification_eventsScalarFieldEnum | Kyc_verification_eventsScalarFieldEnum[]
  }

  /**
   * kyc_verification_events findFirstOrThrow
   */
  export type kyc_verification_eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_events to fetch.
     */
    where?: kyc_verification_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_verification_events to fetch.
     */
    orderBy?: kyc_verification_eventsOrderByWithRelationInput | kyc_verification_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_verification_events.
     */
    cursor?: kyc_verification_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_verification_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_verification_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_verification_events.
     */
    distinct?: Kyc_verification_eventsScalarFieldEnum | Kyc_verification_eventsScalarFieldEnum[]
  }

  /**
   * kyc_verification_events findMany
   */
  export type kyc_verification_eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_events to fetch.
     */
    where?: kyc_verification_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_verification_events to fetch.
     */
    orderBy?: kyc_verification_eventsOrderByWithRelationInput | kyc_verification_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kyc_verification_events.
     */
    cursor?: kyc_verification_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_verification_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_verification_events.
     */
    skip?: number
    distinct?: Kyc_verification_eventsScalarFieldEnum | Kyc_verification_eventsScalarFieldEnum[]
  }

  /**
   * kyc_verification_events create
   */
  export type kyc_verification_eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    /**
     * The data needed to create a kyc_verification_events.
     */
    data: XOR<kyc_verification_eventsCreateInput, kyc_verification_eventsUncheckedCreateInput>
  }

  /**
   * kyc_verification_events createMany
   */
  export type kyc_verification_eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kyc_verification_events.
     */
    data: kyc_verification_eventsCreateManyInput | kyc_verification_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kyc_verification_events update
   */
  export type kyc_verification_eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    /**
     * The data needed to update a kyc_verification_events.
     */
    data: XOR<kyc_verification_eventsUpdateInput, kyc_verification_eventsUncheckedUpdateInput>
    /**
     * Choose, which kyc_verification_events to update.
     */
    where: kyc_verification_eventsWhereUniqueInput
  }

  /**
   * kyc_verification_events updateMany
   */
  export type kyc_verification_eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kyc_verification_events.
     */
    data: XOR<kyc_verification_eventsUpdateManyMutationInput, kyc_verification_eventsUncheckedUpdateManyInput>
    /**
     * Filter which kyc_verification_events to update
     */
    where?: kyc_verification_eventsWhereInput
  }

  /**
   * kyc_verification_events upsert
   */
  export type kyc_verification_eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    /**
     * The filter to search for the kyc_verification_events to update in case it exists.
     */
    where: kyc_verification_eventsWhereUniqueInput
    /**
     * In case the kyc_verification_events found by the `where` argument doesn't exist, create a new kyc_verification_events with this data.
     */
    create: XOR<kyc_verification_eventsCreateInput, kyc_verification_eventsUncheckedCreateInput>
    /**
     * In case the kyc_verification_events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kyc_verification_eventsUpdateInput, kyc_verification_eventsUncheckedUpdateInput>
  }

  /**
   * kyc_verification_events delete
   */
  export type kyc_verification_eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
    /**
     * Filter which kyc_verification_events to delete.
     */
    where: kyc_verification_eventsWhereUniqueInput
  }

  /**
   * kyc_verification_events deleteMany
   */
  export type kyc_verification_eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_verification_events to delete
     */
    where?: kyc_verification_eventsWhereInput
  }

  /**
   * kyc_verification_events without action
   */
  export type kyc_verification_eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_events
     */
    select?: kyc_verification_eventsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_eventsInclude<ExtArgs> | null
  }


  /**
   * Model kyc_verification_history
   */

  export type AggregateKyc_verification_history = {
    _count: Kyc_verification_historyCountAggregateOutputType | null
    _avg: Kyc_verification_historyAvgAggregateOutputType | null
    _sum: Kyc_verification_historySumAggregateOutputType | null
    _min: Kyc_verification_historyMinAggregateOutputType | null
    _max: Kyc_verification_historyMaxAggregateOutputType | null
  }

  export type Kyc_verification_historyAvgAggregateOutputType = {
    id: number | null
  }

  export type Kyc_verification_historySumAggregateOutputType = {
    id: number | null
  }

  export type Kyc_verification_historyMinAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    type: string | null
    review_status: string | null
    review_result: string | null
    review_answer: string | null
    reject_type: string | null
    reject_labels: string | null
    timestamp: Date | null
    created_at: Date | null
  }

  export type Kyc_verification_historyMaxAggregateOutputType = {
    id: number | null
    applicant_id: string | null
    type: string | null
    review_status: string | null
    review_result: string | null
    review_answer: string | null
    reject_type: string | null
    reject_labels: string | null
    timestamp: Date | null
    created_at: Date | null
  }

  export type Kyc_verification_historyCountAggregateOutputType = {
    id: number
    applicant_id: number
    type: number
    review_status: number
    review_result: number
    review_answer: number
    reject_type: number
    reject_labels: number
    timestamp: number
    created_at: number
    _all: number
  }


  export type Kyc_verification_historyAvgAggregateInputType = {
    id?: true
  }

  export type Kyc_verification_historySumAggregateInputType = {
    id?: true
  }

  export type Kyc_verification_historyMinAggregateInputType = {
    id?: true
    applicant_id?: true
    type?: true
    review_status?: true
    review_result?: true
    review_answer?: true
    reject_type?: true
    reject_labels?: true
    timestamp?: true
    created_at?: true
  }

  export type Kyc_verification_historyMaxAggregateInputType = {
    id?: true
    applicant_id?: true
    type?: true
    review_status?: true
    review_result?: true
    review_answer?: true
    reject_type?: true
    reject_labels?: true
    timestamp?: true
    created_at?: true
  }

  export type Kyc_verification_historyCountAggregateInputType = {
    id?: true
    applicant_id?: true
    type?: true
    review_status?: true
    review_result?: true
    review_answer?: true
    reject_type?: true
    reject_labels?: true
    timestamp?: true
    created_at?: true
    _all?: true
  }

  export type Kyc_verification_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_verification_history to aggregate.
     */
    where?: kyc_verification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_verification_histories to fetch.
     */
    orderBy?: kyc_verification_historyOrderByWithRelationInput | kyc_verification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: kyc_verification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_verification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_verification_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned kyc_verification_histories
    **/
    _count?: true | Kyc_verification_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Kyc_verification_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Kyc_verification_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Kyc_verification_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Kyc_verification_historyMaxAggregateInputType
  }

  export type GetKyc_verification_historyAggregateType<T extends Kyc_verification_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateKyc_verification_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKyc_verification_history[P]>
      : GetScalarType<T[P], AggregateKyc_verification_history[P]>
  }




  export type kyc_verification_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: kyc_verification_historyWhereInput
    orderBy?: kyc_verification_historyOrderByWithAggregationInput | kyc_verification_historyOrderByWithAggregationInput[]
    by: Kyc_verification_historyScalarFieldEnum[] | Kyc_verification_historyScalarFieldEnum
    having?: kyc_verification_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Kyc_verification_historyCountAggregateInputType | true
    _avg?: Kyc_verification_historyAvgAggregateInputType
    _sum?: Kyc_verification_historySumAggregateInputType
    _min?: Kyc_verification_historyMinAggregateInputType
    _max?: Kyc_verification_historyMaxAggregateInputType
  }

  export type Kyc_verification_historyGroupByOutputType = {
    id: number
    applicant_id: string
    type: string
    review_status: string
    review_result: string | null
    review_answer: string | null
    reject_type: string | null
    reject_labels: string | null
    timestamp: Date
    created_at: Date
    _count: Kyc_verification_historyCountAggregateOutputType | null
    _avg: Kyc_verification_historyAvgAggregateOutputType | null
    _sum: Kyc_verification_historySumAggregateOutputType | null
    _min: Kyc_verification_historyMinAggregateOutputType | null
    _max: Kyc_verification_historyMaxAggregateOutputType | null
  }

  type GetKyc_verification_historyGroupByPayload<T extends kyc_verification_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Kyc_verification_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Kyc_verification_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Kyc_verification_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Kyc_verification_historyGroupByOutputType[P]>
        }
      >
    >


  export type kyc_verification_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicant_id?: boolean
    type?: boolean
    review_status?: boolean
    review_result?: boolean
    review_answer?: boolean
    reject_type?: boolean
    reject_labels?: boolean
    timestamp?: boolean
    created_at?: boolean
    kyc_applicants?: boolean | kyc_applicantsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kyc_verification_history"]>


  export type kyc_verification_historySelectScalar = {
    id?: boolean
    applicant_id?: boolean
    type?: boolean
    review_status?: boolean
    review_result?: boolean
    review_answer?: boolean
    reject_type?: boolean
    reject_labels?: boolean
    timestamp?: boolean
    created_at?: boolean
  }

  export type kyc_verification_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc_applicants?: boolean | kyc_applicantsDefaultArgs<ExtArgs>
  }

  export type $kyc_verification_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "kyc_verification_history"
    objects: {
      kyc_applicants: Prisma.$kyc_applicantsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      applicant_id: string
      type: string
      review_status: string
      review_result: string | null
      review_answer: string | null
      reject_type: string | null
      reject_labels: string | null
      timestamp: Date
      created_at: Date
    }, ExtArgs["result"]["kyc_verification_history"]>
    composites: {}
  }

  type kyc_verification_historyGetPayload<S extends boolean | null | undefined | kyc_verification_historyDefaultArgs> = $Result.GetResult<Prisma.$kyc_verification_historyPayload, S>

  type kyc_verification_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<kyc_verification_historyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Kyc_verification_historyCountAggregateInputType | true
    }

  export interface kyc_verification_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['kyc_verification_history'], meta: { name: 'kyc_verification_history' } }
    /**
     * Find zero or one Kyc_verification_history that matches the filter.
     * @param {kyc_verification_historyFindUniqueArgs} args - Arguments to find a Kyc_verification_history
     * @example
     * // Get one Kyc_verification_history
     * const kyc_verification_history = await prisma.kyc_verification_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends kyc_verification_historyFindUniqueArgs>(args: SelectSubset<T, kyc_verification_historyFindUniqueArgs<ExtArgs>>): Prisma__kyc_verification_historyClient<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kyc_verification_history that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {kyc_verification_historyFindUniqueOrThrowArgs} args - Arguments to find a Kyc_verification_history
     * @example
     * // Get one Kyc_verification_history
     * const kyc_verification_history = await prisma.kyc_verification_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends kyc_verification_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, kyc_verification_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__kyc_verification_historyClient<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kyc_verification_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_historyFindFirstArgs} args - Arguments to find a Kyc_verification_history
     * @example
     * // Get one Kyc_verification_history
     * const kyc_verification_history = await prisma.kyc_verification_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends kyc_verification_historyFindFirstArgs>(args?: SelectSubset<T, kyc_verification_historyFindFirstArgs<ExtArgs>>): Prisma__kyc_verification_historyClient<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kyc_verification_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_historyFindFirstOrThrowArgs} args - Arguments to find a Kyc_verification_history
     * @example
     * // Get one Kyc_verification_history
     * const kyc_verification_history = await prisma.kyc_verification_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends kyc_verification_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, kyc_verification_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__kyc_verification_historyClient<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kyc_verification_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kyc_verification_histories
     * const kyc_verification_histories = await prisma.kyc_verification_history.findMany()
     * 
     * // Get first 10 Kyc_verification_histories
     * const kyc_verification_histories = await prisma.kyc_verification_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kyc_verification_historyWithIdOnly = await prisma.kyc_verification_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends kyc_verification_historyFindManyArgs>(args?: SelectSubset<T, kyc_verification_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kyc_verification_history.
     * @param {kyc_verification_historyCreateArgs} args - Arguments to create a Kyc_verification_history.
     * @example
     * // Create one Kyc_verification_history
     * const Kyc_verification_history = await prisma.kyc_verification_history.create({
     *   data: {
     *     // ... data to create a Kyc_verification_history
     *   }
     * })
     * 
     */
    create<T extends kyc_verification_historyCreateArgs>(args: SelectSubset<T, kyc_verification_historyCreateArgs<ExtArgs>>): Prisma__kyc_verification_historyClient<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kyc_verification_histories.
     * @param {kyc_verification_historyCreateManyArgs} args - Arguments to create many Kyc_verification_histories.
     * @example
     * // Create many Kyc_verification_histories
     * const kyc_verification_history = await prisma.kyc_verification_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends kyc_verification_historyCreateManyArgs>(args?: SelectSubset<T, kyc_verification_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Kyc_verification_history.
     * @param {kyc_verification_historyDeleteArgs} args - Arguments to delete one Kyc_verification_history.
     * @example
     * // Delete one Kyc_verification_history
     * const Kyc_verification_history = await prisma.kyc_verification_history.delete({
     *   where: {
     *     // ... filter to delete one Kyc_verification_history
     *   }
     * })
     * 
     */
    delete<T extends kyc_verification_historyDeleteArgs>(args: SelectSubset<T, kyc_verification_historyDeleteArgs<ExtArgs>>): Prisma__kyc_verification_historyClient<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kyc_verification_history.
     * @param {kyc_verification_historyUpdateArgs} args - Arguments to update one Kyc_verification_history.
     * @example
     * // Update one Kyc_verification_history
     * const kyc_verification_history = await prisma.kyc_verification_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends kyc_verification_historyUpdateArgs>(args: SelectSubset<T, kyc_verification_historyUpdateArgs<ExtArgs>>): Prisma__kyc_verification_historyClient<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kyc_verification_histories.
     * @param {kyc_verification_historyDeleteManyArgs} args - Arguments to filter Kyc_verification_histories to delete.
     * @example
     * // Delete a few Kyc_verification_histories
     * const { count } = await prisma.kyc_verification_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends kyc_verification_historyDeleteManyArgs>(args?: SelectSubset<T, kyc_verification_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kyc_verification_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kyc_verification_histories
     * const kyc_verification_history = await prisma.kyc_verification_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends kyc_verification_historyUpdateManyArgs>(args: SelectSubset<T, kyc_verification_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kyc_verification_history.
     * @param {kyc_verification_historyUpsertArgs} args - Arguments to update or create a Kyc_verification_history.
     * @example
     * // Update or create a Kyc_verification_history
     * const kyc_verification_history = await prisma.kyc_verification_history.upsert({
     *   create: {
     *     // ... data to create a Kyc_verification_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kyc_verification_history we want to update
     *   }
     * })
     */
    upsert<T extends kyc_verification_historyUpsertArgs>(args: SelectSubset<T, kyc_verification_historyUpsertArgs<ExtArgs>>): Prisma__kyc_verification_historyClient<$Result.GetResult<Prisma.$kyc_verification_historyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kyc_verification_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_historyCountArgs} args - Arguments to filter Kyc_verification_histories to count.
     * @example
     * // Count the number of Kyc_verification_histories
     * const count = await prisma.kyc_verification_history.count({
     *   where: {
     *     // ... the filter for the Kyc_verification_histories we want to count
     *   }
     * })
    **/
    count<T extends kyc_verification_historyCountArgs>(
      args?: Subset<T, kyc_verification_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Kyc_verification_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kyc_verification_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Kyc_verification_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Kyc_verification_historyAggregateArgs>(args: Subset<T, Kyc_verification_historyAggregateArgs>): Prisma.PrismaPromise<GetKyc_verification_historyAggregateType<T>>

    /**
     * Group by Kyc_verification_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {kyc_verification_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends kyc_verification_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: kyc_verification_historyGroupByArgs['orderBy'] }
        : { orderBy?: kyc_verification_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, kyc_verification_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKyc_verification_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the kyc_verification_history model
   */
  readonly fields: kyc_verification_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for kyc_verification_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__kyc_verification_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc_applicants<T extends kyc_applicantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, kyc_applicantsDefaultArgs<ExtArgs>>): Prisma__kyc_applicantsClient<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the kyc_verification_history model
   */ 
  interface kyc_verification_historyFieldRefs {
    readonly id: FieldRef<"kyc_verification_history", 'Int'>
    readonly applicant_id: FieldRef<"kyc_verification_history", 'String'>
    readonly type: FieldRef<"kyc_verification_history", 'String'>
    readonly review_status: FieldRef<"kyc_verification_history", 'String'>
    readonly review_result: FieldRef<"kyc_verification_history", 'String'>
    readonly review_answer: FieldRef<"kyc_verification_history", 'String'>
    readonly reject_type: FieldRef<"kyc_verification_history", 'String'>
    readonly reject_labels: FieldRef<"kyc_verification_history", 'String'>
    readonly timestamp: FieldRef<"kyc_verification_history", 'DateTime'>
    readonly created_at: FieldRef<"kyc_verification_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * kyc_verification_history findUnique
   */
  export type kyc_verification_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_history to fetch.
     */
    where: kyc_verification_historyWhereUniqueInput
  }

  /**
   * kyc_verification_history findUniqueOrThrow
   */
  export type kyc_verification_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_history to fetch.
     */
    where: kyc_verification_historyWhereUniqueInput
  }

  /**
   * kyc_verification_history findFirst
   */
  export type kyc_verification_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_history to fetch.
     */
    where?: kyc_verification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_verification_histories to fetch.
     */
    orderBy?: kyc_verification_historyOrderByWithRelationInput | kyc_verification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_verification_histories.
     */
    cursor?: kyc_verification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_verification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_verification_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_verification_histories.
     */
    distinct?: Kyc_verification_historyScalarFieldEnum | Kyc_verification_historyScalarFieldEnum[]
  }

  /**
   * kyc_verification_history findFirstOrThrow
   */
  export type kyc_verification_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_history to fetch.
     */
    where?: kyc_verification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_verification_histories to fetch.
     */
    orderBy?: kyc_verification_historyOrderByWithRelationInput | kyc_verification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for kyc_verification_histories.
     */
    cursor?: kyc_verification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_verification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_verification_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of kyc_verification_histories.
     */
    distinct?: Kyc_verification_historyScalarFieldEnum | Kyc_verification_historyScalarFieldEnum[]
  }

  /**
   * kyc_verification_history findMany
   */
  export type kyc_verification_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    /**
     * Filter, which kyc_verification_histories to fetch.
     */
    where?: kyc_verification_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of kyc_verification_histories to fetch.
     */
    orderBy?: kyc_verification_historyOrderByWithRelationInput | kyc_verification_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing kyc_verification_histories.
     */
    cursor?: kyc_verification_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` kyc_verification_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` kyc_verification_histories.
     */
    skip?: number
    distinct?: Kyc_verification_historyScalarFieldEnum | Kyc_verification_historyScalarFieldEnum[]
  }

  /**
   * kyc_verification_history create
   */
  export type kyc_verification_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a kyc_verification_history.
     */
    data: XOR<kyc_verification_historyCreateInput, kyc_verification_historyUncheckedCreateInput>
  }

  /**
   * kyc_verification_history createMany
   */
  export type kyc_verification_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many kyc_verification_histories.
     */
    data: kyc_verification_historyCreateManyInput | kyc_verification_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * kyc_verification_history update
   */
  export type kyc_verification_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a kyc_verification_history.
     */
    data: XOR<kyc_verification_historyUpdateInput, kyc_verification_historyUncheckedUpdateInput>
    /**
     * Choose, which kyc_verification_history to update.
     */
    where: kyc_verification_historyWhereUniqueInput
  }

  /**
   * kyc_verification_history updateMany
   */
  export type kyc_verification_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update kyc_verification_histories.
     */
    data: XOR<kyc_verification_historyUpdateManyMutationInput, kyc_verification_historyUncheckedUpdateManyInput>
    /**
     * Filter which kyc_verification_histories to update
     */
    where?: kyc_verification_historyWhereInput
  }

  /**
   * kyc_verification_history upsert
   */
  export type kyc_verification_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the kyc_verification_history to update in case it exists.
     */
    where: kyc_verification_historyWhereUniqueInput
    /**
     * In case the kyc_verification_history found by the `where` argument doesn't exist, create a new kyc_verification_history with this data.
     */
    create: XOR<kyc_verification_historyCreateInput, kyc_verification_historyUncheckedCreateInput>
    /**
     * In case the kyc_verification_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<kyc_verification_historyUpdateInput, kyc_verification_historyUncheckedUpdateInput>
  }

  /**
   * kyc_verification_history delete
   */
  export type kyc_verification_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
    /**
     * Filter which kyc_verification_history to delete.
     */
    where: kyc_verification_historyWhereUniqueInput
  }

  /**
   * kyc_verification_history deleteMany
   */
  export type kyc_verification_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which kyc_verification_histories to delete
     */
    where?: kyc_verification_historyWhereInput
  }

  /**
   * kyc_verification_history without action
   */
  export type kyc_verification_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_verification_history
     */
    select?: kyc_verification_historySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_verification_historyInclude<ExtArgs> | null
  }


  /**
   * Model refreshtoken
   */

  export type AggregateRefreshtoken = {
    _count: RefreshtokenCountAggregateOutputType | null
    _avg: RefreshtokenAvgAggregateOutputType | null
    _sum: RefreshtokenSumAggregateOutputType | null
    _min: RefreshtokenMinAggregateOutputType | null
    _max: RefreshtokenMaxAggregateOutputType | null
  }

  export type RefreshtokenAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type RefreshtokenSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type RefreshtokenMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    token: string | null
    expires_at: Date | null
    created_at: Date | null
    device_info: string | null
  }

  export type RefreshtokenMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    token: string | null
    expires_at: Date | null
    created_at: Date | null
    device_info: string | null
  }

  export type RefreshtokenCountAggregateOutputType = {
    id: number
    user_id: number
    token: number
    expires_at: number
    created_at: number
    device_info: number
    _all: number
  }


  export type RefreshtokenAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type RefreshtokenSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type RefreshtokenMinAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    device_info?: true
  }

  export type RefreshtokenMaxAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    device_info?: true
  }

  export type RefreshtokenCountAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    device_info?: true
    _all?: true
  }

  export type RefreshtokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refreshtoken to aggregate.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned refreshtokens
    **/
    _count?: true | RefreshtokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshtokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshtokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshtokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshtokenMaxAggregateInputType
  }

  export type GetRefreshtokenAggregateType<T extends RefreshtokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshtoken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshtoken[P]>
      : GetScalarType<T[P], AggregateRefreshtoken[P]>
  }




  export type refreshtokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refreshtokenWhereInput
    orderBy?: refreshtokenOrderByWithAggregationInput | refreshtokenOrderByWithAggregationInput[]
    by: RefreshtokenScalarFieldEnum[] | RefreshtokenScalarFieldEnum
    having?: refreshtokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshtokenCountAggregateInputType | true
    _avg?: RefreshtokenAvgAggregateInputType
    _sum?: RefreshtokenSumAggregateInputType
    _min?: RefreshtokenMinAggregateInputType
    _max?: RefreshtokenMaxAggregateInputType
  }

  export type RefreshtokenGroupByOutputType = {
    id: number
    user_id: number
    token: string
    expires_at: Date
    created_at: Date
    device_info: string | null
    _count: RefreshtokenCountAggregateOutputType | null
    _avg: RefreshtokenAvgAggregateOutputType | null
    _sum: RefreshtokenSumAggregateOutputType | null
    _min: RefreshtokenMinAggregateOutputType | null
    _max: RefreshtokenMaxAggregateOutputType | null
  }

  type GetRefreshtokenGroupByPayload<T extends refreshtokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshtokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshtokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshtokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshtokenGroupByOutputType[P]>
        }
      >
    >


  export type refreshtokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
    device_info?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshtoken"]>


  export type refreshtokenSelectScalar = {
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
    device_info?: boolean
  }

  export type refreshtokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $refreshtokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "refreshtoken"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      token: string
      expires_at: Date
      created_at: Date
      device_info: string | null
    }, ExtArgs["result"]["refreshtoken"]>
    composites: {}
  }

  type refreshtokenGetPayload<S extends boolean | null | undefined | refreshtokenDefaultArgs> = $Result.GetResult<Prisma.$refreshtokenPayload, S>

  type refreshtokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<refreshtokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshtokenCountAggregateInputType | true
    }

  export interface refreshtokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['refreshtoken'], meta: { name: 'refreshtoken' } }
    /**
     * Find zero or one Refreshtoken that matches the filter.
     * @param {refreshtokenFindUniqueArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends refreshtokenFindUniqueArgs>(args: SelectSubset<T, refreshtokenFindUniqueArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Refreshtoken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {refreshtokenFindUniqueOrThrowArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends refreshtokenFindUniqueOrThrowArgs>(args: SelectSubset<T, refreshtokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Refreshtoken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindFirstArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends refreshtokenFindFirstArgs>(args?: SelectSubset<T, refreshtokenFindFirstArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Refreshtoken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindFirstOrThrowArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends refreshtokenFindFirstOrThrowArgs>(args?: SelectSubset<T, refreshtokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Refreshtokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refreshtokens
     * const refreshtokens = await prisma.refreshtoken.findMany()
     * 
     * // Get first 10 Refreshtokens
     * const refreshtokens = await prisma.refreshtoken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshtokenWithIdOnly = await prisma.refreshtoken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends refreshtokenFindManyArgs>(args?: SelectSubset<T, refreshtokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Refreshtoken.
     * @param {refreshtokenCreateArgs} args - Arguments to create a Refreshtoken.
     * @example
     * // Create one Refreshtoken
     * const Refreshtoken = await prisma.refreshtoken.create({
     *   data: {
     *     // ... data to create a Refreshtoken
     *   }
     * })
     * 
     */
    create<T extends refreshtokenCreateArgs>(args: SelectSubset<T, refreshtokenCreateArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Refreshtokens.
     * @param {refreshtokenCreateManyArgs} args - Arguments to create many Refreshtokens.
     * @example
     * // Create many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends refreshtokenCreateManyArgs>(args?: SelectSubset<T, refreshtokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Refreshtoken.
     * @param {refreshtokenDeleteArgs} args - Arguments to delete one Refreshtoken.
     * @example
     * // Delete one Refreshtoken
     * const Refreshtoken = await prisma.refreshtoken.delete({
     *   where: {
     *     // ... filter to delete one Refreshtoken
     *   }
     * })
     * 
     */
    delete<T extends refreshtokenDeleteArgs>(args: SelectSubset<T, refreshtokenDeleteArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Refreshtoken.
     * @param {refreshtokenUpdateArgs} args - Arguments to update one Refreshtoken.
     * @example
     * // Update one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends refreshtokenUpdateArgs>(args: SelectSubset<T, refreshtokenUpdateArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Refreshtokens.
     * @param {refreshtokenDeleteManyArgs} args - Arguments to filter Refreshtokens to delete.
     * @example
     * // Delete a few Refreshtokens
     * const { count } = await prisma.refreshtoken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends refreshtokenDeleteManyArgs>(args?: SelectSubset<T, refreshtokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refreshtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends refreshtokenUpdateManyArgs>(args: SelectSubset<T, refreshtokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refreshtoken.
     * @param {refreshtokenUpsertArgs} args - Arguments to update or create a Refreshtoken.
     * @example
     * // Update or create a Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.upsert({
     *   create: {
     *     // ... data to create a Refreshtoken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refreshtoken we want to update
     *   }
     * })
     */
    upsert<T extends refreshtokenUpsertArgs>(args: SelectSubset<T, refreshtokenUpsertArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Refreshtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenCountArgs} args - Arguments to filter Refreshtokens to count.
     * @example
     * // Count the number of Refreshtokens
     * const count = await prisma.refreshtoken.count({
     *   where: {
     *     // ... the filter for the Refreshtokens we want to count
     *   }
     * })
    **/
    count<T extends refreshtokenCountArgs>(
      args?: Subset<T, refreshtokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshtokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refreshtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshtokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshtokenAggregateArgs>(args: Subset<T, RefreshtokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshtokenAggregateType<T>>

    /**
     * Group by Refreshtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends refreshtokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: refreshtokenGroupByArgs['orderBy'] }
        : { orderBy?: refreshtokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, refreshtokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshtokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the refreshtoken model
   */
  readonly fields: refreshtokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for refreshtoken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__refreshtokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the refreshtoken model
   */ 
  interface refreshtokenFieldRefs {
    readonly id: FieldRef<"refreshtoken", 'Int'>
    readonly user_id: FieldRef<"refreshtoken", 'Int'>
    readonly token: FieldRef<"refreshtoken", 'String'>
    readonly expires_at: FieldRef<"refreshtoken", 'DateTime'>
    readonly created_at: FieldRef<"refreshtoken", 'DateTime'>
    readonly device_info: FieldRef<"refreshtoken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * refreshtoken findUnique
   */
  export type refreshtokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken findUniqueOrThrow
   */
  export type refreshtokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken findFirst
   */
  export type refreshtokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refreshtokens.
     */
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken findFirstOrThrow
   */
  export type refreshtokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refreshtokens.
     */
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken findMany
   */
  export type refreshtokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtokens to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken create
   */
  export type refreshtokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The data needed to create a refreshtoken.
     */
    data: XOR<refreshtokenCreateInput, refreshtokenUncheckedCreateInput>
  }

  /**
   * refreshtoken createMany
   */
  export type refreshtokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many refreshtokens.
     */
    data: refreshtokenCreateManyInput | refreshtokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * refreshtoken update
   */
  export type refreshtokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The data needed to update a refreshtoken.
     */
    data: XOR<refreshtokenUpdateInput, refreshtokenUncheckedUpdateInput>
    /**
     * Choose, which refreshtoken to update.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken updateMany
   */
  export type refreshtokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update refreshtokens.
     */
    data: XOR<refreshtokenUpdateManyMutationInput, refreshtokenUncheckedUpdateManyInput>
    /**
     * Filter which refreshtokens to update
     */
    where?: refreshtokenWhereInput
  }

  /**
   * refreshtoken upsert
   */
  export type refreshtokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The filter to search for the refreshtoken to update in case it exists.
     */
    where: refreshtokenWhereUniqueInput
    /**
     * In case the refreshtoken found by the `where` argument doesn't exist, create a new refreshtoken with this data.
     */
    create: XOR<refreshtokenCreateInput, refreshtokenUncheckedCreateInput>
    /**
     * In case the refreshtoken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<refreshtokenUpdateInput, refreshtokenUncheckedUpdateInput>
  }

  /**
   * refreshtoken delete
   */
  export type refreshtokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter which refreshtoken to delete.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken deleteMany
   */
  export type refreshtokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refreshtokens to delete
     */
    where?: refreshtokenWhereInput
  }

  /**
   * refreshtoken without action
   */
  export type refreshtokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
  }


  /**
   * Model userrole
   */

  export type AggregateUserrole = {
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  export type UserroleAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserroleSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserroleMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    role: string | null
    created_at: Date | null
  }

  export type UserroleMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    role: string | null
    created_at: Date | null
  }

  export type UserroleCountAggregateOutputType = {
    id: number
    user_id: number
    role: number
    created_at: number
    _all: number
  }


  export type UserroleAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserroleSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserroleMinAggregateInputType = {
    id?: true
    user_id?: true
    role?: true
    created_at?: true
  }

  export type UserroleMaxAggregateInputType = {
    id?: true
    user_id?: true
    role?: true
    created_at?: true
  }

  export type UserroleCountAggregateInputType = {
    id?: true
    user_id?: true
    role?: true
    created_at?: true
    _all?: true
  }

  export type UserroleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userrole to aggregate.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userroles
    **/
    _count?: true | UserroleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserroleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserroleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserroleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserroleMaxAggregateInputType
  }

  export type GetUserroleAggregateType<T extends UserroleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserrole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserrole[P]>
      : GetScalarType<T[P], AggregateUserrole[P]>
  }




  export type userroleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithAggregationInput | userroleOrderByWithAggregationInput[]
    by: UserroleScalarFieldEnum[] | UserroleScalarFieldEnum
    having?: userroleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserroleCountAggregateInputType | true
    _avg?: UserroleAvgAggregateInputType
    _sum?: UserroleSumAggregateInputType
    _min?: UserroleMinAggregateInputType
    _max?: UserroleMaxAggregateInputType
  }

  export type UserroleGroupByOutputType = {
    id: number
    user_id: number
    role: string
    created_at: Date
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  type GetUserroleGroupByPayload<T extends userroleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserroleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserroleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserroleGroupByOutputType[P]>
            : GetScalarType<T[P], UserroleGroupByOutputType[P]>
        }
      >
    >


  export type userroleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    role?: boolean
    created_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>


  export type userroleSelectScalar = {
    id?: boolean
    user_id?: boolean
    role?: boolean
    created_at?: boolean
  }

  export type userroleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $userrolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userrole"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      role: string
      created_at: Date
    }, ExtArgs["result"]["userrole"]>
    composites: {}
  }

  type userroleGetPayload<S extends boolean | null | undefined | userroleDefaultArgs> = $Result.GetResult<Prisma.$userrolePayload, S>

  type userroleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userroleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserroleCountAggregateInputType | true
    }

  export interface userroleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userrole'], meta: { name: 'userrole' } }
    /**
     * Find zero or one Userrole that matches the filter.
     * @param {userroleFindUniqueArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userroleFindUniqueArgs>(args: SelectSubset<T, userroleFindUniqueArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Userrole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userroleFindUniqueOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userroleFindUniqueOrThrowArgs>(args: SelectSubset<T, userroleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Userrole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userroleFindFirstArgs>(args?: SelectSubset<T, userroleFindFirstArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Userrole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userroleFindFirstOrThrowArgs>(args?: SelectSubset<T, userroleFindFirstOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Userroles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userroles
     * const userroles = await prisma.userrole.findMany()
     * 
     * // Get first 10 Userroles
     * const userroles = await prisma.userrole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userroleWithIdOnly = await prisma.userrole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userroleFindManyArgs>(args?: SelectSubset<T, userroleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Userrole.
     * @param {userroleCreateArgs} args - Arguments to create a Userrole.
     * @example
     * // Create one Userrole
     * const Userrole = await prisma.userrole.create({
     *   data: {
     *     // ... data to create a Userrole
     *   }
     * })
     * 
     */
    create<T extends userroleCreateArgs>(args: SelectSubset<T, userroleCreateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Userroles.
     * @param {userroleCreateManyArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userroleCreateManyArgs>(args?: SelectSubset<T, userroleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userrole.
     * @param {userroleDeleteArgs} args - Arguments to delete one Userrole.
     * @example
     * // Delete one Userrole
     * const Userrole = await prisma.userrole.delete({
     *   where: {
     *     // ... filter to delete one Userrole
     *   }
     * })
     * 
     */
    delete<T extends userroleDeleteArgs>(args: SelectSubset<T, userroleDeleteArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Userrole.
     * @param {userroleUpdateArgs} args - Arguments to update one Userrole.
     * @example
     * // Update one Userrole
     * const userrole = await prisma.userrole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userroleUpdateArgs>(args: SelectSubset<T, userroleUpdateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Userroles.
     * @param {userroleDeleteManyArgs} args - Arguments to filter Userroles to delete.
     * @example
     * // Delete a few Userroles
     * const { count } = await prisma.userrole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userroleDeleteManyArgs>(args?: SelectSubset<T, userroleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userroleUpdateManyArgs>(args: SelectSubset<T, userroleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userrole.
     * @param {userroleUpsertArgs} args - Arguments to update or create a Userrole.
     * @example
     * // Update or create a Userrole
     * const userrole = await prisma.userrole.upsert({
     *   create: {
     *     // ... data to create a Userrole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userrole we want to update
     *   }
     * })
     */
    upsert<T extends userroleUpsertArgs>(args: SelectSubset<T, userroleUpsertArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleCountArgs} args - Arguments to filter Userroles to count.
     * @example
     * // Count the number of Userroles
     * const count = await prisma.userrole.count({
     *   where: {
     *     // ... the filter for the Userroles we want to count
     *   }
     * })
    **/
    count<T extends userroleCountArgs>(
      args?: Subset<T, userroleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserroleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserroleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserroleAggregateArgs>(args: Subset<T, UserroleAggregateArgs>): Prisma.PrismaPromise<GetUserroleAggregateType<T>>

    /**
     * Group by Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userroleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userroleGroupByArgs['orderBy'] }
        : { orderBy?: userroleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userroleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserroleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userrole model
   */
  readonly fields: userroleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userrole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userroleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userrole model
   */ 
  interface userroleFieldRefs {
    readonly id: FieldRef<"userrole", 'Int'>
    readonly user_id: FieldRef<"userrole", 'Int'>
    readonly role: FieldRef<"userrole", 'String'>
    readonly created_at: FieldRef<"userrole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userrole findUnique
   */
  export type userroleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findUniqueOrThrow
   */
  export type userroleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findFirst
   */
  export type userroleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findFirstOrThrow
   */
  export type userroleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findMany
   */
  export type userroleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userroles to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole create
   */
  export type userroleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to create a userrole.
     */
    data: XOR<userroleCreateInput, userroleUncheckedCreateInput>
  }

  /**
   * userrole createMany
   */
  export type userroleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userrole update
   */
  export type userroleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to update a userrole.
     */
    data: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
    /**
     * Choose, which userrole to update.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole updateMany
   */
  export type userroleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
  }

  /**
   * userrole upsert
   */
  export type userroleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The filter to search for the userrole to update in case it exists.
     */
    where: userroleWhereUniqueInput
    /**
     * In case the userrole found by the `where` argument doesn't exist, create a new userrole with this data.
     */
    create: XOR<userroleCreateInput, userroleUncheckedCreateInput>
    /**
     * In case the userrole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
  }

  /**
   * userrole delete
   */
  export type userroleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter which userrole to delete.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole deleteMany
   */
  export type userroleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroles to delete
     */
    where?: userroleWhereInput
  }

  /**
   * userrole without action
   */
  export type userroleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    created_at: Date | null
    updated_at: Date | null
    applicant_id: string | null
    is_verified: boolean | null
    verification_result: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    first_name: string | null
    last_name: string | null
    created_at: Date | null
    updated_at: Date | null
    applicant_id: string | null
    is_verified: boolean | null
    verification_result: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password: number
    first_name: number
    last_name: number
    created_at: number
    updated_at: number
    applicant_id: number
    is_verified: number
    verification_result: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    created_at?: true
    updated_at?: true
    applicant_id?: true
    is_verified?: true
    verification_result?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    created_at?: true
    updated_at?: true
    applicant_id?: true
    is_verified?: true
    verification_result?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    first_name?: true
    last_name?: true
    created_at?: true
    updated_at?: true
    applicant_id?: true
    is_verified?: true
    verification_result?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at: Date
    updated_at: Date
    applicant_id: string | null
    is_verified: boolean
    verification_result: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    applicant_id?: boolean
    is_verified?: boolean
    verification_result?: boolean
    admin?: boolean | users$adminArgs<ExtArgs>
    authprovider?: boolean | users$authproviderArgs<ExtArgs>
    didwallet?: boolean | users$didwalletArgs<ExtArgs>
    investor?: boolean | users$investorArgs<ExtArgs>
    issuer?: boolean | users$issuerArgs<ExtArgs>
    kyc_applicants?: boolean | users$kyc_applicantsArgs<ExtArgs>
    kyc_complete_records?: boolean | users$kyc_complete_recordsArgs<ExtArgs>
    kyc_documents?: boolean | users$kyc_documentsArgs<ExtArgs>
    kyc_verifications?: boolean | users$kyc_verificationsArgs<ExtArgs>
    refreshtoken?: boolean | users$refreshtokenArgs<ExtArgs>
    userrole?: boolean | users$userroleArgs<ExtArgs>
    wallet?: boolean | users$walletArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    first_name?: boolean
    last_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    applicant_id?: boolean
    is_verified?: boolean
    verification_result?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | users$adminArgs<ExtArgs>
    authprovider?: boolean | users$authproviderArgs<ExtArgs>
    didwallet?: boolean | users$didwalletArgs<ExtArgs>
    investor?: boolean | users$investorArgs<ExtArgs>
    issuer?: boolean | users$issuerArgs<ExtArgs>
    kyc_applicants?: boolean | users$kyc_applicantsArgs<ExtArgs>
    kyc_complete_records?: boolean | users$kyc_complete_recordsArgs<ExtArgs>
    kyc_documents?: boolean | users$kyc_documentsArgs<ExtArgs>
    kyc_verifications?: boolean | users$kyc_verificationsArgs<ExtArgs>
    refreshtoken?: boolean | users$refreshtokenArgs<ExtArgs>
    userrole?: boolean | users$userroleArgs<ExtArgs>
    wallet?: boolean | users$walletArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs> | null
      authprovider: Prisma.$authproviderPayload<ExtArgs>[]
      didwallet: Prisma.$didwalletPayload<ExtArgs>[]
      investor: Prisma.$investorPayload<ExtArgs> | null
      issuer: Prisma.$issuerPayload<ExtArgs> | null
      kyc_applicants: Prisma.$kyc_applicantsPayload<ExtArgs>[]
      kyc_complete_records: Prisma.$kyc_complete_recordsPayload<ExtArgs>[]
      kyc_documents: Prisma.$KycDocumentPayload<ExtArgs>[]
      kyc_verifications: Prisma.$kycVerificationPayload<ExtArgs>[]
      refreshtoken: Prisma.$refreshtokenPayload<ExtArgs>[]
      userrole: Prisma.$userrolePayload<ExtArgs>[]
      wallet: Prisma.$walletPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      first_name: string
      last_name: string
      created_at: Date
      updated_at: Date
      applicant_id: string | null
      is_verified: boolean
      verification_result: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends users$adminArgs<ExtArgs> = {}>(args?: Subset<T, users$adminArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    authprovider<T extends users$authproviderArgs<ExtArgs> = {}>(args?: Subset<T, users$authproviderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findMany"> | Null>
    didwallet<T extends users$didwalletArgs<ExtArgs> = {}>(args?: Subset<T, users$didwalletArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findMany"> | Null>
    investor<T extends users$investorArgs<ExtArgs> = {}>(args?: Subset<T, users$investorArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    issuer<T extends users$issuerArgs<ExtArgs> = {}>(args?: Subset<T, users$issuerArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    kyc_applicants<T extends users$kyc_applicantsArgs<ExtArgs> = {}>(args?: Subset<T, users$kyc_applicantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_applicantsPayload<ExtArgs>, T, "findMany"> | Null>
    kyc_complete_records<T extends users$kyc_complete_recordsArgs<ExtArgs> = {}>(args?: Subset<T, users$kyc_complete_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kyc_complete_recordsPayload<ExtArgs>, T, "findMany"> | Null>
    kyc_documents<T extends users$kyc_documentsArgs<ExtArgs> = {}>(args?: Subset<T, users$kyc_documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KycDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    kyc_verifications<T extends users$kyc_verificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$kyc_verificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$kycVerificationPayload<ExtArgs>, T, "findMany"> | Null>
    refreshtoken<T extends users$refreshtokenArgs<ExtArgs> = {}>(args?: Subset<T, users$refreshtokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findMany"> | Null>
    userrole<T extends users$userroleArgs<ExtArgs> = {}>(args?: Subset<T, users$userroleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany"> | Null>
    wallet<T extends users$walletArgs<ExtArgs> = {}>(args?: Subset<T, users$walletArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly first_name: FieldRef<"users", 'String'>
    readonly last_name: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly applicant_id: FieldRef<"users", 'String'>
    readonly is_verified: FieldRef<"users", 'Boolean'>
    readonly verification_result: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.admin
   */
  export type users$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
  }

  /**
   * users.authprovider
   */
  export type users$authproviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    where?: authproviderWhereInput
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    cursor?: authproviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthproviderScalarFieldEnum | AuthproviderScalarFieldEnum[]
  }

  /**
   * users.didwallet
   */
  export type users$didwalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    where?: didwalletWhereInput
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    cursor?: didwalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DidwalletScalarFieldEnum | DidwalletScalarFieldEnum[]
  }

  /**
   * users.investor
   */
  export type users$investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    where?: investorWhereInput
  }

  /**
   * users.issuer
   */
  export type users$issuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    where?: issuerWhereInput
  }

  /**
   * users.kyc_applicants
   */
  export type users$kyc_applicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_applicants
     */
    select?: kyc_applicantsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_applicantsInclude<ExtArgs> | null
    where?: kyc_applicantsWhereInput
    orderBy?: kyc_applicantsOrderByWithRelationInput | kyc_applicantsOrderByWithRelationInput[]
    cursor?: kyc_applicantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kyc_applicantsScalarFieldEnum | Kyc_applicantsScalarFieldEnum[]
  }

  /**
   * users.kyc_complete_records
   */
  export type users$kyc_complete_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kyc_complete_records
     */
    select?: kyc_complete_recordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kyc_complete_recordsInclude<ExtArgs> | null
    where?: kyc_complete_recordsWhereInput
    orderBy?: kyc_complete_recordsOrderByWithRelationInput | kyc_complete_recordsOrderByWithRelationInput[]
    cursor?: kyc_complete_recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Kyc_complete_recordsScalarFieldEnum | Kyc_complete_recordsScalarFieldEnum[]
  }

  /**
   * users.kyc_documents
   */
  export type users$kyc_documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KycDocument
     */
    select?: KycDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KycDocumentInclude<ExtArgs> | null
    where?: KycDocumentWhereInput
    orderBy?: KycDocumentOrderByWithRelationInput | KycDocumentOrderByWithRelationInput[]
    cursor?: KycDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KycDocumentScalarFieldEnum | KycDocumentScalarFieldEnum[]
  }

  /**
   * users.kyc_verifications
   */
  export type users$kyc_verificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the kycVerification
     */
    select?: kycVerificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: kycVerificationInclude<ExtArgs> | null
    where?: kycVerificationWhereInput
    orderBy?: kycVerificationOrderByWithRelationInput | kycVerificationOrderByWithRelationInput[]
    cursor?: kycVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KycVerificationScalarFieldEnum | KycVerificationScalarFieldEnum[]
  }

  /**
   * users.refreshtoken
   */
  export type users$refreshtokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    where?: refreshtokenWhereInput
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    cursor?: refreshtokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * users.userrole
   */
  export type users$userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * users.wallet
   */
  export type users$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    where?: walletWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    user_id: number | null
  }

  export type WalletSumAggregateOutputType = {
    user_id: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    issuer_id: string | null
    address: string | null
    chain: string | null
    type: string | null
    provider: string | null
    did: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    issuer_id: string | null
    address: string | null
    chain: string | null
    type: string | null
    provider: string | null
    did: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    user_id: number
    issuer_id: number
    address: number
    chain: number
    type: number
    provider: number
    did: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    user_id?: true
  }

  export type WalletSumAggregateInputType = {
    user_id?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    user_id?: true
    issuer_id?: true
    address?: true
    chain?: true
    type?: true
    provider?: true
    did?: true
    created_at?: true
    updated_at?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    user_id?: true
    issuer_id?: true
    address?: true
    chain?: true
    type?: true
    provider?: true
    did?: true
    created_at?: true
    updated_at?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    user_id?: true
    issuer_id?: true
    address?: true
    chain?: true
    type?: true
    provider?: true
    did?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet to aggregate.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type walletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: walletWhereInput
    orderBy?: walletOrderByWithAggregationInput | walletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: walletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    user_id: number
    issuer_id: string | null
    address: string
    chain: string
    type: string
    provider: string
    did: string | null
    created_at: Date
    updated_at: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends walletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type walletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    issuer_id?: boolean
    address?: boolean
    chain?: boolean
    type?: boolean
    provider?: boolean
    did?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    issuer?: boolean | wallet$issuerArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>


  export type walletSelectScalar = {
    id?: boolean
    user_id?: boolean
    issuer_id?: boolean
    address?: boolean
    chain?: boolean
    type?: boolean
    provider?: boolean
    did?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type walletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    issuer?: boolean | wallet$issuerArgs<ExtArgs>
  }

  export type $walletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      issuer: Prisma.$issuerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: number
      issuer_id: string | null
      address: string
      chain: string
      type: string
      provider: string
      did: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type walletGetPayload<S extends boolean | null | undefined | walletDefaultArgs> = $Result.GetResult<Prisma.$walletPayload, S>

  type walletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<walletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface walletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet'], meta: { name: 'wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {walletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends walletFindUniqueArgs>(args: SelectSubset<T, walletFindUniqueArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {walletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends walletFindUniqueOrThrowArgs>(args: SelectSubset<T, walletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends walletFindFirstArgs>(args?: SelectSubset<T, walletFindFirstArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends walletFindFirstOrThrowArgs>(args?: SelectSubset<T, walletFindFirstOrThrowArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends walletFindManyArgs>(args?: SelectSubset<T, walletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallet.
     * @param {walletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends walletCreateArgs>(args: SelectSubset<T, walletCreateArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallets.
     * @param {walletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends walletCreateManyArgs>(args?: SelectSubset<T, walletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {walletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends walletDeleteArgs>(args: SelectSubset<T, walletDeleteArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {walletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends walletUpdateArgs>(args: SelectSubset<T, walletUpdateArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {walletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends walletDeleteManyArgs>(args?: SelectSubset<T, walletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends walletUpdateManyArgs>(args: SelectSubset<T, walletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {walletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends walletUpsertArgs>(args: SelectSubset<T, walletUpsertArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends walletCountArgs>(
      args?: Subset<T, walletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends walletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: walletGroupByArgs['orderBy'] }
        : { orderBy?: walletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, walletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet model
   */
  readonly fields: walletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__walletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    issuer<T extends wallet$issuerArgs<ExtArgs> = {}>(args?: Subset<T, wallet$issuerArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet model
   */ 
  interface walletFieldRefs {
    readonly id: FieldRef<"wallet", 'String'>
    readonly user_id: FieldRef<"wallet", 'Int'>
    readonly issuer_id: FieldRef<"wallet", 'String'>
    readonly address: FieldRef<"wallet", 'String'>
    readonly chain: FieldRef<"wallet", 'String'>
    readonly type: FieldRef<"wallet", 'String'>
    readonly provider: FieldRef<"wallet", 'String'>
    readonly did: FieldRef<"wallet", 'String'>
    readonly created_at: FieldRef<"wallet", 'DateTime'>
    readonly updated_at: FieldRef<"wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * wallet findUnique
   */
  export type walletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet findUniqueOrThrow
   */
  export type walletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet findFirst
   */
  export type walletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet findFirstOrThrow
   */
  export type walletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet findMany
   */
  export type walletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet create
   */
  export type walletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to create a wallet.
     */
    data: XOR<walletCreateInput, walletUncheckedCreateInput>
  }

  /**
   * wallet createMany
   */
  export type walletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallets.
     */
    data: walletCreateManyInput | walletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet update
   */
  export type walletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to update a wallet.
     */
    data: XOR<walletUpdateInput, walletUncheckedUpdateInput>
    /**
     * Choose, which wallet to update.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet updateMany
   */
  export type walletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallets.
     */
    data: XOR<walletUpdateManyMutationInput, walletUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletWhereInput
  }

  /**
   * wallet upsert
   */
  export type walletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The filter to search for the wallet to update in case it exists.
     */
    where: walletWhereUniqueInput
    /**
     * In case the wallet found by the `where` argument doesn't exist, create a new wallet with this data.
     */
    create: XOR<walletCreateInput, walletUncheckedCreateInput>
    /**
     * In case the wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<walletUpdateInput, walletUncheckedUpdateInput>
  }

  /**
   * wallet delete
   */
  export type walletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter which wallet to delete.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet deleteMany
   */
  export type walletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to delete
     */
    where?: walletWhereInput
  }

  /**
   * wallet.issuer
   */
  export type wallet$issuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    where?: issuerWhereInput
  }

  /**
   * wallet without action
   */
  export type walletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
  }


  /**
   * Model webhookLog
   */

  export type AggregateWebhookLog = {
    _count: WebhookLogCountAggregateOutputType | null
    _avg: WebhookLogAvgAggregateOutputType | null
    _sum: WebhookLogSumAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  export type WebhookLogAvgAggregateOutputType = {
    id: number | null
  }

  export type WebhookLogSumAggregateOutputType = {
    id: number | null
  }

  export type WebhookLogMinAggregateOutputType = {
    id: number | null
    type: string | null
    signature: string | null
    status: string | null
    provider: string | null
    processed: boolean | null
    processed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WebhookLogMaxAggregateOutputType = {
    id: number | null
    type: string | null
    signature: string | null
    status: string | null
    provider: string | null
    processed: boolean | null
    processed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type WebhookLogCountAggregateOutputType = {
    id: number
    type: number
    payload: number
    signature: number
    status: number
    provider: number
    processed: number
    processed_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type WebhookLogAvgAggregateInputType = {
    id?: true
  }

  export type WebhookLogSumAggregateInputType = {
    id?: true
  }

  export type WebhookLogMinAggregateInputType = {
    id?: true
    type?: true
    signature?: true
    status?: true
    provider?: true
    processed?: true
    processed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type WebhookLogMaxAggregateInputType = {
    id?: true
    type?: true
    signature?: true
    status?: true
    provider?: true
    processed?: true
    processed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type WebhookLogCountAggregateInputType = {
    id?: true
    type?: true
    payload?: true
    signature?: true
    status?: true
    provider?: true
    processed?: true
    processed_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type WebhookLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webhookLog to aggregate.
     */
    where?: webhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookLogs to fetch.
     */
    orderBy?: webhookLogOrderByWithRelationInput | webhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: webhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned webhookLogs
    **/
    _count?: true | WebhookLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookLogMaxAggregateInputType
  }

  export type GetWebhookLogAggregateType<T extends WebhookLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookLog[P]>
      : GetScalarType<T[P], AggregateWebhookLog[P]>
  }




  export type webhookLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: webhookLogWhereInput
    orderBy?: webhookLogOrderByWithAggregationInput | webhookLogOrderByWithAggregationInput[]
    by: WebhookLogScalarFieldEnum[] | WebhookLogScalarFieldEnum
    having?: webhookLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookLogCountAggregateInputType | true
    _avg?: WebhookLogAvgAggregateInputType
    _sum?: WebhookLogSumAggregateInputType
    _min?: WebhookLogMinAggregateInputType
    _max?: WebhookLogMaxAggregateInputType
  }

  export type WebhookLogGroupByOutputType = {
    id: number
    type: string
    payload: JsonValue
    signature: string | null
    status: string
    provider: string
    processed: boolean
    processed_at: Date | null
    created_at: Date
    updated_at: Date
    _count: WebhookLogCountAggregateOutputType | null
    _avg: WebhookLogAvgAggregateOutputType | null
    _sum: WebhookLogSumAggregateOutputType | null
    _min: WebhookLogMinAggregateOutputType | null
    _max: WebhookLogMaxAggregateOutputType | null
  }

  type GetWebhookLogGroupByPayload<T extends webhookLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookLogGroupByOutputType[P]>
        }
      >
    >


  export type webhookLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    payload?: boolean
    signature?: boolean
    status?: boolean
    provider?: boolean
    processed?: boolean
    processed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["webhookLog"]>


  export type webhookLogSelectScalar = {
    id?: boolean
    type?: boolean
    payload?: boolean
    signature?: boolean
    status?: boolean
    provider?: boolean
    processed?: boolean
    processed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $webhookLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "webhookLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      payload: Prisma.JsonValue
      signature: string | null
      status: string
      provider: string
      processed: boolean
      processed_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["webhookLog"]>
    composites: {}
  }

  type webhookLogGetPayload<S extends boolean | null | undefined | webhookLogDefaultArgs> = $Result.GetResult<Prisma.$webhookLogPayload, S>

  type webhookLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<webhookLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookLogCountAggregateInputType | true
    }

  export interface webhookLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['webhookLog'], meta: { name: 'webhookLog' } }
    /**
     * Find zero or one WebhookLog that matches the filter.
     * @param {webhookLogFindUniqueArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends webhookLogFindUniqueArgs>(args: SelectSubset<T, webhookLogFindUniqueArgs<ExtArgs>>): Prisma__webhookLogClient<$Result.GetResult<Prisma.$webhookLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {webhookLogFindUniqueOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends webhookLogFindUniqueOrThrowArgs>(args: SelectSubset<T, webhookLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__webhookLogClient<$Result.GetResult<Prisma.$webhookLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookLogFindFirstArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends webhookLogFindFirstArgs>(args?: SelectSubset<T, webhookLogFindFirstArgs<ExtArgs>>): Prisma__webhookLogClient<$Result.GetResult<Prisma.$webhookLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookLogFindFirstOrThrowArgs} args - Arguments to find a WebhookLog
     * @example
     * // Get one WebhookLog
     * const webhookLog = await prisma.webhookLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends webhookLogFindFirstOrThrowArgs>(args?: SelectSubset<T, webhookLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__webhookLogClient<$Result.GetResult<Prisma.$webhookLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany()
     * 
     * // Get first 10 WebhookLogs
     * const webhookLogs = await prisma.webhookLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookLogWithIdOnly = await prisma.webhookLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends webhookLogFindManyArgs>(args?: SelectSubset<T, webhookLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$webhookLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookLog.
     * @param {webhookLogCreateArgs} args - Arguments to create a WebhookLog.
     * @example
     * // Create one WebhookLog
     * const WebhookLog = await prisma.webhookLog.create({
     *   data: {
     *     // ... data to create a WebhookLog
     *   }
     * })
     * 
     */
    create<T extends webhookLogCreateArgs>(args: SelectSubset<T, webhookLogCreateArgs<ExtArgs>>): Prisma__webhookLogClient<$Result.GetResult<Prisma.$webhookLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookLogs.
     * @param {webhookLogCreateManyArgs} args - Arguments to create many WebhookLogs.
     * @example
     * // Create many WebhookLogs
     * const webhookLog = await prisma.webhookLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends webhookLogCreateManyArgs>(args?: SelectSubset<T, webhookLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WebhookLog.
     * @param {webhookLogDeleteArgs} args - Arguments to delete one WebhookLog.
     * @example
     * // Delete one WebhookLog
     * const WebhookLog = await prisma.webhookLog.delete({
     *   where: {
     *     // ... filter to delete one WebhookLog
     *   }
     * })
     * 
     */
    delete<T extends webhookLogDeleteArgs>(args: SelectSubset<T, webhookLogDeleteArgs<ExtArgs>>): Prisma__webhookLogClient<$Result.GetResult<Prisma.$webhookLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookLog.
     * @param {webhookLogUpdateArgs} args - Arguments to update one WebhookLog.
     * @example
     * // Update one WebhookLog
     * const webhookLog = await prisma.webhookLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends webhookLogUpdateArgs>(args: SelectSubset<T, webhookLogUpdateArgs<ExtArgs>>): Prisma__webhookLogClient<$Result.GetResult<Prisma.$webhookLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookLogs.
     * @param {webhookLogDeleteManyArgs} args - Arguments to filter WebhookLogs to delete.
     * @example
     * // Delete a few WebhookLogs
     * const { count } = await prisma.webhookLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends webhookLogDeleteManyArgs>(args?: SelectSubset<T, webhookLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookLogs
     * const webhookLog = await prisma.webhookLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends webhookLogUpdateManyArgs>(args: SelectSubset<T, webhookLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookLog.
     * @param {webhookLogUpsertArgs} args - Arguments to update or create a WebhookLog.
     * @example
     * // Update or create a WebhookLog
     * const webhookLog = await prisma.webhookLog.upsert({
     *   create: {
     *     // ... data to create a WebhookLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookLog we want to update
     *   }
     * })
     */
    upsert<T extends webhookLogUpsertArgs>(args: SelectSubset<T, webhookLogUpsertArgs<ExtArgs>>): Prisma__webhookLogClient<$Result.GetResult<Prisma.$webhookLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookLogCountArgs} args - Arguments to filter WebhookLogs to count.
     * @example
     * // Count the number of WebhookLogs
     * const count = await prisma.webhookLog.count({
     *   where: {
     *     // ... the filter for the WebhookLogs we want to count
     *   }
     * })
    **/
    count<T extends webhookLogCountArgs>(
      args?: Subset<T, webhookLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookLogAggregateArgs>(args: Subset<T, WebhookLogAggregateArgs>): Prisma.PrismaPromise<GetWebhookLogAggregateType<T>>

    /**
     * Group by WebhookLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {webhookLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends webhookLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: webhookLogGroupByArgs['orderBy'] }
        : { orderBy?: webhookLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, webhookLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the webhookLog model
   */
  readonly fields: webhookLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for webhookLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__webhookLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the webhookLog model
   */ 
  interface webhookLogFieldRefs {
    readonly id: FieldRef<"webhookLog", 'Int'>
    readonly type: FieldRef<"webhookLog", 'String'>
    readonly payload: FieldRef<"webhookLog", 'Json'>
    readonly signature: FieldRef<"webhookLog", 'String'>
    readonly status: FieldRef<"webhookLog", 'String'>
    readonly provider: FieldRef<"webhookLog", 'String'>
    readonly processed: FieldRef<"webhookLog", 'Boolean'>
    readonly processed_at: FieldRef<"webhookLog", 'DateTime'>
    readonly created_at: FieldRef<"webhookLog", 'DateTime'>
    readonly updated_at: FieldRef<"webhookLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * webhookLog findUnique
   */
  export type webhookLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
    /**
     * Filter, which webhookLog to fetch.
     */
    where: webhookLogWhereUniqueInput
  }

  /**
   * webhookLog findUniqueOrThrow
   */
  export type webhookLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
    /**
     * Filter, which webhookLog to fetch.
     */
    where: webhookLogWhereUniqueInput
  }

  /**
   * webhookLog findFirst
   */
  export type webhookLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
    /**
     * Filter, which webhookLog to fetch.
     */
    where?: webhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookLogs to fetch.
     */
    orderBy?: webhookLogOrderByWithRelationInput | webhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhookLogs.
     */
    cursor?: webhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * webhookLog findFirstOrThrow
   */
  export type webhookLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
    /**
     * Filter, which webhookLog to fetch.
     */
    where?: webhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookLogs to fetch.
     */
    orderBy?: webhookLogOrderByWithRelationInput | webhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for webhookLogs.
     */
    cursor?: webhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of webhookLogs.
     */
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * webhookLog findMany
   */
  export type webhookLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
    /**
     * Filter, which webhookLogs to fetch.
     */
    where?: webhookLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of webhookLogs to fetch.
     */
    orderBy?: webhookLogOrderByWithRelationInput | webhookLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing webhookLogs.
     */
    cursor?: webhookLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` webhookLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` webhookLogs.
     */
    skip?: number
    distinct?: WebhookLogScalarFieldEnum | WebhookLogScalarFieldEnum[]
  }

  /**
   * webhookLog create
   */
  export type webhookLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
    /**
     * The data needed to create a webhookLog.
     */
    data: XOR<webhookLogCreateInput, webhookLogUncheckedCreateInput>
  }

  /**
   * webhookLog createMany
   */
  export type webhookLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many webhookLogs.
     */
    data: webhookLogCreateManyInput | webhookLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * webhookLog update
   */
  export type webhookLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
    /**
     * The data needed to update a webhookLog.
     */
    data: XOR<webhookLogUpdateInput, webhookLogUncheckedUpdateInput>
    /**
     * Choose, which webhookLog to update.
     */
    where: webhookLogWhereUniqueInput
  }

  /**
   * webhookLog updateMany
   */
  export type webhookLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update webhookLogs.
     */
    data: XOR<webhookLogUpdateManyMutationInput, webhookLogUncheckedUpdateManyInput>
    /**
     * Filter which webhookLogs to update
     */
    where?: webhookLogWhereInput
  }

  /**
   * webhookLog upsert
   */
  export type webhookLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
    /**
     * The filter to search for the webhookLog to update in case it exists.
     */
    where: webhookLogWhereUniqueInput
    /**
     * In case the webhookLog found by the `where` argument doesn't exist, create a new webhookLog with this data.
     */
    create: XOR<webhookLogCreateInput, webhookLogUncheckedCreateInput>
    /**
     * In case the webhookLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<webhookLogUpdateInput, webhookLogUncheckedUpdateInput>
  }

  /**
   * webhookLog delete
   */
  export type webhookLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
    /**
     * Filter which webhookLog to delete.
     */
    where: webhookLogWhereUniqueInput
  }

  /**
   * webhookLog deleteMany
   */
  export type webhookLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which webhookLogs to delete
     */
    where?: webhookLogWhereInput
  }

  /**
   * webhookLog without action
   */
  export type webhookLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the webhookLog
     */
    select?: webhookLogSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const KycVerificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    applicant_id: 'applicant_id',
    correlation_id: 'correlation_id',
    created_at: 'created_at',
    error_message: 'error_message',
    event_timestamp: 'event_timestamp',
    external_user_id: 'external_user_id',
    inspection_id: 'inspection_id',
    processing_status: 'processing_status',
    raw_data: 'raw_data',
    review_result: 'review_result',
    review_status: 'review_status',
    signature_valid: 'signature_valid',
    updated_at: 'updated_at',
    user_id: 'user_id',
    webhook_type: 'webhook_type'
  };

  export type KycVerificationScalarFieldEnum = (typeof KycVerificationScalarFieldEnum)[keyof typeof KycVerificationScalarFieldEnum]


  export const KycDocumentScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    country: 'country',
    created_at: 'created_at',
    document_id: 'document_id',
    document_sub_type: 'document_sub_type',
    document_type: 'document_type',
    field_name: 'field_name',
    file_name: 'file_name',
    file_path: 'file_path',
    file_type: 'file_type',
    file_url: 'file_url',
    id_doc_type: 'id_doc_type',
    issued_date: 'issued_date',
    number: 'number',
    page_type: 'page_type',
    record_id: 'record_id',
    status: 'status',
    updated_at: 'updated_at',
    user_id: 'user_id',
    valid_until: 'valid_until'
  };

  export type KycDocumentScalarFieldEnum = (typeof KycDocumentScalarFieldEnum)[keyof typeof KycDocumentScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    department: 'department',
    position: 'position',
    last_login: 'last_login'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AuthproviderScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    provider_name: 'provider_name',
    provider_user_id: 'provider_user_id',
    provider_data: 'provider_data',
    created_at: 'created_at',
    last_used: 'last_used'
  };

  export type AuthproviderScalarFieldEnum = (typeof AuthproviderScalarFieldEnum)[keyof typeof AuthproviderScalarFieldEnum]


  export const DidwalletScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    wallet_address: 'wallet_address',
    did: 'did',
    is_primary: 'is_primary',
    created_at: 'created_at',
    last_used: 'last_used'
  };

  export type DidwalletScalarFieldEnum = (typeof DidwalletScalarFieldEnum)[keyof typeof DidwalletScalarFieldEnum]


  export const InvestorScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    investor_type: 'investor_type',
    accreditation_status: 'accreditation_status',
    accreditation_date: 'accreditation_date',
    kyc_documents: 'kyc_documents',
    aml_documents: 'aml_documents',
    kyc_verified: 'kyc_verified',
    aml_verified: 'aml_verified'
  };

  export type InvestorScalarFieldEnum = (typeof InvestorScalarFieldEnum)[keyof typeof InvestorScalarFieldEnum]


  export const IssuerScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    company_name: 'company_name',
    company_registration_number: 'company_registration_number',
    jurisdiction: 'jurisdiction',
    verification_status: 'verification_status',
    verification_date: 'verification_date',
    company_documents: 'company_documents',
    is_active: 'is_active',
    is_kyb_completed: 'is_kyb_completed',
    mobile_number: 'mobile_number',
    platform_client_id: 'platform_client_id',
    registration_date: 'registration_date',
    sumsub_applicant_id: 'sumsub_applicant_id',
    sumsub_correlation_id: 'sumsub_correlation_id',
    sumsub_external_id: 'sumsub_external_id',
    sumsub_inspection_id: 'sumsub_inspection_id',
    did: 'did',
    did_created_at: 'did_created_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type IssuerScalarFieldEnum = (typeof IssuerScalarFieldEnum)[keyof typeof IssuerScalarFieldEnum]


  export const Kyc_address_infoScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    address_type: 'address_type',
    is_primary: 'is_primary',
    street: 'street',
    street_line2: 'street_line2',
    city: 'city',
    state: 'state',
    postal_code: 'postal_code',
    country: 'country',
    is_verified: 'is_verified',
    verification_method: 'verification_method',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Kyc_address_infoScalarFieldEnum = (typeof Kyc_address_infoScalarFieldEnum)[keyof typeof Kyc_address_infoScalarFieldEnum]


  export const Kyc_addressesScalarFieldEnum: {
    id: 'id',
    record_id: 'record_id',
    address_type: 'address_type',
    is_primary: 'is_primary',
    street: 'street',
    street_line_2: 'street_line_2',
    city: 'city',
    state: 'state',
    postal_code: 'postal_code',
    country: 'country',
    is_verified: 'is_verified',
    updated_at: 'updated_at',
    created_at: 'created_at'
  };

  export type Kyc_addressesScalarFieldEnum = (typeof Kyc_addressesScalarFieldEnum)[keyof typeof Kyc_addressesScalarFieldEnum]


  export const Kyc_applicantsScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    user_id: 'user_id',
    external_user_id: 'external_user_id',
    inspection_id: 'inspection_id',
    correlation_id: 'correlation_id',
    status: 'status',
    result: 'result',
    id_doc_status: 'id_doc_status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    sandbox_mode: 'sandbox_mode',
    personal_info_id: 'personal_info_id'
  };

  export type Kyc_applicantsScalarFieldEnum = (typeof Kyc_applicantsScalarFieldEnum)[keyof typeof Kyc_applicantsScalarFieldEnum]


  export const Kyc_audit_logScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    action: 'action',
    performed_by: 'performed_by',
    details: 'details',
    timestamp: 'timestamp'
  };

  export type Kyc_audit_logScalarFieldEnum = (typeof Kyc_audit_logScalarFieldEnum)[keyof typeof Kyc_audit_logScalarFieldEnum]


  export const Kyc_complete_recordsScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    user_id: 'user_id',
    status: 'status',
    result: 'result',
    complete_data: 'complete_data',
    collected_at: 'collected_at',
    updated_at: 'updated_at',
    created_at: 'created_at'
  };

  export type Kyc_complete_recordsScalarFieldEnum = (typeof Kyc_complete_recordsScalarFieldEnum)[keyof typeof Kyc_complete_recordsScalarFieldEnum]


  export const Kyc_personal_infoScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    record_id: 'record_id',
    first_name: 'first_name',
    last_name: 'last_name',
    middle_name: 'middle_name',
    full_name: 'full_name',
    legal_name: 'legal_name',
    gender: 'gender',
    date_of_birth: 'date_of_birth',
    place_of_birth: 'place_of_birth',
    country_of_birth: 'country_of_birth',
    state_of_birth: 'state_of_birth',
    nationality: 'nationality',
    phone: 'phone',
    email: 'email',
    country: 'country',
    tax_residence_country: 'tax_residence_country',
    tax_identification_number: 'tax_identification_number',
    id_number: 'id_number',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Kyc_personal_infoScalarFieldEnum = (typeof Kyc_personal_infoScalarFieldEnum)[keyof typeof Kyc_personal_infoScalarFieldEnum]


  export const Kyc_raw_dataScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    data_type: 'data_type',
    source: 'source',
    raw_data: 'raw_data',
    created_at: 'created_at'
  };

  export type Kyc_raw_dataScalarFieldEnum = (typeof Kyc_raw_dataScalarFieldEnum)[keyof typeof Kyc_raw_dataScalarFieldEnum]


  export const Kyc_verification_eventsScalarFieldEnum: {
    id: 'id',
    record_id: 'record_id',
    type: 'type',
    review_status: 'review_status',
    review_result: 'review_result',
    inspection_id: 'inspection_id',
    event_data: 'event_data',
    event_timestamp: 'event_timestamp',
    created_at: 'created_at'
  };

  export type Kyc_verification_eventsScalarFieldEnum = (typeof Kyc_verification_eventsScalarFieldEnum)[keyof typeof Kyc_verification_eventsScalarFieldEnum]


  export const Kyc_verification_historyScalarFieldEnum: {
    id: 'id',
    applicant_id: 'applicant_id',
    type: 'type',
    review_status: 'review_status',
    review_result: 'review_result',
    review_answer: 'review_answer',
    reject_type: 'reject_type',
    reject_labels: 'reject_labels',
    timestamp: 'timestamp',
    created_at: 'created_at'
  };

  export type Kyc_verification_historyScalarFieldEnum = (typeof Kyc_verification_historyScalarFieldEnum)[keyof typeof Kyc_verification_historyScalarFieldEnum]


  export const RefreshtokenScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token: 'token',
    expires_at: 'expires_at',
    created_at: 'created_at',
    device_info: 'device_info'
  };

  export type RefreshtokenScalarFieldEnum = (typeof RefreshtokenScalarFieldEnum)[keyof typeof RefreshtokenScalarFieldEnum]


  export const UserroleScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    role: 'role',
    created_at: 'created_at'
  };

  export type UserroleScalarFieldEnum = (typeof UserroleScalarFieldEnum)[keyof typeof UserroleScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    first_name: 'first_name',
    last_name: 'last_name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    applicant_id: 'applicant_id',
    is_verified: 'is_verified',
    verification_result: 'verification_result'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    issuer_id: 'issuer_id',
    address: 'address',
    chain: 'chain',
    type: 'type',
    provider: 'provider',
    did: 'did',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const WebhookLogScalarFieldEnum: {
    id: 'id',
    type: 'type',
    payload: 'payload',
    signature: 'signature',
    status: 'status',
    provider: 'provider',
    processed: 'processed',
    processed_at: 'processed_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type WebhookLogScalarFieldEnum = (typeof WebhookLogScalarFieldEnum)[keyof typeof WebhookLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type kycVerificationWhereInput = {
    AND?: kycVerificationWhereInput | kycVerificationWhereInput[]
    OR?: kycVerificationWhereInput[]
    NOT?: kycVerificationWhereInput | kycVerificationWhereInput[]
    id?: IntFilter<"kycVerification"> | number
    type?: StringFilter<"kycVerification"> | string
    applicant_id?: StringFilter<"kycVerification"> | string
    correlation_id?: StringNullableFilter<"kycVerification"> | string | null
    created_at?: DateTimeFilter<"kycVerification"> | Date | string
    error_message?: StringNullableFilter<"kycVerification"> | string | null
    event_timestamp?: DateTimeFilter<"kycVerification"> | Date | string
    external_user_id?: StringNullableFilter<"kycVerification"> | string | null
    inspection_id?: StringNullableFilter<"kycVerification"> | string | null
    processing_status?: StringNullableFilter<"kycVerification"> | string | null
    raw_data?: StringFilter<"kycVerification"> | string
    review_result?: StringNullableFilter<"kycVerification"> | string | null
    review_status?: StringFilter<"kycVerification"> | string
    signature_valid?: BoolFilter<"kycVerification"> | boolean
    updated_at?: DateTimeFilter<"kycVerification"> | Date | string
    user_id?: IntNullableFilter<"kycVerification"> | number | null
    webhook_type?: StringFilter<"kycVerification"> | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type kycVerificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    applicant_id?: SortOrder
    correlation_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    error_message?: SortOrderInput | SortOrder
    event_timestamp?: SortOrder
    external_user_id?: SortOrderInput | SortOrder
    inspection_id?: SortOrderInput | SortOrder
    processing_status?: SortOrderInput | SortOrder
    raw_data?: SortOrder
    review_result?: SortOrderInput | SortOrder
    review_status?: SortOrder
    signature_valid?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    webhook_type?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type kycVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kycVerificationWhereInput | kycVerificationWhereInput[]
    OR?: kycVerificationWhereInput[]
    NOT?: kycVerificationWhereInput | kycVerificationWhereInput[]
    type?: StringFilter<"kycVerification"> | string
    applicant_id?: StringFilter<"kycVerification"> | string
    correlation_id?: StringNullableFilter<"kycVerification"> | string | null
    created_at?: DateTimeFilter<"kycVerification"> | Date | string
    error_message?: StringNullableFilter<"kycVerification"> | string | null
    event_timestamp?: DateTimeFilter<"kycVerification"> | Date | string
    external_user_id?: StringNullableFilter<"kycVerification"> | string | null
    inspection_id?: StringNullableFilter<"kycVerification"> | string | null
    processing_status?: StringNullableFilter<"kycVerification"> | string | null
    raw_data?: StringFilter<"kycVerification"> | string
    review_result?: StringNullableFilter<"kycVerification"> | string | null
    review_status?: StringFilter<"kycVerification"> | string
    signature_valid?: BoolFilter<"kycVerification"> | boolean
    updated_at?: DateTimeFilter<"kycVerification"> | Date | string
    user_id?: IntNullableFilter<"kycVerification"> | number | null
    webhook_type?: StringFilter<"kycVerification"> | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type kycVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    applicant_id?: SortOrder
    correlation_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    error_message?: SortOrderInput | SortOrder
    event_timestamp?: SortOrder
    external_user_id?: SortOrderInput | SortOrder
    inspection_id?: SortOrderInput | SortOrder
    processing_status?: SortOrderInput | SortOrder
    raw_data?: SortOrder
    review_result?: SortOrderInput | SortOrder
    review_status?: SortOrder
    signature_valid?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    webhook_type?: SortOrder
    _count?: kycVerificationCountOrderByAggregateInput
    _avg?: kycVerificationAvgOrderByAggregateInput
    _max?: kycVerificationMaxOrderByAggregateInput
    _min?: kycVerificationMinOrderByAggregateInput
    _sum?: kycVerificationSumOrderByAggregateInput
  }

  export type kycVerificationScalarWhereWithAggregatesInput = {
    AND?: kycVerificationScalarWhereWithAggregatesInput | kycVerificationScalarWhereWithAggregatesInput[]
    OR?: kycVerificationScalarWhereWithAggregatesInput[]
    NOT?: kycVerificationScalarWhereWithAggregatesInput | kycVerificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kycVerification"> | number
    type?: StringWithAggregatesFilter<"kycVerification"> | string
    applicant_id?: StringWithAggregatesFilter<"kycVerification"> | string
    correlation_id?: StringNullableWithAggregatesFilter<"kycVerification"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"kycVerification"> | Date | string
    error_message?: StringNullableWithAggregatesFilter<"kycVerification"> | string | null
    event_timestamp?: DateTimeWithAggregatesFilter<"kycVerification"> | Date | string
    external_user_id?: StringNullableWithAggregatesFilter<"kycVerification"> | string | null
    inspection_id?: StringNullableWithAggregatesFilter<"kycVerification"> | string | null
    processing_status?: StringNullableWithAggregatesFilter<"kycVerification"> | string | null
    raw_data?: StringWithAggregatesFilter<"kycVerification"> | string
    review_result?: StringNullableWithAggregatesFilter<"kycVerification"> | string | null
    review_status?: StringWithAggregatesFilter<"kycVerification"> | string
    signature_valid?: BoolWithAggregatesFilter<"kycVerification"> | boolean
    updated_at?: DateTimeWithAggregatesFilter<"kycVerification"> | Date | string
    user_id?: IntNullableWithAggregatesFilter<"kycVerification"> | number | null
    webhook_type?: StringWithAggregatesFilter<"kycVerification"> | string
  }

  export type KycDocumentWhereInput = {
    AND?: KycDocumentWhereInput | KycDocumentWhereInput[]
    OR?: KycDocumentWhereInput[]
    NOT?: KycDocumentWhereInput | KycDocumentWhereInput[]
    id?: IntFilter<"KycDocument"> | number
    applicant_id?: StringNullableFilter<"KycDocument"> | string | null
    country?: StringNullableFilter<"KycDocument"> | string | null
    created_at?: DateTimeFilter<"KycDocument"> | Date | string
    document_id?: StringNullableFilter<"KycDocument"> | string | null
    document_sub_type?: StringNullableFilter<"KycDocument"> | string | null
    document_type?: StringFilter<"KycDocument"> | string
    field_name?: StringNullableFilter<"KycDocument"> | string | null
    file_name?: StringFilter<"KycDocument"> | string
    file_path?: StringFilter<"KycDocument"> | string
    file_type?: StringFilter<"KycDocument"> | string
    file_url?: StringNullableFilter<"KycDocument"> | string | null
    id_doc_type?: StringNullableFilter<"KycDocument"> | string | null
    issued_date?: DateTimeNullableFilter<"KycDocument"> | Date | string | null
    number?: StringNullableFilter<"KycDocument"> | string | null
    page_type?: StringNullableFilter<"KycDocument"> | string | null
    record_id?: IntNullableFilter<"KycDocument"> | number | null
    status?: StringFilter<"KycDocument"> | string
    updated_at?: DateTimeFilter<"KycDocument"> | Date | string
    user_id?: IntNullableFilter<"KycDocument"> | number | null
    valid_until?: DateTimeNullableFilter<"KycDocument"> | Date | string | null
    kyc_complete_records?: XOR<Kyc_complete_recordsNullableRelationFilter, kyc_complete_recordsWhereInput> | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type KycDocumentOrderByWithRelationInput = {
    id?: SortOrder
    applicant_id?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    created_at?: SortOrder
    document_id?: SortOrderInput | SortOrder
    document_sub_type?: SortOrderInput | SortOrder
    document_type?: SortOrder
    field_name?: SortOrderInput | SortOrder
    file_name?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrderInput | SortOrder
    id_doc_type?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    page_type?: SortOrderInput | SortOrder
    record_id?: SortOrderInput | SortOrder
    status?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    valid_until?: SortOrderInput | SortOrder
    kyc_complete_records?: kyc_complete_recordsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type KycDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: KycDocumentWhereInput | KycDocumentWhereInput[]
    OR?: KycDocumentWhereInput[]
    NOT?: KycDocumentWhereInput | KycDocumentWhereInput[]
    applicant_id?: StringNullableFilter<"KycDocument"> | string | null
    country?: StringNullableFilter<"KycDocument"> | string | null
    created_at?: DateTimeFilter<"KycDocument"> | Date | string
    document_id?: StringNullableFilter<"KycDocument"> | string | null
    document_sub_type?: StringNullableFilter<"KycDocument"> | string | null
    document_type?: StringFilter<"KycDocument"> | string
    field_name?: StringNullableFilter<"KycDocument"> | string | null
    file_name?: StringFilter<"KycDocument"> | string
    file_path?: StringFilter<"KycDocument"> | string
    file_type?: StringFilter<"KycDocument"> | string
    file_url?: StringNullableFilter<"KycDocument"> | string | null
    id_doc_type?: StringNullableFilter<"KycDocument"> | string | null
    issued_date?: DateTimeNullableFilter<"KycDocument"> | Date | string | null
    number?: StringNullableFilter<"KycDocument"> | string | null
    page_type?: StringNullableFilter<"KycDocument"> | string | null
    record_id?: IntNullableFilter<"KycDocument"> | number | null
    status?: StringFilter<"KycDocument"> | string
    updated_at?: DateTimeFilter<"KycDocument"> | Date | string
    user_id?: IntNullableFilter<"KycDocument"> | number | null
    valid_until?: DateTimeNullableFilter<"KycDocument"> | Date | string | null
    kyc_complete_records?: XOR<Kyc_complete_recordsNullableRelationFilter, kyc_complete_recordsWhereInput> | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type KycDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    applicant_id?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    created_at?: SortOrder
    document_id?: SortOrderInput | SortOrder
    document_sub_type?: SortOrderInput | SortOrder
    document_type?: SortOrder
    field_name?: SortOrderInput | SortOrder
    file_name?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrderInput | SortOrder
    id_doc_type?: SortOrderInput | SortOrder
    issued_date?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    page_type?: SortOrderInput | SortOrder
    record_id?: SortOrderInput | SortOrder
    status?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    valid_until?: SortOrderInput | SortOrder
    _count?: KycDocumentCountOrderByAggregateInput
    _avg?: KycDocumentAvgOrderByAggregateInput
    _max?: KycDocumentMaxOrderByAggregateInput
    _min?: KycDocumentMinOrderByAggregateInput
    _sum?: KycDocumentSumOrderByAggregateInput
  }

  export type KycDocumentScalarWhereWithAggregatesInput = {
    AND?: KycDocumentScalarWhereWithAggregatesInput | KycDocumentScalarWhereWithAggregatesInput[]
    OR?: KycDocumentScalarWhereWithAggregatesInput[]
    NOT?: KycDocumentScalarWhereWithAggregatesInput | KycDocumentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"KycDocument"> | number
    applicant_id?: StringNullableWithAggregatesFilter<"KycDocument"> | string | null
    country?: StringNullableWithAggregatesFilter<"KycDocument"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"KycDocument"> | Date | string
    document_id?: StringNullableWithAggregatesFilter<"KycDocument"> | string | null
    document_sub_type?: StringNullableWithAggregatesFilter<"KycDocument"> | string | null
    document_type?: StringWithAggregatesFilter<"KycDocument"> | string
    field_name?: StringNullableWithAggregatesFilter<"KycDocument"> | string | null
    file_name?: StringWithAggregatesFilter<"KycDocument"> | string
    file_path?: StringWithAggregatesFilter<"KycDocument"> | string
    file_type?: StringWithAggregatesFilter<"KycDocument"> | string
    file_url?: StringNullableWithAggregatesFilter<"KycDocument"> | string | null
    id_doc_type?: StringNullableWithAggregatesFilter<"KycDocument"> | string | null
    issued_date?: DateTimeNullableWithAggregatesFilter<"KycDocument"> | Date | string | null
    number?: StringNullableWithAggregatesFilter<"KycDocument"> | string | null
    page_type?: StringNullableWithAggregatesFilter<"KycDocument"> | string | null
    record_id?: IntNullableWithAggregatesFilter<"KycDocument"> | number | null
    status?: StringWithAggregatesFilter<"KycDocument"> | string
    updated_at?: DateTimeWithAggregatesFilter<"KycDocument"> | Date | string
    user_id?: IntNullableWithAggregatesFilter<"KycDocument"> | number | null
    valid_until?: DateTimeNullableWithAggregatesFilter<"KycDocument"> | Date | string | null
  }

  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    id?: IntFilter<"admin"> | number
    user_id?: IntFilter<"admin"> | number
    department?: StringFilter<"admin"> | string
    position?: StringFilter<"admin"> | string
    last_login?: DateTimeNullableFilter<"admin"> | Date | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type adminOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    department?: StringFilter<"admin"> | string
    position?: StringFilter<"admin"> | string
    last_login?: DateTimeNullableFilter<"admin"> | Date | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id">

  export type adminOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrderInput | SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin"> | number
    user_id?: IntWithAggregatesFilter<"admin"> | number
    department?: StringWithAggregatesFilter<"admin"> | string
    position?: StringWithAggregatesFilter<"admin"> | string
    last_login?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
  }

  export type authproviderWhereInput = {
    AND?: authproviderWhereInput | authproviderWhereInput[]
    OR?: authproviderWhereInput[]
    NOT?: authproviderWhereInput | authproviderWhereInput[]
    id?: IntFilter<"authprovider"> | number
    user_id?: IntFilter<"authprovider"> | number
    provider_name?: StringFilter<"authprovider"> | string
    provider_user_id?: StringFilter<"authprovider"> | string
    provider_data?: JsonNullableFilter<"authprovider">
    created_at?: DateTimeFilter<"authprovider"> | Date | string
    last_used?: DateTimeFilter<"authprovider"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type authproviderOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    provider_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type authproviderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: authproviderWhereInput | authproviderWhereInput[]
    OR?: authproviderWhereInput[]
    NOT?: authproviderWhereInput | authproviderWhereInput[]
    user_id?: IntFilter<"authprovider"> | number
    provider_name?: StringFilter<"authprovider"> | string
    provider_user_id?: StringFilter<"authprovider"> | string
    provider_data?: JsonNullableFilter<"authprovider">
    created_at?: DateTimeFilter<"authprovider"> | Date | string
    last_used?: DateTimeFilter<"authprovider"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type authproviderOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    provider_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    _count?: authproviderCountOrderByAggregateInput
    _avg?: authproviderAvgOrderByAggregateInput
    _max?: authproviderMaxOrderByAggregateInput
    _min?: authproviderMinOrderByAggregateInput
    _sum?: authproviderSumOrderByAggregateInput
  }

  export type authproviderScalarWhereWithAggregatesInput = {
    AND?: authproviderScalarWhereWithAggregatesInput | authproviderScalarWhereWithAggregatesInput[]
    OR?: authproviderScalarWhereWithAggregatesInput[]
    NOT?: authproviderScalarWhereWithAggregatesInput | authproviderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"authprovider"> | number
    user_id?: IntWithAggregatesFilter<"authprovider"> | number
    provider_name?: StringWithAggregatesFilter<"authprovider"> | string
    provider_user_id?: StringWithAggregatesFilter<"authprovider"> | string
    provider_data?: JsonNullableWithAggregatesFilter<"authprovider">
    created_at?: DateTimeWithAggregatesFilter<"authprovider"> | Date | string
    last_used?: DateTimeWithAggregatesFilter<"authprovider"> | Date | string
  }

  export type didwalletWhereInput = {
    AND?: didwalletWhereInput | didwalletWhereInput[]
    OR?: didwalletWhereInput[]
    NOT?: didwalletWhereInput | didwalletWhereInput[]
    id?: IntFilter<"didwallet"> | number
    user_id?: IntFilter<"didwallet"> | number
    wallet_address?: StringFilter<"didwallet"> | string
    did?: StringFilter<"didwallet"> | string
    is_primary?: BoolFilter<"didwallet"> | boolean
    created_at?: DateTimeFilter<"didwallet"> | Date | string
    last_used?: DateTimeFilter<"didwallet"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type didwalletOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type didwalletWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: didwalletWhereInput | didwalletWhereInput[]
    OR?: didwalletWhereInput[]
    NOT?: didwalletWhereInput | didwalletWhereInput[]
    user_id?: IntFilter<"didwallet"> | number
    wallet_address?: StringFilter<"didwallet"> | string
    did?: StringFilter<"didwallet"> | string
    is_primary?: BoolFilter<"didwallet"> | boolean
    created_at?: DateTimeFilter<"didwallet"> | Date | string
    last_used?: DateTimeFilter<"didwallet"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type didwalletOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    _count?: didwalletCountOrderByAggregateInput
    _avg?: didwalletAvgOrderByAggregateInput
    _max?: didwalletMaxOrderByAggregateInput
    _min?: didwalletMinOrderByAggregateInput
    _sum?: didwalletSumOrderByAggregateInput
  }

  export type didwalletScalarWhereWithAggregatesInput = {
    AND?: didwalletScalarWhereWithAggregatesInput | didwalletScalarWhereWithAggregatesInput[]
    OR?: didwalletScalarWhereWithAggregatesInput[]
    NOT?: didwalletScalarWhereWithAggregatesInput | didwalletScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"didwallet"> | number
    user_id?: IntWithAggregatesFilter<"didwallet"> | number
    wallet_address?: StringWithAggregatesFilter<"didwallet"> | string
    did?: StringWithAggregatesFilter<"didwallet"> | string
    is_primary?: BoolWithAggregatesFilter<"didwallet"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"didwallet"> | Date | string
    last_used?: DateTimeWithAggregatesFilter<"didwallet"> | Date | string
  }

  export type investorWhereInput = {
    AND?: investorWhereInput | investorWhereInput[]
    OR?: investorWhereInput[]
    NOT?: investorWhereInput | investorWhereInput[]
    id?: IntFilter<"investor"> | number
    user_id?: IntFilter<"investor"> | number
    investor_type?: StringFilter<"investor"> | string
    accreditation_status?: StringFilter<"investor"> | string
    accreditation_date?: DateTimeNullableFilter<"investor"> | Date | string | null
    kyc_documents?: JsonNullableFilter<"investor">
    aml_documents?: JsonNullableFilter<"investor">
    kyc_verified?: BoolFilter<"investor"> | boolean
    aml_verified?: BoolFilter<"investor"> | boolean
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type investorOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrderInput | SortOrder
    kyc_documents?: SortOrderInput | SortOrder
    aml_documents?: SortOrderInput | SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type investorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: investorWhereInput | investorWhereInput[]
    OR?: investorWhereInput[]
    NOT?: investorWhereInput | investorWhereInput[]
    investor_type?: StringFilter<"investor"> | string
    accreditation_status?: StringFilter<"investor"> | string
    accreditation_date?: DateTimeNullableFilter<"investor"> | Date | string | null
    kyc_documents?: JsonNullableFilter<"investor">
    aml_documents?: JsonNullableFilter<"investor">
    kyc_verified?: BoolFilter<"investor"> | boolean
    aml_verified?: BoolFilter<"investor"> | boolean
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id">

  export type investorOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrderInput | SortOrder
    kyc_documents?: SortOrderInput | SortOrder
    aml_documents?: SortOrderInput | SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
    _count?: investorCountOrderByAggregateInput
    _avg?: investorAvgOrderByAggregateInput
    _max?: investorMaxOrderByAggregateInput
    _min?: investorMinOrderByAggregateInput
    _sum?: investorSumOrderByAggregateInput
  }

  export type investorScalarWhereWithAggregatesInput = {
    AND?: investorScalarWhereWithAggregatesInput | investorScalarWhereWithAggregatesInput[]
    OR?: investorScalarWhereWithAggregatesInput[]
    NOT?: investorScalarWhereWithAggregatesInput | investorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"investor"> | number
    user_id?: IntWithAggregatesFilter<"investor"> | number
    investor_type?: StringWithAggregatesFilter<"investor"> | string
    accreditation_status?: StringWithAggregatesFilter<"investor"> | string
    accreditation_date?: DateTimeNullableWithAggregatesFilter<"investor"> | Date | string | null
    kyc_documents?: JsonNullableWithAggregatesFilter<"investor">
    aml_documents?: JsonNullableWithAggregatesFilter<"investor">
    kyc_verified?: BoolWithAggregatesFilter<"investor"> | boolean
    aml_verified?: BoolWithAggregatesFilter<"investor"> | boolean
  }

  export type issuerWhereInput = {
    AND?: issuerWhereInput | issuerWhereInput[]
    OR?: issuerWhereInput[]
    NOT?: issuerWhereInput | issuerWhereInput[]
    id?: StringFilter<"issuer"> | string
    user_id?: IntFilter<"issuer"> | number
    company_name?: StringFilter<"issuer"> | string
    company_registration_number?: StringFilter<"issuer"> | string
    jurisdiction?: StringFilter<"issuer"> | string
    verification_status?: BoolFilter<"issuer"> | boolean
    verification_date?: DateTimeNullableFilter<"issuer"> | Date | string | null
    company_documents?: JsonNullableFilter<"issuer">
    is_active?: BoolFilter<"issuer"> | boolean
    is_kyb_completed?: BoolFilter<"issuer"> | boolean
    mobile_number?: StringNullableFilter<"issuer"> | string | null
    platform_client_id?: StringNullableFilter<"issuer"> | string | null
    registration_date?: DateTimeFilter<"issuer"> | Date | string
    sumsub_applicant_id?: StringNullableFilter<"issuer"> | string | null
    sumsub_correlation_id?: StringNullableFilter<"issuer"> | string | null
    sumsub_external_id?: StringNullableFilter<"issuer"> | string | null
    sumsub_inspection_id?: StringNullableFilter<"issuer"> | string | null
    did?: StringNullableFilter<"issuer"> | string | null
    did_created_at?: DateTimeNullableFilter<"issuer"> | Date | string | null
    created_at?: DateTimeFilter<"issuer"> | Date | string
    updated_at?: DateTimeFilter<"issuer"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    wallet?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
  }

  export type issuerOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrderInput | SortOrder
    company_documents?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_kyb_completed?: SortOrder
    mobile_number?: SortOrderInput | SortOrder
    platform_client_id?: SortOrderInput | SortOrder
    registration_date?: SortOrder
    sumsub_applicant_id?: SortOrderInput | SortOrder
    sumsub_correlation_id?: SortOrderInput | SortOrder
    sumsub_external_id?: SortOrderInput | SortOrder
    sumsub_inspection_id?: SortOrderInput | SortOrder
    did?: SortOrderInput | SortOrder
    did_created_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
    wallet?: walletOrderByWithRelationInput
  }

  export type issuerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: number
    AND?: issuerWhereInput | issuerWhereInput[]
    OR?: issuerWhereInput[]
    NOT?: issuerWhereInput | issuerWhereInput[]
    company_name?: StringFilter<"issuer"> | string
    company_registration_number?: StringFilter<"issuer"> | string
    jurisdiction?: StringFilter<"issuer"> | string
    verification_status?: BoolFilter<"issuer"> | boolean
    verification_date?: DateTimeNullableFilter<"issuer"> | Date | string | null
    company_documents?: JsonNullableFilter<"issuer">
    is_active?: BoolFilter<"issuer"> | boolean
    is_kyb_completed?: BoolFilter<"issuer"> | boolean
    mobile_number?: StringNullableFilter<"issuer"> | string | null
    platform_client_id?: StringNullableFilter<"issuer"> | string | null
    registration_date?: DateTimeFilter<"issuer"> | Date | string
    sumsub_applicant_id?: StringNullableFilter<"issuer"> | string | null
    sumsub_correlation_id?: StringNullableFilter<"issuer"> | string | null
    sumsub_external_id?: StringNullableFilter<"issuer"> | string | null
    sumsub_inspection_id?: StringNullableFilter<"issuer"> | string | null
    did?: StringNullableFilter<"issuer"> | string | null
    did_created_at?: DateTimeNullableFilter<"issuer"> | Date | string | null
    created_at?: DateTimeFilter<"issuer"> | Date | string
    updated_at?: DateTimeFilter<"issuer"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    wallet?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
  }, "id" | "user_id">

  export type issuerOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrderInput | SortOrder
    company_documents?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_kyb_completed?: SortOrder
    mobile_number?: SortOrderInput | SortOrder
    platform_client_id?: SortOrderInput | SortOrder
    registration_date?: SortOrder
    sumsub_applicant_id?: SortOrderInput | SortOrder
    sumsub_correlation_id?: SortOrderInput | SortOrder
    sumsub_external_id?: SortOrderInput | SortOrder
    sumsub_inspection_id?: SortOrderInput | SortOrder
    did?: SortOrderInput | SortOrder
    did_created_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: issuerCountOrderByAggregateInput
    _avg?: issuerAvgOrderByAggregateInput
    _max?: issuerMaxOrderByAggregateInput
    _min?: issuerMinOrderByAggregateInput
    _sum?: issuerSumOrderByAggregateInput
  }

  export type issuerScalarWhereWithAggregatesInput = {
    AND?: issuerScalarWhereWithAggregatesInput | issuerScalarWhereWithAggregatesInput[]
    OR?: issuerScalarWhereWithAggregatesInput[]
    NOT?: issuerScalarWhereWithAggregatesInput | issuerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"issuer"> | string
    user_id?: IntWithAggregatesFilter<"issuer"> | number
    company_name?: StringWithAggregatesFilter<"issuer"> | string
    company_registration_number?: StringWithAggregatesFilter<"issuer"> | string
    jurisdiction?: StringWithAggregatesFilter<"issuer"> | string
    verification_status?: BoolWithAggregatesFilter<"issuer"> | boolean
    verification_date?: DateTimeNullableWithAggregatesFilter<"issuer"> | Date | string | null
    company_documents?: JsonNullableWithAggregatesFilter<"issuer">
    is_active?: BoolWithAggregatesFilter<"issuer"> | boolean
    is_kyb_completed?: BoolWithAggregatesFilter<"issuer"> | boolean
    mobile_number?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    platform_client_id?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    registration_date?: DateTimeWithAggregatesFilter<"issuer"> | Date | string
    sumsub_applicant_id?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    sumsub_correlation_id?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    sumsub_external_id?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    sumsub_inspection_id?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    did?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    did_created_at?: DateTimeNullableWithAggregatesFilter<"issuer"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"issuer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"issuer"> | Date | string
  }

  export type kyc_address_infoWhereInput = {
    AND?: kyc_address_infoWhereInput | kyc_address_infoWhereInput[]
    OR?: kyc_address_infoWhereInput[]
    NOT?: kyc_address_infoWhereInput | kyc_address_infoWhereInput[]
    id?: IntFilter<"kyc_address_info"> | number
    applicant_id?: StringFilter<"kyc_address_info"> | string
    address_type?: StringFilter<"kyc_address_info"> | string
    is_primary?: BoolFilter<"kyc_address_info"> | boolean
    street?: StringNullableFilter<"kyc_address_info"> | string | null
    street_line2?: StringNullableFilter<"kyc_address_info"> | string | null
    city?: StringNullableFilter<"kyc_address_info"> | string | null
    state?: StringNullableFilter<"kyc_address_info"> | string | null
    postal_code?: StringNullableFilter<"kyc_address_info"> | string | null
    country?: StringNullableFilter<"kyc_address_info"> | string | null
    is_verified?: BoolFilter<"kyc_address_info"> | boolean
    verification_method?: StringNullableFilter<"kyc_address_info"> | string | null
    created_at?: DateTimeFilter<"kyc_address_info"> | Date | string
    updated_at?: DateTimeFilter<"kyc_address_info"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsRelationFilter, kyc_applicantsWhereInput>
  }

  export type kyc_address_infoOrderByWithRelationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrderInput | SortOrder
    street_line2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    verification_method?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    kyc_applicants?: kyc_applicantsOrderByWithRelationInput
  }

  export type kyc_address_infoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kyc_address_infoWhereInput | kyc_address_infoWhereInput[]
    OR?: kyc_address_infoWhereInput[]
    NOT?: kyc_address_infoWhereInput | kyc_address_infoWhereInput[]
    applicant_id?: StringFilter<"kyc_address_info"> | string
    address_type?: StringFilter<"kyc_address_info"> | string
    is_primary?: BoolFilter<"kyc_address_info"> | boolean
    street?: StringNullableFilter<"kyc_address_info"> | string | null
    street_line2?: StringNullableFilter<"kyc_address_info"> | string | null
    city?: StringNullableFilter<"kyc_address_info"> | string | null
    state?: StringNullableFilter<"kyc_address_info"> | string | null
    postal_code?: StringNullableFilter<"kyc_address_info"> | string | null
    country?: StringNullableFilter<"kyc_address_info"> | string | null
    is_verified?: BoolFilter<"kyc_address_info"> | boolean
    verification_method?: StringNullableFilter<"kyc_address_info"> | string | null
    created_at?: DateTimeFilter<"kyc_address_info"> | Date | string
    updated_at?: DateTimeFilter<"kyc_address_info"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsRelationFilter, kyc_applicantsWhereInput>
  }, "id">

  export type kyc_address_infoOrderByWithAggregationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrderInput | SortOrder
    street_line2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    verification_method?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: kyc_address_infoCountOrderByAggregateInput
    _avg?: kyc_address_infoAvgOrderByAggregateInput
    _max?: kyc_address_infoMaxOrderByAggregateInput
    _min?: kyc_address_infoMinOrderByAggregateInput
    _sum?: kyc_address_infoSumOrderByAggregateInput
  }

  export type kyc_address_infoScalarWhereWithAggregatesInput = {
    AND?: kyc_address_infoScalarWhereWithAggregatesInput | kyc_address_infoScalarWhereWithAggregatesInput[]
    OR?: kyc_address_infoScalarWhereWithAggregatesInput[]
    NOT?: kyc_address_infoScalarWhereWithAggregatesInput | kyc_address_infoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kyc_address_info"> | number
    applicant_id?: StringWithAggregatesFilter<"kyc_address_info"> | string
    address_type?: StringWithAggregatesFilter<"kyc_address_info"> | string
    is_primary?: BoolWithAggregatesFilter<"kyc_address_info"> | boolean
    street?: StringNullableWithAggregatesFilter<"kyc_address_info"> | string | null
    street_line2?: StringNullableWithAggregatesFilter<"kyc_address_info"> | string | null
    city?: StringNullableWithAggregatesFilter<"kyc_address_info"> | string | null
    state?: StringNullableWithAggregatesFilter<"kyc_address_info"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"kyc_address_info"> | string | null
    country?: StringNullableWithAggregatesFilter<"kyc_address_info"> | string | null
    is_verified?: BoolWithAggregatesFilter<"kyc_address_info"> | boolean
    verification_method?: StringNullableWithAggregatesFilter<"kyc_address_info"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"kyc_address_info"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"kyc_address_info"> | Date | string
  }

  export type kyc_addressesWhereInput = {
    AND?: kyc_addressesWhereInput | kyc_addressesWhereInput[]
    OR?: kyc_addressesWhereInput[]
    NOT?: kyc_addressesWhereInput | kyc_addressesWhereInput[]
    id?: IntFilter<"kyc_addresses"> | number
    record_id?: IntFilter<"kyc_addresses"> | number
    address_type?: StringFilter<"kyc_addresses"> | string
    is_primary?: BoolFilter<"kyc_addresses"> | boolean
    street?: StringNullableFilter<"kyc_addresses"> | string | null
    street_line_2?: StringNullableFilter<"kyc_addresses"> | string | null
    city?: StringNullableFilter<"kyc_addresses"> | string | null
    state?: StringNullableFilter<"kyc_addresses"> | string | null
    postal_code?: StringNullableFilter<"kyc_addresses"> | string | null
    country?: StringNullableFilter<"kyc_addresses"> | string | null
    is_verified?: BoolFilter<"kyc_addresses"> | boolean
    updated_at?: DateTimeFilter<"kyc_addresses"> | Date | string
    created_at?: DateTimeFilter<"kyc_addresses"> | Date | string
    kyc_complete_records?: XOR<Kyc_complete_recordsRelationFilter, kyc_complete_recordsWhereInput>
  }

  export type kyc_addressesOrderByWithRelationInput = {
    id?: SortOrder
    record_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrderInput | SortOrder
    street_line_2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
    kyc_complete_records?: kyc_complete_recordsOrderByWithRelationInput
  }

  export type kyc_addressesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kyc_addressesWhereInput | kyc_addressesWhereInput[]
    OR?: kyc_addressesWhereInput[]
    NOT?: kyc_addressesWhereInput | kyc_addressesWhereInput[]
    record_id?: IntFilter<"kyc_addresses"> | number
    address_type?: StringFilter<"kyc_addresses"> | string
    is_primary?: BoolFilter<"kyc_addresses"> | boolean
    street?: StringNullableFilter<"kyc_addresses"> | string | null
    street_line_2?: StringNullableFilter<"kyc_addresses"> | string | null
    city?: StringNullableFilter<"kyc_addresses"> | string | null
    state?: StringNullableFilter<"kyc_addresses"> | string | null
    postal_code?: StringNullableFilter<"kyc_addresses"> | string | null
    country?: StringNullableFilter<"kyc_addresses"> | string | null
    is_verified?: BoolFilter<"kyc_addresses"> | boolean
    updated_at?: DateTimeFilter<"kyc_addresses"> | Date | string
    created_at?: DateTimeFilter<"kyc_addresses"> | Date | string
    kyc_complete_records?: XOR<Kyc_complete_recordsRelationFilter, kyc_complete_recordsWhereInput>
  }, "id">

  export type kyc_addressesOrderByWithAggregationInput = {
    id?: SortOrder
    record_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrderInput | SortOrder
    street_line_2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postal_code?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
    _count?: kyc_addressesCountOrderByAggregateInput
    _avg?: kyc_addressesAvgOrderByAggregateInput
    _max?: kyc_addressesMaxOrderByAggregateInput
    _min?: kyc_addressesMinOrderByAggregateInput
    _sum?: kyc_addressesSumOrderByAggregateInput
  }

  export type kyc_addressesScalarWhereWithAggregatesInput = {
    AND?: kyc_addressesScalarWhereWithAggregatesInput | kyc_addressesScalarWhereWithAggregatesInput[]
    OR?: kyc_addressesScalarWhereWithAggregatesInput[]
    NOT?: kyc_addressesScalarWhereWithAggregatesInput | kyc_addressesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kyc_addresses"> | number
    record_id?: IntWithAggregatesFilter<"kyc_addresses"> | number
    address_type?: StringWithAggregatesFilter<"kyc_addresses"> | string
    is_primary?: BoolWithAggregatesFilter<"kyc_addresses"> | boolean
    street?: StringNullableWithAggregatesFilter<"kyc_addresses"> | string | null
    street_line_2?: StringNullableWithAggregatesFilter<"kyc_addresses"> | string | null
    city?: StringNullableWithAggregatesFilter<"kyc_addresses"> | string | null
    state?: StringNullableWithAggregatesFilter<"kyc_addresses"> | string | null
    postal_code?: StringNullableWithAggregatesFilter<"kyc_addresses"> | string | null
    country?: StringNullableWithAggregatesFilter<"kyc_addresses"> | string | null
    is_verified?: BoolWithAggregatesFilter<"kyc_addresses"> | boolean
    updated_at?: DateTimeWithAggregatesFilter<"kyc_addresses"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"kyc_addresses"> | Date | string
  }

  export type kyc_applicantsWhereInput = {
    AND?: kyc_applicantsWhereInput | kyc_applicantsWhereInput[]
    OR?: kyc_applicantsWhereInput[]
    NOT?: kyc_applicantsWhereInput | kyc_applicantsWhereInput[]
    id?: IntFilter<"kyc_applicants"> | number
    applicant_id?: StringFilter<"kyc_applicants"> | string
    user_id?: IntNullableFilter<"kyc_applicants"> | number | null
    external_user_id?: StringNullableFilter<"kyc_applicants"> | string | null
    inspection_id?: StringNullableFilter<"kyc_applicants"> | string | null
    correlation_id?: StringNullableFilter<"kyc_applicants"> | string | null
    status?: StringFilter<"kyc_applicants"> | string
    result?: StringNullableFilter<"kyc_applicants"> | string | null
    id_doc_status?: StringNullableFilter<"kyc_applicants"> | string | null
    created_at?: DateTimeFilter<"kyc_applicants"> | Date | string
    updated_at?: DateTimeFilter<"kyc_applicants"> | Date | string
    sandbox_mode?: BoolFilter<"kyc_applicants"> | boolean
    personal_info_id?: IntNullableFilter<"kyc_applicants"> | number | null
    kyc_address_info?: Kyc_address_infoListRelationFilter
    kyc_personal_info?: XOR<Kyc_personal_infoNullableRelationFilter, kyc_personal_infoWhereInput> | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    kyc_audit_log?: Kyc_audit_logListRelationFilter
    kyc_raw_data?: Kyc_raw_dataListRelationFilter
    kyc_verification_history?: Kyc_verification_historyListRelationFilter
  }

  export type kyc_applicantsOrderByWithRelationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    external_user_id?: SortOrderInput | SortOrder
    inspection_id?: SortOrderInput | SortOrder
    correlation_id?: SortOrderInput | SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    id_doc_status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sandbox_mode?: SortOrder
    personal_info_id?: SortOrderInput | SortOrder
    kyc_address_info?: kyc_address_infoOrderByRelationAggregateInput
    kyc_personal_info?: kyc_personal_infoOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    kyc_audit_log?: kyc_audit_logOrderByRelationAggregateInput
    kyc_raw_data?: kyc_raw_dataOrderByRelationAggregateInput
    kyc_verification_history?: kyc_verification_historyOrderByRelationAggregateInput
  }

  export type kyc_applicantsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    applicant_id?: string
    personal_info_id?: number
    AND?: kyc_applicantsWhereInput | kyc_applicantsWhereInput[]
    OR?: kyc_applicantsWhereInput[]
    NOT?: kyc_applicantsWhereInput | kyc_applicantsWhereInput[]
    user_id?: IntNullableFilter<"kyc_applicants"> | number | null
    external_user_id?: StringNullableFilter<"kyc_applicants"> | string | null
    inspection_id?: StringNullableFilter<"kyc_applicants"> | string | null
    correlation_id?: StringNullableFilter<"kyc_applicants"> | string | null
    status?: StringFilter<"kyc_applicants"> | string
    result?: StringNullableFilter<"kyc_applicants"> | string | null
    id_doc_status?: StringNullableFilter<"kyc_applicants"> | string | null
    created_at?: DateTimeFilter<"kyc_applicants"> | Date | string
    updated_at?: DateTimeFilter<"kyc_applicants"> | Date | string
    sandbox_mode?: BoolFilter<"kyc_applicants"> | boolean
    kyc_address_info?: Kyc_address_infoListRelationFilter
    kyc_personal_info?: XOR<Kyc_personal_infoNullableRelationFilter, kyc_personal_infoWhereInput> | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    kyc_audit_log?: Kyc_audit_logListRelationFilter
    kyc_raw_data?: Kyc_raw_dataListRelationFilter
    kyc_verification_history?: Kyc_verification_historyListRelationFilter
  }, "id" | "applicant_id" | "personal_info_id">

  export type kyc_applicantsOrderByWithAggregationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    external_user_id?: SortOrderInput | SortOrder
    inspection_id?: SortOrderInput | SortOrder
    correlation_id?: SortOrderInput | SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    id_doc_status?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sandbox_mode?: SortOrder
    personal_info_id?: SortOrderInput | SortOrder
    _count?: kyc_applicantsCountOrderByAggregateInput
    _avg?: kyc_applicantsAvgOrderByAggregateInput
    _max?: kyc_applicantsMaxOrderByAggregateInput
    _min?: kyc_applicantsMinOrderByAggregateInput
    _sum?: kyc_applicantsSumOrderByAggregateInput
  }

  export type kyc_applicantsScalarWhereWithAggregatesInput = {
    AND?: kyc_applicantsScalarWhereWithAggregatesInput | kyc_applicantsScalarWhereWithAggregatesInput[]
    OR?: kyc_applicantsScalarWhereWithAggregatesInput[]
    NOT?: kyc_applicantsScalarWhereWithAggregatesInput | kyc_applicantsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kyc_applicants"> | number
    applicant_id?: StringWithAggregatesFilter<"kyc_applicants"> | string
    user_id?: IntNullableWithAggregatesFilter<"kyc_applicants"> | number | null
    external_user_id?: StringNullableWithAggregatesFilter<"kyc_applicants"> | string | null
    inspection_id?: StringNullableWithAggregatesFilter<"kyc_applicants"> | string | null
    correlation_id?: StringNullableWithAggregatesFilter<"kyc_applicants"> | string | null
    status?: StringWithAggregatesFilter<"kyc_applicants"> | string
    result?: StringNullableWithAggregatesFilter<"kyc_applicants"> | string | null
    id_doc_status?: StringNullableWithAggregatesFilter<"kyc_applicants"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"kyc_applicants"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"kyc_applicants"> | Date | string
    sandbox_mode?: BoolWithAggregatesFilter<"kyc_applicants"> | boolean
    personal_info_id?: IntNullableWithAggregatesFilter<"kyc_applicants"> | number | null
  }

  export type kyc_audit_logWhereInput = {
    AND?: kyc_audit_logWhereInput | kyc_audit_logWhereInput[]
    OR?: kyc_audit_logWhereInput[]
    NOT?: kyc_audit_logWhereInput | kyc_audit_logWhereInput[]
    id?: IntFilter<"kyc_audit_log"> | number
    applicant_id?: StringFilter<"kyc_audit_log"> | string
    action?: StringFilter<"kyc_audit_log"> | string
    performed_by?: StringNullableFilter<"kyc_audit_log"> | string | null
    details?: StringNullableFilter<"kyc_audit_log"> | string | null
    timestamp?: DateTimeFilter<"kyc_audit_log"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsRelationFilter, kyc_applicantsWhereInput>
  }

  export type kyc_audit_logOrderByWithRelationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    action?: SortOrder
    performed_by?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    kyc_applicants?: kyc_applicantsOrderByWithRelationInput
  }

  export type kyc_audit_logWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kyc_audit_logWhereInput | kyc_audit_logWhereInput[]
    OR?: kyc_audit_logWhereInput[]
    NOT?: kyc_audit_logWhereInput | kyc_audit_logWhereInput[]
    applicant_id?: StringFilter<"kyc_audit_log"> | string
    action?: StringFilter<"kyc_audit_log"> | string
    performed_by?: StringNullableFilter<"kyc_audit_log"> | string | null
    details?: StringNullableFilter<"kyc_audit_log"> | string | null
    timestamp?: DateTimeFilter<"kyc_audit_log"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsRelationFilter, kyc_applicantsWhereInput>
  }, "id">

  export type kyc_audit_logOrderByWithAggregationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    action?: SortOrder
    performed_by?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: kyc_audit_logCountOrderByAggregateInput
    _avg?: kyc_audit_logAvgOrderByAggregateInput
    _max?: kyc_audit_logMaxOrderByAggregateInput
    _min?: kyc_audit_logMinOrderByAggregateInput
    _sum?: kyc_audit_logSumOrderByAggregateInput
  }

  export type kyc_audit_logScalarWhereWithAggregatesInput = {
    AND?: kyc_audit_logScalarWhereWithAggregatesInput | kyc_audit_logScalarWhereWithAggregatesInput[]
    OR?: kyc_audit_logScalarWhereWithAggregatesInput[]
    NOT?: kyc_audit_logScalarWhereWithAggregatesInput | kyc_audit_logScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kyc_audit_log"> | number
    applicant_id?: StringWithAggregatesFilter<"kyc_audit_log"> | string
    action?: StringWithAggregatesFilter<"kyc_audit_log"> | string
    performed_by?: StringNullableWithAggregatesFilter<"kyc_audit_log"> | string | null
    details?: StringNullableWithAggregatesFilter<"kyc_audit_log"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"kyc_audit_log"> | Date | string
  }

  export type kyc_complete_recordsWhereInput = {
    AND?: kyc_complete_recordsWhereInput | kyc_complete_recordsWhereInput[]
    OR?: kyc_complete_recordsWhereInput[]
    NOT?: kyc_complete_recordsWhereInput | kyc_complete_recordsWhereInput[]
    id?: IntFilter<"kyc_complete_records"> | number
    applicant_id?: StringFilter<"kyc_complete_records"> | string
    user_id?: IntNullableFilter<"kyc_complete_records"> | number | null
    status?: StringFilter<"kyc_complete_records"> | string
    result?: StringNullableFilter<"kyc_complete_records"> | string | null
    complete_data?: JsonNullableFilter<"kyc_complete_records">
    collected_at?: DateTimeFilter<"kyc_complete_records"> | Date | string
    updated_at?: DateTimeFilter<"kyc_complete_records"> | Date | string
    created_at?: DateTimeFilter<"kyc_complete_records"> | Date | string
    kyc_addresses?: Kyc_addressesListRelationFilter
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    kyc_documents?: KycDocumentListRelationFilter
    kyc_personal_info?: XOR<Kyc_personal_infoNullableRelationFilter, kyc_personal_infoWhereInput> | null
    kyc_verification_events?: Kyc_verification_eventsListRelationFilter
  }

  export type kyc_complete_recordsOrderByWithRelationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    complete_data?: SortOrderInput | SortOrder
    collected_at?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
    kyc_addresses?: kyc_addressesOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    kyc_documents?: KycDocumentOrderByRelationAggregateInput
    kyc_personal_info?: kyc_personal_infoOrderByWithRelationInput
    kyc_verification_events?: kyc_verification_eventsOrderByRelationAggregateInput
  }

  export type kyc_complete_recordsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    applicant_id?: string
    AND?: kyc_complete_recordsWhereInput | kyc_complete_recordsWhereInput[]
    OR?: kyc_complete_recordsWhereInput[]
    NOT?: kyc_complete_recordsWhereInput | kyc_complete_recordsWhereInput[]
    user_id?: IntNullableFilter<"kyc_complete_records"> | number | null
    status?: StringFilter<"kyc_complete_records"> | string
    result?: StringNullableFilter<"kyc_complete_records"> | string | null
    complete_data?: JsonNullableFilter<"kyc_complete_records">
    collected_at?: DateTimeFilter<"kyc_complete_records"> | Date | string
    updated_at?: DateTimeFilter<"kyc_complete_records"> | Date | string
    created_at?: DateTimeFilter<"kyc_complete_records"> | Date | string
    kyc_addresses?: Kyc_addressesListRelationFilter
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    kyc_documents?: KycDocumentListRelationFilter
    kyc_personal_info?: XOR<Kyc_personal_infoNullableRelationFilter, kyc_personal_infoWhereInput> | null
    kyc_verification_events?: Kyc_verification_eventsListRelationFilter
  }, "id" | "applicant_id">

  export type kyc_complete_recordsOrderByWithAggregationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    status?: SortOrder
    result?: SortOrderInput | SortOrder
    complete_data?: SortOrderInput | SortOrder
    collected_at?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
    _count?: kyc_complete_recordsCountOrderByAggregateInput
    _avg?: kyc_complete_recordsAvgOrderByAggregateInput
    _max?: kyc_complete_recordsMaxOrderByAggregateInput
    _min?: kyc_complete_recordsMinOrderByAggregateInput
    _sum?: kyc_complete_recordsSumOrderByAggregateInput
  }

  export type kyc_complete_recordsScalarWhereWithAggregatesInput = {
    AND?: kyc_complete_recordsScalarWhereWithAggregatesInput | kyc_complete_recordsScalarWhereWithAggregatesInput[]
    OR?: kyc_complete_recordsScalarWhereWithAggregatesInput[]
    NOT?: kyc_complete_recordsScalarWhereWithAggregatesInput | kyc_complete_recordsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kyc_complete_records"> | number
    applicant_id?: StringWithAggregatesFilter<"kyc_complete_records"> | string
    user_id?: IntNullableWithAggregatesFilter<"kyc_complete_records"> | number | null
    status?: StringWithAggregatesFilter<"kyc_complete_records"> | string
    result?: StringNullableWithAggregatesFilter<"kyc_complete_records"> | string | null
    complete_data?: JsonNullableWithAggregatesFilter<"kyc_complete_records">
    collected_at?: DateTimeWithAggregatesFilter<"kyc_complete_records"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"kyc_complete_records"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"kyc_complete_records"> | Date | string
  }

  export type kyc_personal_infoWhereInput = {
    AND?: kyc_personal_infoWhereInput | kyc_personal_infoWhereInput[]
    OR?: kyc_personal_infoWhereInput[]
    NOT?: kyc_personal_infoWhereInput | kyc_personal_infoWhereInput[]
    id?: IntFilter<"kyc_personal_info"> | number
    applicant_id?: StringNullableFilter<"kyc_personal_info"> | string | null
    record_id?: IntNullableFilter<"kyc_personal_info"> | number | null
    first_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    last_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    middle_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    full_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    legal_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    gender?: StringNullableFilter<"kyc_personal_info"> | string | null
    date_of_birth?: DateTimeNullableFilter<"kyc_personal_info"> | Date | string | null
    place_of_birth?: StringNullableFilter<"kyc_personal_info"> | string | null
    country_of_birth?: StringNullableFilter<"kyc_personal_info"> | string | null
    state_of_birth?: StringNullableFilter<"kyc_personal_info"> | string | null
    nationality?: StringNullableFilter<"kyc_personal_info"> | string | null
    phone?: StringNullableFilter<"kyc_personal_info"> | string | null
    email?: StringNullableFilter<"kyc_personal_info"> | string | null
    country?: StringNullableFilter<"kyc_personal_info"> | string | null
    tax_residence_country?: StringNullableFilter<"kyc_personal_info"> | string | null
    tax_identification_number?: StringNullableFilter<"kyc_personal_info"> | string | null
    id_number?: StringNullableFilter<"kyc_personal_info"> | string | null
    created_at?: DateTimeFilter<"kyc_personal_info"> | Date | string
    updated_at?: DateTimeFilter<"kyc_personal_info"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsNullableRelationFilter, kyc_applicantsWhereInput> | null
    kyc_complete_records?: XOR<Kyc_complete_recordsNullableRelationFilter, kyc_complete_recordsWhereInput> | null
  }

  export type kyc_personal_infoOrderByWithRelationInput = {
    id?: SortOrder
    applicant_id?: SortOrderInput | SortOrder
    record_id?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    middle_name?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    legal_name?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    place_of_birth?: SortOrderInput | SortOrder
    country_of_birth?: SortOrderInput | SortOrder
    state_of_birth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    tax_residence_country?: SortOrderInput | SortOrder
    tax_identification_number?: SortOrderInput | SortOrder
    id_number?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    kyc_applicants?: kyc_applicantsOrderByWithRelationInput
    kyc_complete_records?: kyc_complete_recordsOrderByWithRelationInput
  }

  export type kyc_personal_infoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    record_id?: number
    AND?: kyc_personal_infoWhereInput | kyc_personal_infoWhereInput[]
    OR?: kyc_personal_infoWhereInput[]
    NOT?: kyc_personal_infoWhereInput | kyc_personal_infoWhereInput[]
    applicant_id?: StringNullableFilter<"kyc_personal_info"> | string | null
    first_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    last_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    middle_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    full_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    legal_name?: StringNullableFilter<"kyc_personal_info"> | string | null
    gender?: StringNullableFilter<"kyc_personal_info"> | string | null
    date_of_birth?: DateTimeNullableFilter<"kyc_personal_info"> | Date | string | null
    place_of_birth?: StringNullableFilter<"kyc_personal_info"> | string | null
    country_of_birth?: StringNullableFilter<"kyc_personal_info"> | string | null
    state_of_birth?: StringNullableFilter<"kyc_personal_info"> | string | null
    nationality?: StringNullableFilter<"kyc_personal_info"> | string | null
    phone?: StringNullableFilter<"kyc_personal_info"> | string | null
    email?: StringNullableFilter<"kyc_personal_info"> | string | null
    country?: StringNullableFilter<"kyc_personal_info"> | string | null
    tax_residence_country?: StringNullableFilter<"kyc_personal_info"> | string | null
    tax_identification_number?: StringNullableFilter<"kyc_personal_info"> | string | null
    id_number?: StringNullableFilter<"kyc_personal_info"> | string | null
    created_at?: DateTimeFilter<"kyc_personal_info"> | Date | string
    updated_at?: DateTimeFilter<"kyc_personal_info"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsNullableRelationFilter, kyc_applicantsWhereInput> | null
    kyc_complete_records?: XOR<Kyc_complete_recordsNullableRelationFilter, kyc_complete_recordsWhereInput> | null
  }, "id" | "record_id">

  export type kyc_personal_infoOrderByWithAggregationInput = {
    id?: SortOrder
    applicant_id?: SortOrderInput | SortOrder
    record_id?: SortOrderInput | SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    middle_name?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    legal_name?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    date_of_birth?: SortOrderInput | SortOrder
    place_of_birth?: SortOrderInput | SortOrder
    country_of_birth?: SortOrderInput | SortOrder
    state_of_birth?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    tax_residence_country?: SortOrderInput | SortOrder
    tax_identification_number?: SortOrderInput | SortOrder
    id_number?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: kyc_personal_infoCountOrderByAggregateInput
    _avg?: kyc_personal_infoAvgOrderByAggregateInput
    _max?: kyc_personal_infoMaxOrderByAggregateInput
    _min?: kyc_personal_infoMinOrderByAggregateInput
    _sum?: kyc_personal_infoSumOrderByAggregateInput
  }

  export type kyc_personal_infoScalarWhereWithAggregatesInput = {
    AND?: kyc_personal_infoScalarWhereWithAggregatesInput | kyc_personal_infoScalarWhereWithAggregatesInput[]
    OR?: kyc_personal_infoScalarWhereWithAggregatesInput[]
    NOT?: kyc_personal_infoScalarWhereWithAggregatesInput | kyc_personal_infoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kyc_personal_info"> | number
    applicant_id?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    record_id?: IntNullableWithAggregatesFilter<"kyc_personal_info"> | number | null
    first_name?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    middle_name?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    full_name?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    legal_name?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    gender?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    date_of_birth?: DateTimeNullableWithAggregatesFilter<"kyc_personal_info"> | Date | string | null
    place_of_birth?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    country_of_birth?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    state_of_birth?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    phone?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    email?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    country?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    tax_residence_country?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    tax_identification_number?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    id_number?: StringNullableWithAggregatesFilter<"kyc_personal_info"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"kyc_personal_info"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"kyc_personal_info"> | Date | string
  }

  export type kyc_raw_dataWhereInput = {
    AND?: kyc_raw_dataWhereInput | kyc_raw_dataWhereInput[]
    OR?: kyc_raw_dataWhereInput[]
    NOT?: kyc_raw_dataWhereInput | kyc_raw_dataWhereInput[]
    id?: IntFilter<"kyc_raw_data"> | number
    applicant_id?: StringFilter<"kyc_raw_data"> | string
    data_type?: StringFilter<"kyc_raw_data"> | string
    source?: StringFilter<"kyc_raw_data"> | string
    raw_data?: StringFilter<"kyc_raw_data"> | string
    created_at?: DateTimeFilter<"kyc_raw_data"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsRelationFilter, kyc_applicantsWhereInput>
  }

  export type kyc_raw_dataOrderByWithRelationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    data_type?: SortOrder
    source?: SortOrder
    raw_data?: SortOrder
    created_at?: SortOrder
    kyc_applicants?: kyc_applicantsOrderByWithRelationInput
  }

  export type kyc_raw_dataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kyc_raw_dataWhereInput | kyc_raw_dataWhereInput[]
    OR?: kyc_raw_dataWhereInput[]
    NOT?: kyc_raw_dataWhereInput | kyc_raw_dataWhereInput[]
    applicant_id?: StringFilter<"kyc_raw_data"> | string
    data_type?: StringFilter<"kyc_raw_data"> | string
    source?: StringFilter<"kyc_raw_data"> | string
    raw_data?: StringFilter<"kyc_raw_data"> | string
    created_at?: DateTimeFilter<"kyc_raw_data"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsRelationFilter, kyc_applicantsWhereInput>
  }, "id">

  export type kyc_raw_dataOrderByWithAggregationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    data_type?: SortOrder
    source?: SortOrder
    raw_data?: SortOrder
    created_at?: SortOrder
    _count?: kyc_raw_dataCountOrderByAggregateInput
    _avg?: kyc_raw_dataAvgOrderByAggregateInput
    _max?: kyc_raw_dataMaxOrderByAggregateInput
    _min?: kyc_raw_dataMinOrderByAggregateInput
    _sum?: kyc_raw_dataSumOrderByAggregateInput
  }

  export type kyc_raw_dataScalarWhereWithAggregatesInput = {
    AND?: kyc_raw_dataScalarWhereWithAggregatesInput | kyc_raw_dataScalarWhereWithAggregatesInput[]
    OR?: kyc_raw_dataScalarWhereWithAggregatesInput[]
    NOT?: kyc_raw_dataScalarWhereWithAggregatesInput | kyc_raw_dataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kyc_raw_data"> | number
    applicant_id?: StringWithAggregatesFilter<"kyc_raw_data"> | string
    data_type?: StringWithAggregatesFilter<"kyc_raw_data"> | string
    source?: StringWithAggregatesFilter<"kyc_raw_data"> | string
    raw_data?: StringWithAggregatesFilter<"kyc_raw_data"> | string
    created_at?: DateTimeWithAggregatesFilter<"kyc_raw_data"> | Date | string
  }

  export type kyc_verification_eventsWhereInput = {
    AND?: kyc_verification_eventsWhereInput | kyc_verification_eventsWhereInput[]
    OR?: kyc_verification_eventsWhereInput[]
    NOT?: kyc_verification_eventsWhereInput | kyc_verification_eventsWhereInput[]
    id?: IntFilter<"kyc_verification_events"> | number
    record_id?: IntFilter<"kyc_verification_events"> | number
    type?: StringFilter<"kyc_verification_events"> | string
    review_status?: StringNullableFilter<"kyc_verification_events"> | string | null
    review_result?: StringNullableFilter<"kyc_verification_events"> | string | null
    inspection_id?: StringNullableFilter<"kyc_verification_events"> | string | null
    event_data?: JsonNullableFilter<"kyc_verification_events">
    event_timestamp?: DateTimeFilter<"kyc_verification_events"> | Date | string
    created_at?: DateTimeFilter<"kyc_verification_events"> | Date | string
    kyc_complete_records?: XOR<Kyc_complete_recordsRelationFilter, kyc_complete_recordsWhereInput>
  }

  export type kyc_verification_eventsOrderByWithRelationInput = {
    id?: SortOrder
    record_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrderInput | SortOrder
    review_result?: SortOrderInput | SortOrder
    inspection_id?: SortOrderInput | SortOrder
    event_data?: SortOrderInput | SortOrder
    event_timestamp?: SortOrder
    created_at?: SortOrder
    kyc_complete_records?: kyc_complete_recordsOrderByWithRelationInput
  }

  export type kyc_verification_eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kyc_verification_eventsWhereInput | kyc_verification_eventsWhereInput[]
    OR?: kyc_verification_eventsWhereInput[]
    NOT?: kyc_verification_eventsWhereInput | kyc_verification_eventsWhereInput[]
    record_id?: IntFilter<"kyc_verification_events"> | number
    type?: StringFilter<"kyc_verification_events"> | string
    review_status?: StringNullableFilter<"kyc_verification_events"> | string | null
    review_result?: StringNullableFilter<"kyc_verification_events"> | string | null
    inspection_id?: StringNullableFilter<"kyc_verification_events"> | string | null
    event_data?: JsonNullableFilter<"kyc_verification_events">
    event_timestamp?: DateTimeFilter<"kyc_verification_events"> | Date | string
    created_at?: DateTimeFilter<"kyc_verification_events"> | Date | string
    kyc_complete_records?: XOR<Kyc_complete_recordsRelationFilter, kyc_complete_recordsWhereInput>
  }, "id">

  export type kyc_verification_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    record_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrderInput | SortOrder
    review_result?: SortOrderInput | SortOrder
    inspection_id?: SortOrderInput | SortOrder
    event_data?: SortOrderInput | SortOrder
    event_timestamp?: SortOrder
    created_at?: SortOrder
    _count?: kyc_verification_eventsCountOrderByAggregateInput
    _avg?: kyc_verification_eventsAvgOrderByAggregateInput
    _max?: kyc_verification_eventsMaxOrderByAggregateInput
    _min?: kyc_verification_eventsMinOrderByAggregateInput
    _sum?: kyc_verification_eventsSumOrderByAggregateInput
  }

  export type kyc_verification_eventsScalarWhereWithAggregatesInput = {
    AND?: kyc_verification_eventsScalarWhereWithAggregatesInput | kyc_verification_eventsScalarWhereWithAggregatesInput[]
    OR?: kyc_verification_eventsScalarWhereWithAggregatesInput[]
    NOT?: kyc_verification_eventsScalarWhereWithAggregatesInput | kyc_verification_eventsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kyc_verification_events"> | number
    record_id?: IntWithAggregatesFilter<"kyc_verification_events"> | number
    type?: StringWithAggregatesFilter<"kyc_verification_events"> | string
    review_status?: StringNullableWithAggregatesFilter<"kyc_verification_events"> | string | null
    review_result?: StringNullableWithAggregatesFilter<"kyc_verification_events"> | string | null
    inspection_id?: StringNullableWithAggregatesFilter<"kyc_verification_events"> | string | null
    event_data?: JsonNullableWithAggregatesFilter<"kyc_verification_events">
    event_timestamp?: DateTimeWithAggregatesFilter<"kyc_verification_events"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"kyc_verification_events"> | Date | string
  }

  export type kyc_verification_historyWhereInput = {
    AND?: kyc_verification_historyWhereInput | kyc_verification_historyWhereInput[]
    OR?: kyc_verification_historyWhereInput[]
    NOT?: kyc_verification_historyWhereInput | kyc_verification_historyWhereInput[]
    id?: IntFilter<"kyc_verification_history"> | number
    applicant_id?: StringFilter<"kyc_verification_history"> | string
    type?: StringFilter<"kyc_verification_history"> | string
    review_status?: StringFilter<"kyc_verification_history"> | string
    review_result?: StringNullableFilter<"kyc_verification_history"> | string | null
    review_answer?: StringNullableFilter<"kyc_verification_history"> | string | null
    reject_type?: StringNullableFilter<"kyc_verification_history"> | string | null
    reject_labels?: StringNullableFilter<"kyc_verification_history"> | string | null
    timestamp?: DateTimeFilter<"kyc_verification_history"> | Date | string
    created_at?: DateTimeFilter<"kyc_verification_history"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsRelationFilter, kyc_applicantsWhereInput>
  }

  export type kyc_verification_historyOrderByWithRelationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrder
    review_result?: SortOrderInput | SortOrder
    review_answer?: SortOrderInput | SortOrder
    reject_type?: SortOrderInput | SortOrder
    reject_labels?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    kyc_applicants?: kyc_applicantsOrderByWithRelationInput
  }

  export type kyc_verification_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: kyc_verification_historyWhereInput | kyc_verification_historyWhereInput[]
    OR?: kyc_verification_historyWhereInput[]
    NOT?: kyc_verification_historyWhereInput | kyc_verification_historyWhereInput[]
    applicant_id?: StringFilter<"kyc_verification_history"> | string
    type?: StringFilter<"kyc_verification_history"> | string
    review_status?: StringFilter<"kyc_verification_history"> | string
    review_result?: StringNullableFilter<"kyc_verification_history"> | string | null
    review_answer?: StringNullableFilter<"kyc_verification_history"> | string | null
    reject_type?: StringNullableFilter<"kyc_verification_history"> | string | null
    reject_labels?: StringNullableFilter<"kyc_verification_history"> | string | null
    timestamp?: DateTimeFilter<"kyc_verification_history"> | Date | string
    created_at?: DateTimeFilter<"kyc_verification_history"> | Date | string
    kyc_applicants?: XOR<Kyc_applicantsRelationFilter, kyc_applicantsWhereInput>
  }, "id">

  export type kyc_verification_historyOrderByWithAggregationInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrder
    review_result?: SortOrderInput | SortOrder
    review_answer?: SortOrderInput | SortOrder
    reject_type?: SortOrderInput | SortOrder
    reject_labels?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
    _count?: kyc_verification_historyCountOrderByAggregateInput
    _avg?: kyc_verification_historyAvgOrderByAggregateInput
    _max?: kyc_verification_historyMaxOrderByAggregateInput
    _min?: kyc_verification_historyMinOrderByAggregateInput
    _sum?: kyc_verification_historySumOrderByAggregateInput
  }

  export type kyc_verification_historyScalarWhereWithAggregatesInput = {
    AND?: kyc_verification_historyScalarWhereWithAggregatesInput | kyc_verification_historyScalarWhereWithAggregatesInput[]
    OR?: kyc_verification_historyScalarWhereWithAggregatesInput[]
    NOT?: kyc_verification_historyScalarWhereWithAggregatesInput | kyc_verification_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"kyc_verification_history"> | number
    applicant_id?: StringWithAggregatesFilter<"kyc_verification_history"> | string
    type?: StringWithAggregatesFilter<"kyc_verification_history"> | string
    review_status?: StringWithAggregatesFilter<"kyc_verification_history"> | string
    review_result?: StringNullableWithAggregatesFilter<"kyc_verification_history"> | string | null
    review_answer?: StringNullableWithAggregatesFilter<"kyc_verification_history"> | string | null
    reject_type?: StringNullableWithAggregatesFilter<"kyc_verification_history"> | string | null
    reject_labels?: StringNullableWithAggregatesFilter<"kyc_verification_history"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"kyc_verification_history"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"kyc_verification_history"> | Date | string
  }

  export type refreshtokenWhereInput = {
    AND?: refreshtokenWhereInput | refreshtokenWhereInput[]
    OR?: refreshtokenWhereInput[]
    NOT?: refreshtokenWhereInput | refreshtokenWhereInput[]
    id?: IntFilter<"refreshtoken"> | number
    user_id?: IntFilter<"refreshtoken"> | number
    token?: StringFilter<"refreshtoken"> | string
    expires_at?: DateTimeFilter<"refreshtoken"> | Date | string
    created_at?: DateTimeFilter<"refreshtoken"> | Date | string
    device_info?: StringNullableFilter<"refreshtoken"> | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type refreshtokenOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type refreshtokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: refreshtokenWhereInput | refreshtokenWhereInput[]
    OR?: refreshtokenWhereInput[]
    NOT?: refreshtokenWhereInput | refreshtokenWhereInput[]
    user_id?: IntFilter<"refreshtoken"> | number
    expires_at?: DateTimeFilter<"refreshtoken"> | Date | string
    created_at?: DateTimeFilter<"refreshtoken"> | Date | string
    device_info?: StringNullableFilter<"refreshtoken"> | string | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "token">

  export type refreshtokenOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrderInput | SortOrder
    _count?: refreshtokenCountOrderByAggregateInput
    _avg?: refreshtokenAvgOrderByAggregateInput
    _max?: refreshtokenMaxOrderByAggregateInput
    _min?: refreshtokenMinOrderByAggregateInput
    _sum?: refreshtokenSumOrderByAggregateInput
  }

  export type refreshtokenScalarWhereWithAggregatesInput = {
    AND?: refreshtokenScalarWhereWithAggregatesInput | refreshtokenScalarWhereWithAggregatesInput[]
    OR?: refreshtokenScalarWhereWithAggregatesInput[]
    NOT?: refreshtokenScalarWhereWithAggregatesInput | refreshtokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"refreshtoken"> | number
    user_id?: IntWithAggregatesFilter<"refreshtoken"> | number
    token?: StringWithAggregatesFilter<"refreshtoken"> | string
    expires_at?: DateTimeWithAggregatesFilter<"refreshtoken"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"refreshtoken"> | Date | string
    device_info?: StringNullableWithAggregatesFilter<"refreshtoken"> | string | null
  }

  export type userroleWhereInput = {
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    id?: IntFilter<"userrole"> | number
    user_id?: IntFilter<"userrole"> | number
    role?: StringFilter<"userrole"> | string
    created_at?: DateTimeFilter<"userrole"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type userroleOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type userroleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    user_id?: IntFilter<"userrole"> | number
    role?: StringFilter<"userrole"> | string
    created_at?: DateTimeFilter<"userrole"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type userroleOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    _count?: userroleCountOrderByAggregateInput
    _avg?: userroleAvgOrderByAggregateInput
    _max?: userroleMaxOrderByAggregateInput
    _min?: userroleMinOrderByAggregateInput
    _sum?: userroleSumOrderByAggregateInput
  }

  export type userroleScalarWhereWithAggregatesInput = {
    AND?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    OR?: userroleScalarWhereWithAggregatesInput[]
    NOT?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userrole"> | number
    user_id?: IntWithAggregatesFilter<"userrole"> | number
    role?: StringWithAggregatesFilter<"userrole"> | string
    created_at?: DateTimeWithAggregatesFilter<"userrole"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    applicant_id?: StringNullableFilter<"users"> | string | null
    is_verified?: BoolFilter<"users"> | boolean
    verification_result?: StringNullableFilter<"users"> | string | null
    admin?: XOR<AdminNullableRelationFilter, adminWhereInput> | null
    authprovider?: AuthproviderListRelationFilter
    didwallet?: DidwalletListRelationFilter
    investor?: XOR<InvestorNullableRelationFilter, investorWhereInput> | null
    issuer?: XOR<IssuerNullableRelationFilter, issuerWhereInput> | null
    kyc_applicants?: Kyc_applicantsListRelationFilter
    kyc_complete_records?: Kyc_complete_recordsListRelationFilter
    kyc_documents?: KycDocumentListRelationFilter
    kyc_verifications?: KycVerificationListRelationFilter
    refreshtoken?: RefreshtokenListRelationFilter
    userrole?: UserroleListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    applicant_id?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    verification_result?: SortOrderInput | SortOrder
    admin?: adminOrderByWithRelationInput
    authprovider?: authproviderOrderByRelationAggregateInput
    didwallet?: didwalletOrderByRelationAggregateInput
    investor?: investorOrderByWithRelationInput
    issuer?: issuerOrderByWithRelationInput
    kyc_applicants?: kyc_applicantsOrderByRelationAggregateInput
    kyc_complete_records?: kyc_complete_recordsOrderByRelationAggregateInput
    kyc_documents?: KycDocumentOrderByRelationAggregateInput
    kyc_verifications?: kycVerificationOrderByRelationAggregateInput
    refreshtoken?: refreshtokenOrderByRelationAggregateInput
    userrole?: userroleOrderByRelationAggregateInput
    wallet?: walletOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    first_name?: StringFilter<"users"> | string
    last_name?: StringFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    applicant_id?: StringNullableFilter<"users"> | string | null
    is_verified?: BoolFilter<"users"> | boolean
    verification_result?: StringNullableFilter<"users"> | string | null
    admin?: XOR<AdminNullableRelationFilter, adminWhereInput> | null
    authprovider?: AuthproviderListRelationFilter
    didwallet?: DidwalletListRelationFilter
    investor?: XOR<InvestorNullableRelationFilter, investorWhereInput> | null
    issuer?: XOR<IssuerNullableRelationFilter, issuerWhereInput> | null
    kyc_applicants?: Kyc_applicantsListRelationFilter
    kyc_complete_records?: Kyc_complete_recordsListRelationFilter
    kyc_documents?: KycDocumentListRelationFilter
    kyc_verifications?: KycVerificationListRelationFilter
    refreshtoken?: RefreshtokenListRelationFilter
    userrole?: UserroleListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, walletWhereInput> | null
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    applicant_id?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    verification_result?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    first_name?: StringWithAggregatesFilter<"users"> | string
    last_name?: StringWithAggregatesFilter<"users"> | string
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    applicant_id?: StringNullableWithAggregatesFilter<"users"> | string | null
    is_verified?: BoolWithAggregatesFilter<"users"> | boolean
    verification_result?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type walletWhereInput = {
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    id?: StringFilter<"wallet"> | string
    user_id?: IntFilter<"wallet"> | number
    issuer_id?: StringNullableFilter<"wallet"> | string | null
    address?: StringFilter<"wallet"> | string
    chain?: StringFilter<"wallet"> | string
    type?: StringFilter<"wallet"> | string
    provider?: StringFilter<"wallet"> | string
    did?: StringNullableFilter<"wallet"> | string | null
    created_at?: DateTimeFilter<"wallet"> | Date | string
    updated_at?: DateTimeFilter<"wallet"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    issuer?: XOR<IssuerNullableRelationFilter, issuerWhereInput> | null
  }

  export type walletOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    issuer_id?: SortOrderInput | SortOrder
    address?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    did?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    users?: usersOrderByWithRelationInput
    issuer?: issuerOrderByWithRelationInput
  }

  export type walletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: number
    issuer_id?: string
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    address?: StringFilter<"wallet"> | string
    chain?: StringFilter<"wallet"> | string
    type?: StringFilter<"wallet"> | string
    provider?: StringFilter<"wallet"> | string
    did?: StringNullableFilter<"wallet"> | string | null
    created_at?: DateTimeFilter<"wallet"> | Date | string
    updated_at?: DateTimeFilter<"wallet"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    issuer?: XOR<IssuerNullableRelationFilter, issuerWhereInput> | null
  }, "id" | "user_id" | "issuer_id">

  export type walletOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    issuer_id?: SortOrderInput | SortOrder
    address?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    did?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: walletCountOrderByAggregateInput
    _avg?: walletAvgOrderByAggregateInput
    _max?: walletMaxOrderByAggregateInput
    _min?: walletMinOrderByAggregateInput
    _sum?: walletSumOrderByAggregateInput
  }

  export type walletScalarWhereWithAggregatesInput = {
    AND?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    OR?: walletScalarWhereWithAggregatesInput[]
    NOT?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"wallet"> | string
    user_id?: IntWithAggregatesFilter<"wallet"> | number
    issuer_id?: StringNullableWithAggregatesFilter<"wallet"> | string | null
    address?: StringWithAggregatesFilter<"wallet"> | string
    chain?: StringWithAggregatesFilter<"wallet"> | string
    type?: StringWithAggregatesFilter<"wallet"> | string
    provider?: StringWithAggregatesFilter<"wallet"> | string
    did?: StringNullableWithAggregatesFilter<"wallet"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"wallet"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"wallet"> | Date | string
  }

  export type webhookLogWhereInput = {
    AND?: webhookLogWhereInput | webhookLogWhereInput[]
    OR?: webhookLogWhereInput[]
    NOT?: webhookLogWhereInput | webhookLogWhereInput[]
    id?: IntFilter<"webhookLog"> | number
    type?: StringFilter<"webhookLog"> | string
    payload?: JsonFilter<"webhookLog">
    signature?: StringNullableFilter<"webhookLog"> | string | null
    status?: StringFilter<"webhookLog"> | string
    provider?: StringFilter<"webhookLog"> | string
    processed?: BoolFilter<"webhookLog"> | boolean
    processed_at?: DateTimeNullableFilter<"webhookLog"> | Date | string | null
    created_at?: DateTimeFilter<"webhookLog"> | Date | string
    updated_at?: DateTimeFilter<"webhookLog"> | Date | string
  }

  export type webhookLogOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    signature?: SortOrderInput | SortOrder
    status?: SortOrder
    provider?: SortOrder
    processed?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type webhookLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: webhookLogWhereInput | webhookLogWhereInput[]
    OR?: webhookLogWhereInput[]
    NOT?: webhookLogWhereInput | webhookLogWhereInput[]
    type?: StringFilter<"webhookLog"> | string
    payload?: JsonFilter<"webhookLog">
    signature?: StringNullableFilter<"webhookLog"> | string | null
    status?: StringFilter<"webhookLog"> | string
    provider?: StringFilter<"webhookLog"> | string
    processed?: BoolFilter<"webhookLog"> | boolean
    processed_at?: DateTimeNullableFilter<"webhookLog"> | Date | string | null
    created_at?: DateTimeFilter<"webhookLog"> | Date | string
    updated_at?: DateTimeFilter<"webhookLog"> | Date | string
  }, "id">

  export type webhookLogOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    signature?: SortOrderInput | SortOrder
    status?: SortOrder
    provider?: SortOrder
    processed?: SortOrder
    processed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: webhookLogCountOrderByAggregateInput
    _avg?: webhookLogAvgOrderByAggregateInput
    _max?: webhookLogMaxOrderByAggregateInput
    _min?: webhookLogMinOrderByAggregateInput
    _sum?: webhookLogSumOrderByAggregateInput
  }

  export type webhookLogScalarWhereWithAggregatesInput = {
    AND?: webhookLogScalarWhereWithAggregatesInput | webhookLogScalarWhereWithAggregatesInput[]
    OR?: webhookLogScalarWhereWithAggregatesInput[]
    NOT?: webhookLogScalarWhereWithAggregatesInput | webhookLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"webhookLog"> | number
    type?: StringWithAggregatesFilter<"webhookLog"> | string
    payload?: JsonWithAggregatesFilter<"webhookLog">
    signature?: StringNullableWithAggregatesFilter<"webhookLog"> | string | null
    status?: StringWithAggregatesFilter<"webhookLog"> | string
    provider?: StringWithAggregatesFilter<"webhookLog"> | string
    processed?: BoolWithAggregatesFilter<"webhookLog"> | boolean
    processed_at?: DateTimeNullableWithAggregatesFilter<"webhookLog"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"webhookLog"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"webhookLog"> | Date | string
  }

  export type kycVerificationCreateInput = {
    type: string
    applicant_id: string
    correlation_id?: string | null
    created_at?: Date | string
    error_message?: string | null
    event_timestamp: Date | string
    external_user_id?: string | null
    inspection_id?: string | null
    processing_status?: string | null
    raw_data: string
    review_result?: string | null
    review_status: string
    signature_valid: boolean
    updated_at: Date | string
    webhook_type: string
    users?: usersCreateNestedOneWithoutKyc_verificationsInput
  }

  export type kycVerificationUncheckedCreateInput = {
    id?: number
    type: string
    applicant_id: string
    correlation_id?: string | null
    created_at?: Date | string
    error_message?: string | null
    event_timestamp: Date | string
    external_user_id?: string | null
    inspection_id?: string | null
    processing_status?: string | null
    raw_data: string
    review_result?: string | null
    review_status: string
    signature_valid: boolean
    updated_at: Date | string
    user_id?: number | null
    webhook_type: string
  }

  export type kycVerificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    applicant_id?: StringFieldUpdateOperationsInput | string
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    processing_status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_data?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_status?: StringFieldUpdateOperationsInput | string
    signature_valid?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_type?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneWithoutKyc_verificationsNestedInput
  }

  export type kycVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    applicant_id?: StringFieldUpdateOperationsInput | string
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    processing_status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_data?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_status?: StringFieldUpdateOperationsInput | string
    signature_valid?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    webhook_type?: StringFieldUpdateOperationsInput | string
  }

  export type kycVerificationCreateManyInput = {
    id?: number
    type: string
    applicant_id: string
    correlation_id?: string | null
    created_at?: Date | string
    error_message?: string | null
    event_timestamp: Date | string
    external_user_id?: string | null
    inspection_id?: string | null
    processing_status?: string | null
    raw_data: string
    review_result?: string | null
    review_status: string
    signature_valid: boolean
    updated_at: Date | string
    user_id?: number | null
    webhook_type: string
  }

  export type kycVerificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    applicant_id?: StringFieldUpdateOperationsInput | string
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    processing_status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_data?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_status?: StringFieldUpdateOperationsInput | string
    signature_valid?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_type?: StringFieldUpdateOperationsInput | string
  }

  export type kycVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    applicant_id?: StringFieldUpdateOperationsInput | string
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    processing_status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_data?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_status?: StringFieldUpdateOperationsInput | string
    signature_valid?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    webhook_type?: StringFieldUpdateOperationsInput | string
  }

  export type KycDocumentCreateInput = {
    applicant_id?: string | null
    country?: string | null
    created_at?: Date | string
    document_id?: string | null
    document_sub_type?: string | null
    document_type: string
    field_name?: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url?: string | null
    id_doc_type?: string | null
    issued_date?: Date | string | null
    number?: string | null
    page_type?: string | null
    status?: string
    updated_at: Date | string
    valid_until?: Date | string | null
    kyc_complete_records?: kyc_complete_recordsCreateNestedOneWithoutKyc_documentsInput
    users?: usersCreateNestedOneWithoutKyc_documentsInput
  }

  export type KycDocumentUncheckedCreateInput = {
    id?: number
    applicant_id?: string | null
    country?: string | null
    created_at?: Date | string
    document_id?: string | null
    document_sub_type?: string | null
    document_type: string
    field_name?: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url?: string | null
    id_doc_type?: string | null
    issued_date?: Date | string | null
    number?: string | null
    page_type?: string | null
    record_id?: number | null
    status?: string
    updated_at: Date | string
    user_id?: number | null
    valid_until?: Date | string | null
  }

  export type KycDocumentUpdateInput = {
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_complete_records?: kyc_complete_recordsUpdateOneWithoutKyc_documentsNestedInput
    users?: usersUpdateOneWithoutKyc_documentsNestedInput
  }

  export type KycDocumentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KycDocumentCreateManyInput = {
    id?: number
    applicant_id?: string | null
    country?: string | null
    created_at?: Date | string
    document_id?: string | null
    document_sub_type?: string | null
    document_type: string
    field_name?: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url?: string | null
    id_doc_type?: string | null
    issued_date?: Date | string | null
    number?: string | null
    page_type?: string | null
    record_id?: number | null
    status?: string
    updated_at: Date | string
    user_id?: number | null
    valid_until?: Date | string | null
  }

  export type KycDocumentUpdateManyMutationInput = {
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KycDocumentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminCreateInput = {
    department: string
    position: string
    last_login?: Date | string | null
    users: usersCreateNestedOneWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    id?: number
    user_id: number
    department: string
    position: string
    last_login?: Date | string | null
  }

  export type adminUpdateInput = {
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminCreateManyInput = {
    id?: number
    user_id: number
    department: string
    position: string
    last_login?: Date | string | null
  }

  export type adminUpdateManyMutationInput = {
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type authproviderCreateInput = {
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
    users: usersCreateNestedOneWithoutAuthproviderInput
  }

  export type authproviderUncheckedCreateInput = {
    id?: number
    user_id: number
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type authproviderUpdateInput = {
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutAuthproviderNestedInput
  }

  export type authproviderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authproviderCreateManyInput = {
    id?: number
    user_id: number
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type authproviderUpdateManyMutationInput = {
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authproviderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletCreateInput = {
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
    users: usersCreateNestedOneWithoutDidwalletInput
  }

  export type didwalletUncheckedCreateInput = {
    id?: number
    user_id: number
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletUpdateInput = {
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutDidwalletNestedInput
  }

  export type didwalletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletCreateManyInput = {
    id?: number
    user_id: number
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletUpdateManyMutationInput = {
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type investorCreateInput = {
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
    users: usersCreateNestedOneWithoutInvestorInput
  }

  export type investorUncheckedCreateInput = {
    id?: number
    user_id: number
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorUpdateInput = {
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneRequiredWithoutInvestorNestedInput
  }

  export type investorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type investorCreateManyInput = {
    id?: number
    user_id: number
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorUpdateManyMutationInput = {
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type investorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type issuerCreateInput = {
    id?: string
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_kyb_completed?: boolean
    mobile_number?: string | null
    platform_client_id?: string | null
    registration_date?: Date | string
    sumsub_applicant_id?: string | null
    sumsub_correlation_id?: string | null
    sumsub_external_id?: string | null
    sumsub_inspection_id?: string | null
    did?: string | null
    did_created_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutIssuerInput
    wallet?: walletCreateNestedOneWithoutIssuerInput
  }

  export type issuerUncheckedCreateInput = {
    id?: string
    user_id: number
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_kyb_completed?: boolean
    mobile_number?: string | null
    platform_client_id?: string | null
    registration_date?: Date | string
    sumsub_applicant_id?: string | null
    sumsub_correlation_id?: string | null
    sumsub_external_id?: string | null
    sumsub_inspection_id?: string | null
    did?: string | null
    did_created_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    wallet?: walletUncheckedCreateNestedOneWithoutIssuerInput
  }

  export type issuerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_kyb_completed?: BoolFieldUpdateOperationsInput | boolean
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    platform_client_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sumsub_applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_external_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    did?: NullableStringFieldUpdateOperationsInput | string | null
    did_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutIssuerNestedInput
    wallet?: walletUpdateOneWithoutIssuerNestedInput
  }

  export type issuerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_kyb_completed?: BoolFieldUpdateOperationsInput | boolean
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    platform_client_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sumsub_applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_external_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    did?: NullableStringFieldUpdateOperationsInput | string | null
    did_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: walletUncheckedUpdateOneWithoutIssuerNestedInput
  }

  export type issuerCreateManyInput = {
    id?: string
    user_id: number
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_kyb_completed?: boolean
    mobile_number?: string | null
    platform_client_id?: string | null
    registration_date?: Date | string
    sumsub_applicant_id?: string | null
    sumsub_correlation_id?: string | null
    sumsub_external_id?: string | null
    sumsub_inspection_id?: string | null
    did?: string | null
    did_created_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type issuerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_kyb_completed?: BoolFieldUpdateOperationsInput | boolean
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    platform_client_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sumsub_applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_external_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    did?: NullableStringFieldUpdateOperationsInput | string | null
    did_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type issuerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_kyb_completed?: BoolFieldUpdateOperationsInput | boolean
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    platform_client_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sumsub_applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_external_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    did?: NullableStringFieldUpdateOperationsInput | string | null
    did_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_address_infoCreateInput = {
    address_type: string
    is_primary?: boolean
    street?: string | null
    street_line2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    verification_method?: string | null
    created_at?: Date | string
    updated_at: Date | string
    kyc_applicants: kyc_applicantsCreateNestedOneWithoutKyc_address_infoInput
  }

  export type kyc_address_infoUncheckedCreateInput = {
    id?: number
    applicant_id: string
    address_type: string
    is_primary?: boolean
    street?: string | null
    street_line2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    verification_method?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type kyc_address_infoUpdateInput = {
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_method?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_applicants?: kyc_applicantsUpdateOneRequiredWithoutKyc_address_infoNestedInput
  }

  export type kyc_address_infoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_method?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_address_infoCreateManyInput = {
    id?: number
    applicant_id: string
    address_type: string
    is_primary?: boolean
    street?: string | null
    street_line2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    verification_method?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type kyc_address_infoUpdateManyMutationInput = {
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_method?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_address_infoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_method?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_addressesCreateInput = {
    address_type?: string
    is_primary?: boolean
    street?: string | null
    street_line_2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    updated_at: Date | string
    created_at?: Date | string
    kyc_complete_records: kyc_complete_recordsCreateNestedOneWithoutKyc_addressesInput
  }

  export type kyc_addressesUncheckedCreateInput = {
    id?: number
    record_id: number
    address_type?: string
    is_primary?: boolean
    street?: string | null
    street_line_2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    updated_at: Date | string
    created_at?: Date | string
  }

  export type kyc_addressesUpdateInput = {
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_complete_records?: kyc_complete_recordsUpdateOneRequiredWithoutKyc_addressesNestedInput
  }

  export type kyc_addressesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: IntFieldUpdateOperationsInput | number
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_addressesCreateManyInput = {
    id?: number
    record_id: number
    address_type?: string
    is_primary?: boolean
    street?: string | null
    street_line_2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    updated_at: Date | string
    created_at?: Date | string
  }

  export type kyc_addressesUpdateManyMutationInput = {
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_addressesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: IntFieldUpdateOperationsInput | number
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_applicantsCreateInput = {
    applicant_id: string
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    kyc_address_info?: kyc_address_infoCreateNestedManyWithoutKyc_applicantsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_applicantsInput
    users?: usersCreateNestedOneWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsUncheckedCreateInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    personal_info_id?: number | null
    kyc_address_info?: kyc_address_infoUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyUncheckedCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsUpdateInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    kyc_address_info?: kyc_address_infoUpdateManyWithoutKyc_applicantsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_applicantsNestedInput
    users?: usersUpdateOneWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_applicantsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    personal_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    kyc_address_info?: kyc_address_infoUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUncheckedUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_applicantsCreateManyInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    personal_info_id?: number | null
  }

  export type kyc_applicantsUpdateManyMutationInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
  }

  export type kyc_applicantsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    personal_info_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type kyc_audit_logCreateInput = {
    action: string
    performed_by?: string | null
    details?: string | null
    timestamp?: Date | string
    kyc_applicants: kyc_applicantsCreateNestedOneWithoutKyc_audit_logInput
  }

  export type kyc_audit_logUncheckedCreateInput = {
    id?: number
    applicant_id: string
    action: string
    performed_by?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type kyc_audit_logUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_applicants?: kyc_applicantsUpdateOneRequiredWithoutKyc_audit_logNestedInput
  }

  export type kyc_audit_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_audit_logCreateManyInput = {
    id?: number
    applicant_id: string
    action: string
    performed_by?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type kyc_audit_logUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_audit_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_complete_recordsCreateInput = {
    applicant_id: string
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesCreateNestedManyWithoutKyc_complete_recordsInput
    users?: usersCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsUncheckedCreateInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoUncheckedCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsUpdateInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUpdateManyWithoutKyc_complete_recordsNestedInput
    users?: usersUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_complete_recordsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUncheckedUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_complete_recordsCreateManyInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
  }

  export type kyc_complete_recordsUpdateManyMutationInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_complete_recordsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_personal_infoCreateInput = {
    applicant_id?: string | null
    first_name?: string | null
    last_name?: string | null
    middle_name?: string | null
    full_name?: string | null
    legal_name?: string | null
    gender?: string | null
    date_of_birth?: Date | string | null
    place_of_birth?: string | null
    country_of_birth?: string | null
    state_of_birth?: string | null
    nationality?: string | null
    phone?: string | null
    email?: string | null
    country?: string | null
    tax_residence_country?: string | null
    tax_identification_number?: string | null
    id_number?: string | null
    created_at?: Date | string
    updated_at: Date | string
    kyc_applicants?: kyc_applicantsCreateNestedOneWithoutKyc_personal_infoInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedOneWithoutKyc_personal_infoInput
  }

  export type kyc_personal_infoUncheckedCreateInput = {
    id?: number
    applicant_id?: string | null
    record_id?: number | null
    first_name?: string | null
    last_name?: string | null
    middle_name?: string | null
    full_name?: string | null
    legal_name?: string | null
    gender?: string | null
    date_of_birth?: Date | string | null
    place_of_birth?: string | null
    country_of_birth?: string | null
    state_of_birth?: string | null
    nationality?: string | null
    phone?: string | null
    email?: string | null
    country?: string | null
    tax_residence_country?: string | null
    tax_identification_number?: string | null
    id_number?: string | null
    created_at?: Date | string
    updated_at: Date | string
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedOneWithoutKyc_personal_infoInput
  }

  export type kyc_personal_infoUpdateInput = {
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    country_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    state_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_residence_country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_identification_number?: NullableStringFieldUpdateOperationsInput | string | null
    id_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_applicants?: kyc_applicantsUpdateOneWithoutKyc_personal_infoNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateOneWithoutKyc_personal_infoNestedInput
  }

  export type kyc_personal_infoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    country_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    state_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_residence_country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_identification_number?: NullableStringFieldUpdateOperationsInput | string | null
    id_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_applicants?: kyc_applicantsUncheckedUpdateOneWithoutKyc_personal_infoNestedInput
  }

  export type kyc_personal_infoCreateManyInput = {
    id?: number
    applicant_id?: string | null
    record_id?: number | null
    first_name?: string | null
    last_name?: string | null
    middle_name?: string | null
    full_name?: string | null
    legal_name?: string | null
    gender?: string | null
    date_of_birth?: Date | string | null
    place_of_birth?: string | null
    country_of_birth?: string | null
    state_of_birth?: string | null
    nationality?: string | null
    phone?: string | null
    email?: string | null
    country?: string | null
    tax_residence_country?: string | null
    tax_identification_number?: string | null
    id_number?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type kyc_personal_infoUpdateManyMutationInput = {
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    country_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    state_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_residence_country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_identification_number?: NullableStringFieldUpdateOperationsInput | string | null
    id_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_personal_infoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    country_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    state_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_residence_country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_identification_number?: NullableStringFieldUpdateOperationsInput | string | null
    id_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_raw_dataCreateInput = {
    data_type: string
    source: string
    raw_data: string
    created_at?: Date | string
    kyc_applicants: kyc_applicantsCreateNestedOneWithoutKyc_raw_dataInput
  }

  export type kyc_raw_dataUncheckedCreateInput = {
    id?: number
    applicant_id: string
    data_type: string
    source: string
    raw_data: string
    created_at?: Date | string
  }

  export type kyc_raw_dataUpdateInput = {
    data_type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    raw_data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_applicants?: kyc_applicantsUpdateOneRequiredWithoutKyc_raw_dataNestedInput
  }

  export type kyc_raw_dataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    data_type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    raw_data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_raw_dataCreateManyInput = {
    id?: number
    applicant_id: string
    data_type: string
    source: string
    raw_data: string
    created_at?: Date | string
  }

  export type kyc_raw_dataUpdateManyMutationInput = {
    data_type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    raw_data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_raw_dataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    data_type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    raw_data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_eventsCreateInput = {
    type?: string
    review_status?: string | null
    review_result?: string | null
    inspection_id?: string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp: Date | string
    created_at?: Date | string
    kyc_complete_records: kyc_complete_recordsCreateNestedOneWithoutKyc_verification_eventsInput
  }

  export type kyc_verification_eventsUncheckedCreateInput = {
    id?: number
    record_id: number
    type?: string
    review_status?: string | null
    review_result?: string | null
    inspection_id?: string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_verification_eventsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    review_status?: NullableStringFieldUpdateOperationsInput | string | null
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_complete_records?: kyc_complete_recordsUpdateOneRequiredWithoutKyc_verification_eventsNestedInput
  }

  export type kyc_verification_eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    review_status?: NullableStringFieldUpdateOperationsInput | string | null
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_eventsCreateManyInput = {
    id?: number
    record_id: number
    type?: string
    review_status?: string | null
    review_result?: string | null
    inspection_id?: string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_verification_eventsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    review_status?: NullableStringFieldUpdateOperationsInput | string | null
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    review_status?: NullableStringFieldUpdateOperationsInput | string | null
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_historyCreateInput = {
    type: string
    review_status: string
    review_result?: string | null
    review_answer?: string | null
    reject_type?: string | null
    reject_labels?: string | null
    timestamp: Date | string
    created_at?: Date | string
    kyc_applicants: kyc_applicantsCreateNestedOneWithoutKyc_verification_historyInput
  }

  export type kyc_verification_historyUncheckedCreateInput = {
    id?: number
    applicant_id: string
    type: string
    review_status: string
    review_result?: string | null
    review_answer?: string | null
    reject_type?: string | null
    reject_labels?: string | null
    timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_verification_historyUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    review_status?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_answer?: NullableStringFieldUpdateOperationsInput | string | null
    reject_type?: NullableStringFieldUpdateOperationsInput | string | null
    reject_labels?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_applicants?: kyc_applicantsUpdateOneRequiredWithoutKyc_verification_historyNestedInput
  }

  export type kyc_verification_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    review_status?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_answer?: NullableStringFieldUpdateOperationsInput | string | null
    reject_type?: NullableStringFieldUpdateOperationsInput | string | null
    reject_labels?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_historyCreateManyInput = {
    id?: number
    applicant_id: string
    type: string
    review_status: string
    review_result?: string | null
    review_answer?: string | null
    reject_type?: string | null
    reject_labels?: string | null
    timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_verification_historyUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    review_status?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_answer?: NullableStringFieldUpdateOperationsInput | string | null
    reject_type?: NullableStringFieldUpdateOperationsInput | string | null
    reject_labels?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    review_status?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_answer?: NullableStringFieldUpdateOperationsInput | string | null
    reject_type?: NullableStringFieldUpdateOperationsInput | string | null
    reject_labels?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refreshtokenCreateInput = {
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
    users: usersCreateNestedOneWithoutRefreshtokenInput
  }

  export type refreshtokenUncheckedCreateInput = {
    id?: number
    user_id: number
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type refreshtokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateOneRequiredWithoutRefreshtokenNestedInput
  }

  export type refreshtokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refreshtokenCreateManyInput = {
    id?: number
    user_id: number
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type refreshtokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refreshtokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userroleCreateInput = {
    role: string
    created_at?: Date | string
    users: usersCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateInput = {
    id?: number
    user_id: number
    role: string
    created_at?: Date | string
  }

  export type userroleUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroleCreateManyInput = {
    id?: number
    user_id: number
    role: string
    created_at?: Date | string
  }

  export type userroleUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletCreateInput = {
    id?: string
    address: string
    chain?: string
    type?: string
    provider?: string
    did?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutWalletInput
    issuer?: issuerCreateNestedOneWithoutWalletInput
  }

  export type walletUncheckedCreateInput = {
    id?: string
    user_id: number
    issuer_id?: string | null
    address: string
    chain?: string
    type?: string
    provider?: string
    did?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type walletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    did?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutWalletNestedInput
    issuer?: issuerUpdateOneWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    issuer_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    did?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletCreateManyInput = {
    id?: string
    user_id: number
    issuer_id?: string | null
    address: string
    chain?: string
    type?: string
    provider?: string
    did?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type walletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    did?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    issuer_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    did?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookLogCreateInput = {
    type: string
    payload: JsonNullValueInput | InputJsonValue
    signature?: string | null
    status?: string
    provider?: string
    processed?: boolean
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type webhookLogUncheckedCreateInput = {
    id?: number
    type: string
    payload: JsonNullValueInput | InputJsonValue
    signature?: string | null
    status?: string
    provider?: string
    processed?: boolean
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type webhookLogUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookLogCreateManyInput = {
    id?: number
    type: string
    payload: JsonNullValueInput | InputJsonValue
    signature?: string | null
    status?: string
    provider?: string
    processed?: boolean
    processed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type webhookLogUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type webhookLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    processed?: BoolFieldUpdateOperationsInput | boolean
    processed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type kycVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    applicant_id?: SortOrder
    correlation_id?: SortOrder
    created_at?: SortOrder
    error_message?: SortOrder
    event_timestamp?: SortOrder
    external_user_id?: SortOrder
    inspection_id?: SortOrder
    processing_status?: SortOrder
    raw_data?: SortOrder
    review_result?: SortOrder
    review_status?: SortOrder
    signature_valid?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    webhook_type?: SortOrder
  }

  export type kycVerificationAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type kycVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    applicant_id?: SortOrder
    correlation_id?: SortOrder
    created_at?: SortOrder
    error_message?: SortOrder
    event_timestamp?: SortOrder
    external_user_id?: SortOrder
    inspection_id?: SortOrder
    processing_status?: SortOrder
    raw_data?: SortOrder
    review_result?: SortOrder
    review_status?: SortOrder
    signature_valid?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    webhook_type?: SortOrder
  }

  export type kycVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    applicant_id?: SortOrder
    correlation_id?: SortOrder
    created_at?: SortOrder
    error_message?: SortOrder
    event_timestamp?: SortOrder
    external_user_id?: SortOrder
    inspection_id?: SortOrder
    processing_status?: SortOrder
    raw_data?: SortOrder
    review_result?: SortOrder
    review_status?: SortOrder
    signature_valid?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    webhook_type?: SortOrder
  }

  export type kycVerificationSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Kyc_complete_recordsNullableRelationFilter = {
    is?: kyc_complete_recordsWhereInput | null
    isNot?: kyc_complete_recordsWhereInput | null
  }

  export type KycDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    country?: SortOrder
    created_at?: SortOrder
    document_id?: SortOrder
    document_sub_type?: SortOrder
    document_type?: SortOrder
    field_name?: SortOrder
    file_name?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrder
    id_doc_type?: SortOrder
    issued_date?: SortOrder
    number?: SortOrder
    page_type?: SortOrder
    record_id?: SortOrder
    status?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    valid_until?: SortOrder
  }

  export type KycDocumentAvgOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    user_id?: SortOrder
  }

  export type KycDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    country?: SortOrder
    created_at?: SortOrder
    document_id?: SortOrder
    document_sub_type?: SortOrder
    document_type?: SortOrder
    field_name?: SortOrder
    file_name?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrder
    id_doc_type?: SortOrder
    issued_date?: SortOrder
    number?: SortOrder
    page_type?: SortOrder
    record_id?: SortOrder
    status?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    valid_until?: SortOrder
  }

  export type KycDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    country?: SortOrder
    created_at?: SortOrder
    document_id?: SortOrder
    document_sub_type?: SortOrder
    document_type?: SortOrder
    field_name?: SortOrder
    file_name?: SortOrder
    file_path?: SortOrder
    file_type?: SortOrder
    file_url?: SortOrder
    id_doc_type?: SortOrder
    issued_date?: SortOrder
    number?: SortOrder
    page_type?: SortOrder
    record_id?: SortOrder
    status?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    valid_until?: SortOrder
  }

  export type KycDocumentSumOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    user_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type adminCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type authproviderCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    provider_data?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type authproviderAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type authproviderMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type authproviderMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type authproviderSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type didwalletCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type didwalletAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type didwalletMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type didwalletMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type didwalletSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type investorCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrder
    kyc_documents?: SortOrder
    aml_documents?: SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
  }

  export type investorAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type investorMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
  }

  export type investorMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
  }

  export type investorSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type WalletNullableRelationFilter = {
    is?: walletWhereInput | null
    isNot?: walletWhereInput | null
  }

  export type issuerCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrder
    company_documents?: SortOrder
    is_active?: SortOrder
    is_kyb_completed?: SortOrder
    mobile_number?: SortOrder
    platform_client_id?: SortOrder
    registration_date?: SortOrder
    sumsub_applicant_id?: SortOrder
    sumsub_correlation_id?: SortOrder
    sumsub_external_id?: SortOrder
    sumsub_inspection_id?: SortOrder
    did?: SortOrder
    did_created_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type issuerAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type issuerMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrder
    is_active?: SortOrder
    is_kyb_completed?: SortOrder
    mobile_number?: SortOrder
    platform_client_id?: SortOrder
    registration_date?: SortOrder
    sumsub_applicant_id?: SortOrder
    sumsub_correlation_id?: SortOrder
    sumsub_external_id?: SortOrder
    sumsub_inspection_id?: SortOrder
    did?: SortOrder
    did_created_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type issuerMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrder
    is_active?: SortOrder
    is_kyb_completed?: SortOrder
    mobile_number?: SortOrder
    platform_client_id?: SortOrder
    registration_date?: SortOrder
    sumsub_applicant_id?: SortOrder
    sumsub_correlation_id?: SortOrder
    sumsub_external_id?: SortOrder
    sumsub_inspection_id?: SortOrder
    did?: SortOrder
    did_created_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type issuerSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type Kyc_applicantsRelationFilter = {
    is?: kyc_applicantsWhereInput
    isNot?: kyc_applicantsWhereInput
  }

  export type kyc_address_infoCountOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrder
    street_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_verified?: SortOrder
    verification_method?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type kyc_address_infoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kyc_address_infoMaxOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrder
    street_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_verified?: SortOrder
    verification_method?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type kyc_address_infoMinOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrder
    street_line2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_verified?: SortOrder
    verification_method?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type kyc_address_infoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Kyc_complete_recordsRelationFilter = {
    is?: kyc_complete_recordsWhereInput
    isNot?: kyc_complete_recordsWhereInput
  }

  export type kyc_addressesCountOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrder
    street_line_2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_addressesAvgOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
  }

  export type kyc_addressesMaxOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrder
    street_line_2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_addressesMinOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    address_type?: SortOrder
    is_primary?: SortOrder
    street?: SortOrder
    street_line_2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postal_code?: SortOrder
    country?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_addressesSumOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
  }

  export type Kyc_address_infoListRelationFilter = {
    every?: kyc_address_infoWhereInput
    some?: kyc_address_infoWhereInput
    none?: kyc_address_infoWhereInput
  }

  export type Kyc_personal_infoNullableRelationFilter = {
    is?: kyc_personal_infoWhereInput | null
    isNot?: kyc_personal_infoWhereInput | null
  }

  export type Kyc_audit_logListRelationFilter = {
    every?: kyc_audit_logWhereInput
    some?: kyc_audit_logWhereInput
    none?: kyc_audit_logWhereInput
  }

  export type Kyc_raw_dataListRelationFilter = {
    every?: kyc_raw_dataWhereInput
    some?: kyc_raw_dataWhereInput
    none?: kyc_raw_dataWhereInput
  }

  export type Kyc_verification_historyListRelationFilter = {
    every?: kyc_verification_historyWhereInput
    some?: kyc_verification_historyWhereInput
    none?: kyc_verification_historyWhereInput
  }

  export type kyc_address_infoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kyc_audit_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kyc_raw_dataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kyc_verification_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kyc_applicantsCountOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrder
    external_user_id?: SortOrder
    inspection_id?: SortOrder
    correlation_id?: SortOrder
    status?: SortOrder
    result?: SortOrder
    id_doc_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sandbox_mode?: SortOrder
    personal_info_id?: SortOrder
  }

  export type kyc_applicantsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    personal_info_id?: SortOrder
  }

  export type kyc_applicantsMaxOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrder
    external_user_id?: SortOrder
    inspection_id?: SortOrder
    correlation_id?: SortOrder
    status?: SortOrder
    result?: SortOrder
    id_doc_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sandbox_mode?: SortOrder
    personal_info_id?: SortOrder
  }

  export type kyc_applicantsMinOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrder
    external_user_id?: SortOrder
    inspection_id?: SortOrder
    correlation_id?: SortOrder
    status?: SortOrder
    result?: SortOrder
    id_doc_status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sandbox_mode?: SortOrder
    personal_info_id?: SortOrder
  }

  export type kyc_applicantsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    personal_info_id?: SortOrder
  }

  export type kyc_audit_logCountOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    action?: SortOrder
    performed_by?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type kyc_audit_logAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kyc_audit_logMaxOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    action?: SortOrder
    performed_by?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type kyc_audit_logMinOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    action?: SortOrder
    performed_by?: SortOrder
    details?: SortOrder
    timestamp?: SortOrder
  }

  export type kyc_audit_logSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Kyc_addressesListRelationFilter = {
    every?: kyc_addressesWhereInput
    some?: kyc_addressesWhereInput
    none?: kyc_addressesWhereInput
  }

  export type KycDocumentListRelationFilter = {
    every?: KycDocumentWhereInput
    some?: KycDocumentWhereInput
    none?: KycDocumentWhereInput
  }

  export type Kyc_verification_eventsListRelationFilter = {
    every?: kyc_verification_eventsWhereInput
    some?: kyc_verification_eventsWhereInput
    none?: kyc_verification_eventsWhereInput
  }

  export type kyc_addressesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KycDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kyc_verification_eventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kyc_complete_recordsCountOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    result?: SortOrder
    complete_data?: SortOrder
    collected_at?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_complete_recordsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type kyc_complete_recordsMaxOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    result?: SortOrder
    collected_at?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_complete_recordsMinOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    user_id?: SortOrder
    status?: SortOrder
    result?: SortOrder
    collected_at?: SortOrder
    updated_at?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_complete_recordsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type Kyc_applicantsNullableRelationFilter = {
    is?: kyc_applicantsWhereInput | null
    isNot?: kyc_applicantsWhereInput | null
  }

  export type kyc_personal_infoCountOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    record_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    middle_name?: SortOrder
    full_name?: SortOrder
    legal_name?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    place_of_birth?: SortOrder
    country_of_birth?: SortOrder
    state_of_birth?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    country?: SortOrder
    tax_residence_country?: SortOrder
    tax_identification_number?: SortOrder
    id_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type kyc_personal_infoAvgOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
  }

  export type kyc_personal_infoMaxOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    record_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    middle_name?: SortOrder
    full_name?: SortOrder
    legal_name?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    place_of_birth?: SortOrder
    country_of_birth?: SortOrder
    state_of_birth?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    country?: SortOrder
    tax_residence_country?: SortOrder
    tax_identification_number?: SortOrder
    id_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type kyc_personal_infoMinOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    record_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    middle_name?: SortOrder
    full_name?: SortOrder
    legal_name?: SortOrder
    gender?: SortOrder
    date_of_birth?: SortOrder
    place_of_birth?: SortOrder
    country_of_birth?: SortOrder
    state_of_birth?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    country?: SortOrder
    tax_residence_country?: SortOrder
    tax_identification_number?: SortOrder
    id_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type kyc_personal_infoSumOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
  }

  export type kyc_raw_dataCountOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    data_type?: SortOrder
    source?: SortOrder
    raw_data?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_raw_dataAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kyc_raw_dataMaxOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    data_type?: SortOrder
    source?: SortOrder
    raw_data?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_raw_dataMinOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    data_type?: SortOrder
    source?: SortOrder
    raw_data?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_raw_dataSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kyc_verification_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrder
    review_result?: SortOrder
    inspection_id?: SortOrder
    event_data?: SortOrder
    event_timestamp?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_verification_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
  }

  export type kyc_verification_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrder
    review_result?: SortOrder
    inspection_id?: SortOrder
    event_timestamp?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_verification_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrder
    review_result?: SortOrder
    inspection_id?: SortOrder
    event_timestamp?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_verification_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
  }

  export type kyc_verification_historyCountOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrder
    review_result?: SortOrder
    review_answer?: SortOrder
    reject_type?: SortOrder
    reject_labels?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_verification_historyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type kyc_verification_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrder
    review_result?: SortOrder
    review_answer?: SortOrder
    reject_type?: SortOrder
    reject_labels?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_verification_historyMinOrderByAggregateInput = {
    id?: SortOrder
    applicant_id?: SortOrder
    type?: SortOrder
    review_status?: SortOrder
    review_result?: SortOrder
    review_answer?: SortOrder
    reject_type?: SortOrder
    reject_labels?: SortOrder
    timestamp?: SortOrder
    created_at?: SortOrder
  }

  export type kyc_verification_historySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type refreshtokenCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrder
  }

  export type refreshtokenAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type refreshtokenMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrder
  }

  export type refreshtokenMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrder
  }

  export type refreshtokenSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type userroleCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type userroleAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type userroleMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type userroleMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type userroleSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type AdminNullableRelationFilter = {
    is?: adminWhereInput | null
    isNot?: adminWhereInput | null
  }

  export type AuthproviderListRelationFilter = {
    every?: authproviderWhereInput
    some?: authproviderWhereInput
    none?: authproviderWhereInput
  }

  export type DidwalletListRelationFilter = {
    every?: didwalletWhereInput
    some?: didwalletWhereInput
    none?: didwalletWhereInput
  }

  export type InvestorNullableRelationFilter = {
    is?: investorWhereInput | null
    isNot?: investorWhereInput | null
  }

  export type IssuerNullableRelationFilter = {
    is?: issuerWhereInput | null
    isNot?: issuerWhereInput | null
  }

  export type Kyc_applicantsListRelationFilter = {
    every?: kyc_applicantsWhereInput
    some?: kyc_applicantsWhereInput
    none?: kyc_applicantsWhereInput
  }

  export type Kyc_complete_recordsListRelationFilter = {
    every?: kyc_complete_recordsWhereInput
    some?: kyc_complete_recordsWhereInput
    none?: kyc_complete_recordsWhereInput
  }

  export type KycVerificationListRelationFilter = {
    every?: kycVerificationWhereInput
    some?: kycVerificationWhereInput
    none?: kycVerificationWhereInput
  }

  export type RefreshtokenListRelationFilter = {
    every?: refreshtokenWhereInput
    some?: refreshtokenWhereInput
    none?: refreshtokenWhereInput
  }

  export type UserroleListRelationFilter = {
    every?: userroleWhereInput
    some?: userroleWhereInput
    none?: userroleWhereInput
  }

  export type authproviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type didwalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kyc_applicantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kyc_complete_recordsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type kycVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type refreshtokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userroleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    applicant_id?: SortOrder
    is_verified?: SortOrder
    verification_result?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    applicant_id?: SortOrder
    is_verified?: SortOrder
    verification_result?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    applicant_id?: SortOrder
    is_verified?: SortOrder
    verification_result?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type walletCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    issuer_id?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    did?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type walletAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type walletMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    issuer_id?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    did?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type walletMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    issuer_id?: SortOrder
    address?: SortOrder
    chain?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    did?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type walletSumOrderByAggregateInput = {
    user_id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type webhookLogCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    payload?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    processed?: SortOrder
    processed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type webhookLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type webhookLogMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    processed?: SortOrder
    processed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type webhookLogMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    signature?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    processed?: SortOrder
    processed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type webhookLogSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type usersCreateNestedOneWithoutKyc_verificationsInput = {
    create?: XOR<usersCreateWithoutKyc_verificationsInput, usersUncheckedCreateWithoutKyc_verificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutKyc_verificationsInput
    connect?: usersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type usersUpdateOneWithoutKyc_verificationsNestedInput = {
    create?: XOR<usersCreateWithoutKyc_verificationsInput, usersUncheckedCreateWithoutKyc_verificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutKyc_verificationsInput
    upsert?: usersUpsertWithoutKyc_verificationsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutKyc_verificationsInput, usersUpdateWithoutKyc_verificationsInput>, usersUncheckedUpdateWithoutKyc_verificationsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type kyc_complete_recordsCreateNestedOneWithoutKyc_documentsInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutKyc_documentsInput, kyc_complete_recordsUncheckedCreateWithoutKyc_documentsInput>
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutKyc_documentsInput
    connect?: kyc_complete_recordsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutKyc_documentsInput = {
    create?: XOR<usersCreateWithoutKyc_documentsInput, usersUncheckedCreateWithoutKyc_documentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutKyc_documentsInput
    connect?: usersWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type kyc_complete_recordsUpdateOneWithoutKyc_documentsNestedInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutKyc_documentsInput, kyc_complete_recordsUncheckedCreateWithoutKyc_documentsInput>
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutKyc_documentsInput
    upsert?: kyc_complete_recordsUpsertWithoutKyc_documentsInput
    disconnect?: kyc_complete_recordsWhereInput | boolean
    delete?: kyc_complete_recordsWhereInput | boolean
    connect?: kyc_complete_recordsWhereUniqueInput
    update?: XOR<XOR<kyc_complete_recordsUpdateToOneWithWhereWithoutKyc_documentsInput, kyc_complete_recordsUpdateWithoutKyc_documentsInput>, kyc_complete_recordsUncheckedUpdateWithoutKyc_documentsInput>
  }

  export type usersUpdateOneWithoutKyc_documentsNestedInput = {
    create?: XOR<usersCreateWithoutKyc_documentsInput, usersUncheckedCreateWithoutKyc_documentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutKyc_documentsInput
    upsert?: usersUpsertWithoutKyc_documentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutKyc_documentsInput, usersUpdateWithoutKyc_documentsInput>, usersUncheckedUpdateWithoutKyc_documentsInput>
  }

  export type usersCreateNestedOneWithoutAdminInput = {
    create?: XOR<usersCreateWithoutAdminInput, usersUncheckedCreateWithoutAdminInput>
    connectOrCreate?: usersCreateOrConnectWithoutAdminInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<usersCreateWithoutAdminInput, usersUncheckedCreateWithoutAdminInput>
    connectOrCreate?: usersCreateOrConnectWithoutAdminInput
    upsert?: usersUpsertWithoutAdminInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAdminInput, usersUpdateWithoutAdminInput>, usersUncheckedUpdateWithoutAdminInput>
  }

  export type usersCreateNestedOneWithoutAuthproviderInput = {
    create?: XOR<usersCreateWithoutAuthproviderInput, usersUncheckedCreateWithoutAuthproviderInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuthproviderInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAuthproviderNestedInput = {
    create?: XOR<usersCreateWithoutAuthproviderInput, usersUncheckedCreateWithoutAuthproviderInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuthproviderInput
    upsert?: usersUpsertWithoutAuthproviderInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAuthproviderInput, usersUpdateWithoutAuthproviderInput>, usersUncheckedUpdateWithoutAuthproviderInput>
  }

  export type usersCreateNestedOneWithoutDidwalletInput = {
    create?: XOR<usersCreateWithoutDidwalletInput, usersUncheckedCreateWithoutDidwalletInput>
    connectOrCreate?: usersCreateOrConnectWithoutDidwalletInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutDidwalletNestedInput = {
    create?: XOR<usersCreateWithoutDidwalletInput, usersUncheckedCreateWithoutDidwalletInput>
    connectOrCreate?: usersCreateOrConnectWithoutDidwalletInput
    upsert?: usersUpsertWithoutDidwalletInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutDidwalletInput, usersUpdateWithoutDidwalletInput>, usersUncheckedUpdateWithoutDidwalletInput>
  }

  export type usersCreateNestedOneWithoutInvestorInput = {
    create?: XOR<usersCreateWithoutInvestorInput, usersUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: usersCreateOrConnectWithoutInvestorInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutInvestorNestedInput = {
    create?: XOR<usersCreateWithoutInvestorInput, usersUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: usersCreateOrConnectWithoutInvestorInput
    upsert?: usersUpsertWithoutInvestorInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutInvestorInput, usersUpdateWithoutInvestorInput>, usersUncheckedUpdateWithoutInvestorInput>
  }

  export type usersCreateNestedOneWithoutIssuerInput = {
    create?: XOR<usersCreateWithoutIssuerInput, usersUncheckedCreateWithoutIssuerInput>
    connectOrCreate?: usersCreateOrConnectWithoutIssuerInput
    connect?: usersWhereUniqueInput
  }

  export type walletCreateNestedOneWithoutIssuerInput = {
    create?: XOR<walletCreateWithoutIssuerInput, walletUncheckedCreateWithoutIssuerInput>
    connectOrCreate?: walletCreateOrConnectWithoutIssuerInput
    connect?: walletWhereUniqueInput
  }

  export type walletUncheckedCreateNestedOneWithoutIssuerInput = {
    create?: XOR<walletCreateWithoutIssuerInput, walletUncheckedCreateWithoutIssuerInput>
    connectOrCreate?: walletCreateOrConnectWithoutIssuerInput
    connect?: walletWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutIssuerNestedInput = {
    create?: XOR<usersCreateWithoutIssuerInput, usersUncheckedCreateWithoutIssuerInput>
    connectOrCreate?: usersCreateOrConnectWithoutIssuerInput
    upsert?: usersUpsertWithoutIssuerInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutIssuerInput, usersUpdateWithoutIssuerInput>, usersUncheckedUpdateWithoutIssuerInput>
  }

  export type walletUpdateOneWithoutIssuerNestedInput = {
    create?: XOR<walletCreateWithoutIssuerInput, walletUncheckedCreateWithoutIssuerInput>
    connectOrCreate?: walletCreateOrConnectWithoutIssuerInput
    upsert?: walletUpsertWithoutIssuerInput
    disconnect?: walletWhereInput | boolean
    delete?: walletWhereInput | boolean
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutIssuerInput, walletUpdateWithoutIssuerInput>, walletUncheckedUpdateWithoutIssuerInput>
  }

  export type walletUncheckedUpdateOneWithoutIssuerNestedInput = {
    create?: XOR<walletCreateWithoutIssuerInput, walletUncheckedCreateWithoutIssuerInput>
    connectOrCreate?: walletCreateOrConnectWithoutIssuerInput
    upsert?: walletUpsertWithoutIssuerInput
    disconnect?: walletWhereInput | boolean
    delete?: walletWhereInput | boolean
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutIssuerInput, walletUpdateWithoutIssuerInput>, walletUncheckedUpdateWithoutIssuerInput>
  }

  export type kyc_applicantsCreateNestedOneWithoutKyc_address_infoInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_address_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_address_infoInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_address_infoInput
    connect?: kyc_applicantsWhereUniqueInput
  }

  export type kyc_applicantsUpdateOneRequiredWithoutKyc_address_infoNestedInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_address_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_address_infoInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_address_infoInput
    upsert?: kyc_applicantsUpsertWithoutKyc_address_infoInput
    connect?: kyc_applicantsWhereUniqueInput
    update?: XOR<XOR<kyc_applicantsUpdateToOneWithWhereWithoutKyc_address_infoInput, kyc_applicantsUpdateWithoutKyc_address_infoInput>, kyc_applicantsUncheckedUpdateWithoutKyc_address_infoInput>
  }

  export type kyc_complete_recordsCreateNestedOneWithoutKyc_addressesInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutKyc_addressesInput, kyc_complete_recordsUncheckedCreateWithoutKyc_addressesInput>
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutKyc_addressesInput
    connect?: kyc_complete_recordsWhereUniqueInput
  }

  export type kyc_complete_recordsUpdateOneRequiredWithoutKyc_addressesNestedInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutKyc_addressesInput, kyc_complete_recordsUncheckedCreateWithoutKyc_addressesInput>
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutKyc_addressesInput
    upsert?: kyc_complete_recordsUpsertWithoutKyc_addressesInput
    connect?: kyc_complete_recordsWhereUniqueInput
    update?: XOR<XOR<kyc_complete_recordsUpdateToOneWithWhereWithoutKyc_addressesInput, kyc_complete_recordsUpdateWithoutKyc_addressesInput>, kyc_complete_recordsUncheckedUpdateWithoutKyc_addressesInput>
  }

  export type kyc_address_infoCreateNestedManyWithoutKyc_applicantsInput = {
    create?: XOR<kyc_address_infoCreateWithoutKyc_applicantsInput, kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput> | kyc_address_infoCreateWithoutKyc_applicantsInput[] | kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_address_infoCreateOrConnectWithoutKyc_applicantsInput | kyc_address_infoCreateOrConnectWithoutKyc_applicantsInput[]
    createMany?: kyc_address_infoCreateManyKyc_applicantsInputEnvelope
    connect?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
  }

  export type kyc_personal_infoCreateNestedOneWithoutKyc_applicantsInput = {
    create?: XOR<kyc_personal_infoCreateWithoutKyc_applicantsInput, kyc_personal_infoUncheckedCreateWithoutKyc_applicantsInput>
    connectOrCreate?: kyc_personal_infoCreateOrConnectWithoutKyc_applicantsInput
    connect?: kyc_personal_infoWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutKyc_applicantsInput = {
    create?: XOR<usersCreateWithoutKyc_applicantsInput, usersUncheckedCreateWithoutKyc_applicantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutKyc_applicantsInput
    connect?: usersWhereUniqueInput
  }

  export type kyc_audit_logCreateNestedManyWithoutKyc_applicantsInput = {
    create?: XOR<kyc_audit_logCreateWithoutKyc_applicantsInput, kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput> | kyc_audit_logCreateWithoutKyc_applicantsInput[] | kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_audit_logCreateOrConnectWithoutKyc_applicantsInput | kyc_audit_logCreateOrConnectWithoutKyc_applicantsInput[]
    createMany?: kyc_audit_logCreateManyKyc_applicantsInputEnvelope
    connect?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
  }

  export type kyc_raw_dataCreateNestedManyWithoutKyc_applicantsInput = {
    create?: XOR<kyc_raw_dataCreateWithoutKyc_applicantsInput, kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput> | kyc_raw_dataCreateWithoutKyc_applicantsInput[] | kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_raw_dataCreateOrConnectWithoutKyc_applicantsInput | kyc_raw_dataCreateOrConnectWithoutKyc_applicantsInput[]
    createMany?: kyc_raw_dataCreateManyKyc_applicantsInputEnvelope
    connect?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
  }

  export type kyc_verification_historyCreateNestedManyWithoutKyc_applicantsInput = {
    create?: XOR<kyc_verification_historyCreateWithoutKyc_applicantsInput, kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput> | kyc_verification_historyCreateWithoutKyc_applicantsInput[] | kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_verification_historyCreateOrConnectWithoutKyc_applicantsInput | kyc_verification_historyCreateOrConnectWithoutKyc_applicantsInput[]
    createMany?: kyc_verification_historyCreateManyKyc_applicantsInputEnvelope
    connect?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
  }

  export type kyc_address_infoUncheckedCreateNestedManyWithoutKyc_applicantsInput = {
    create?: XOR<kyc_address_infoCreateWithoutKyc_applicantsInput, kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput> | kyc_address_infoCreateWithoutKyc_applicantsInput[] | kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_address_infoCreateOrConnectWithoutKyc_applicantsInput | kyc_address_infoCreateOrConnectWithoutKyc_applicantsInput[]
    createMany?: kyc_address_infoCreateManyKyc_applicantsInputEnvelope
    connect?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
  }

  export type kyc_audit_logUncheckedCreateNestedManyWithoutKyc_applicantsInput = {
    create?: XOR<kyc_audit_logCreateWithoutKyc_applicantsInput, kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput> | kyc_audit_logCreateWithoutKyc_applicantsInput[] | kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_audit_logCreateOrConnectWithoutKyc_applicantsInput | kyc_audit_logCreateOrConnectWithoutKyc_applicantsInput[]
    createMany?: kyc_audit_logCreateManyKyc_applicantsInputEnvelope
    connect?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
  }

  export type kyc_raw_dataUncheckedCreateNestedManyWithoutKyc_applicantsInput = {
    create?: XOR<kyc_raw_dataCreateWithoutKyc_applicantsInput, kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput> | kyc_raw_dataCreateWithoutKyc_applicantsInput[] | kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_raw_dataCreateOrConnectWithoutKyc_applicantsInput | kyc_raw_dataCreateOrConnectWithoutKyc_applicantsInput[]
    createMany?: kyc_raw_dataCreateManyKyc_applicantsInputEnvelope
    connect?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
  }

  export type kyc_verification_historyUncheckedCreateNestedManyWithoutKyc_applicantsInput = {
    create?: XOR<kyc_verification_historyCreateWithoutKyc_applicantsInput, kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput> | kyc_verification_historyCreateWithoutKyc_applicantsInput[] | kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_verification_historyCreateOrConnectWithoutKyc_applicantsInput | kyc_verification_historyCreateOrConnectWithoutKyc_applicantsInput[]
    createMany?: kyc_verification_historyCreateManyKyc_applicantsInputEnvelope
    connect?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
  }

  export type kyc_address_infoUpdateManyWithoutKyc_applicantsNestedInput = {
    create?: XOR<kyc_address_infoCreateWithoutKyc_applicantsInput, kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput> | kyc_address_infoCreateWithoutKyc_applicantsInput[] | kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_address_infoCreateOrConnectWithoutKyc_applicantsInput | kyc_address_infoCreateOrConnectWithoutKyc_applicantsInput[]
    upsert?: kyc_address_infoUpsertWithWhereUniqueWithoutKyc_applicantsInput | kyc_address_infoUpsertWithWhereUniqueWithoutKyc_applicantsInput[]
    createMany?: kyc_address_infoCreateManyKyc_applicantsInputEnvelope
    set?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
    disconnect?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
    delete?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
    connect?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
    update?: kyc_address_infoUpdateWithWhereUniqueWithoutKyc_applicantsInput | kyc_address_infoUpdateWithWhereUniqueWithoutKyc_applicantsInput[]
    updateMany?: kyc_address_infoUpdateManyWithWhereWithoutKyc_applicantsInput | kyc_address_infoUpdateManyWithWhereWithoutKyc_applicantsInput[]
    deleteMany?: kyc_address_infoScalarWhereInput | kyc_address_infoScalarWhereInput[]
  }

  export type kyc_personal_infoUpdateOneWithoutKyc_applicantsNestedInput = {
    create?: XOR<kyc_personal_infoCreateWithoutKyc_applicantsInput, kyc_personal_infoUncheckedCreateWithoutKyc_applicantsInput>
    connectOrCreate?: kyc_personal_infoCreateOrConnectWithoutKyc_applicantsInput
    upsert?: kyc_personal_infoUpsertWithoutKyc_applicantsInput
    disconnect?: kyc_personal_infoWhereInput | boolean
    delete?: kyc_personal_infoWhereInput | boolean
    connect?: kyc_personal_infoWhereUniqueInput
    update?: XOR<XOR<kyc_personal_infoUpdateToOneWithWhereWithoutKyc_applicantsInput, kyc_personal_infoUpdateWithoutKyc_applicantsInput>, kyc_personal_infoUncheckedUpdateWithoutKyc_applicantsInput>
  }

  export type usersUpdateOneWithoutKyc_applicantsNestedInput = {
    create?: XOR<usersCreateWithoutKyc_applicantsInput, usersUncheckedCreateWithoutKyc_applicantsInput>
    connectOrCreate?: usersCreateOrConnectWithoutKyc_applicantsInput
    upsert?: usersUpsertWithoutKyc_applicantsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutKyc_applicantsInput, usersUpdateWithoutKyc_applicantsInput>, usersUncheckedUpdateWithoutKyc_applicantsInput>
  }

  export type kyc_audit_logUpdateManyWithoutKyc_applicantsNestedInput = {
    create?: XOR<kyc_audit_logCreateWithoutKyc_applicantsInput, kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput> | kyc_audit_logCreateWithoutKyc_applicantsInput[] | kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_audit_logCreateOrConnectWithoutKyc_applicantsInput | kyc_audit_logCreateOrConnectWithoutKyc_applicantsInput[]
    upsert?: kyc_audit_logUpsertWithWhereUniqueWithoutKyc_applicantsInput | kyc_audit_logUpsertWithWhereUniqueWithoutKyc_applicantsInput[]
    createMany?: kyc_audit_logCreateManyKyc_applicantsInputEnvelope
    set?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
    disconnect?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
    delete?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
    connect?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
    update?: kyc_audit_logUpdateWithWhereUniqueWithoutKyc_applicantsInput | kyc_audit_logUpdateWithWhereUniqueWithoutKyc_applicantsInput[]
    updateMany?: kyc_audit_logUpdateManyWithWhereWithoutKyc_applicantsInput | kyc_audit_logUpdateManyWithWhereWithoutKyc_applicantsInput[]
    deleteMany?: kyc_audit_logScalarWhereInput | kyc_audit_logScalarWhereInput[]
  }

  export type kyc_raw_dataUpdateManyWithoutKyc_applicantsNestedInput = {
    create?: XOR<kyc_raw_dataCreateWithoutKyc_applicantsInput, kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput> | kyc_raw_dataCreateWithoutKyc_applicantsInput[] | kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_raw_dataCreateOrConnectWithoutKyc_applicantsInput | kyc_raw_dataCreateOrConnectWithoutKyc_applicantsInput[]
    upsert?: kyc_raw_dataUpsertWithWhereUniqueWithoutKyc_applicantsInput | kyc_raw_dataUpsertWithWhereUniqueWithoutKyc_applicantsInput[]
    createMany?: kyc_raw_dataCreateManyKyc_applicantsInputEnvelope
    set?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
    disconnect?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
    delete?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
    connect?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
    update?: kyc_raw_dataUpdateWithWhereUniqueWithoutKyc_applicantsInput | kyc_raw_dataUpdateWithWhereUniqueWithoutKyc_applicantsInput[]
    updateMany?: kyc_raw_dataUpdateManyWithWhereWithoutKyc_applicantsInput | kyc_raw_dataUpdateManyWithWhereWithoutKyc_applicantsInput[]
    deleteMany?: kyc_raw_dataScalarWhereInput | kyc_raw_dataScalarWhereInput[]
  }

  export type kyc_verification_historyUpdateManyWithoutKyc_applicantsNestedInput = {
    create?: XOR<kyc_verification_historyCreateWithoutKyc_applicantsInput, kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput> | kyc_verification_historyCreateWithoutKyc_applicantsInput[] | kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_verification_historyCreateOrConnectWithoutKyc_applicantsInput | kyc_verification_historyCreateOrConnectWithoutKyc_applicantsInput[]
    upsert?: kyc_verification_historyUpsertWithWhereUniqueWithoutKyc_applicantsInput | kyc_verification_historyUpsertWithWhereUniqueWithoutKyc_applicantsInput[]
    createMany?: kyc_verification_historyCreateManyKyc_applicantsInputEnvelope
    set?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
    disconnect?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
    delete?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
    connect?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
    update?: kyc_verification_historyUpdateWithWhereUniqueWithoutKyc_applicantsInput | kyc_verification_historyUpdateWithWhereUniqueWithoutKyc_applicantsInput[]
    updateMany?: kyc_verification_historyUpdateManyWithWhereWithoutKyc_applicantsInput | kyc_verification_historyUpdateManyWithWhereWithoutKyc_applicantsInput[]
    deleteMany?: kyc_verification_historyScalarWhereInput | kyc_verification_historyScalarWhereInput[]
  }

  export type kyc_address_infoUncheckedUpdateManyWithoutKyc_applicantsNestedInput = {
    create?: XOR<kyc_address_infoCreateWithoutKyc_applicantsInput, kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput> | kyc_address_infoCreateWithoutKyc_applicantsInput[] | kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_address_infoCreateOrConnectWithoutKyc_applicantsInput | kyc_address_infoCreateOrConnectWithoutKyc_applicantsInput[]
    upsert?: kyc_address_infoUpsertWithWhereUniqueWithoutKyc_applicantsInput | kyc_address_infoUpsertWithWhereUniqueWithoutKyc_applicantsInput[]
    createMany?: kyc_address_infoCreateManyKyc_applicantsInputEnvelope
    set?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
    disconnect?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
    delete?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
    connect?: kyc_address_infoWhereUniqueInput | kyc_address_infoWhereUniqueInput[]
    update?: kyc_address_infoUpdateWithWhereUniqueWithoutKyc_applicantsInput | kyc_address_infoUpdateWithWhereUniqueWithoutKyc_applicantsInput[]
    updateMany?: kyc_address_infoUpdateManyWithWhereWithoutKyc_applicantsInput | kyc_address_infoUpdateManyWithWhereWithoutKyc_applicantsInput[]
    deleteMany?: kyc_address_infoScalarWhereInput | kyc_address_infoScalarWhereInput[]
  }

  export type kyc_audit_logUncheckedUpdateManyWithoutKyc_applicantsNestedInput = {
    create?: XOR<kyc_audit_logCreateWithoutKyc_applicantsInput, kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput> | kyc_audit_logCreateWithoutKyc_applicantsInput[] | kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_audit_logCreateOrConnectWithoutKyc_applicantsInput | kyc_audit_logCreateOrConnectWithoutKyc_applicantsInput[]
    upsert?: kyc_audit_logUpsertWithWhereUniqueWithoutKyc_applicantsInput | kyc_audit_logUpsertWithWhereUniqueWithoutKyc_applicantsInput[]
    createMany?: kyc_audit_logCreateManyKyc_applicantsInputEnvelope
    set?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
    disconnect?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
    delete?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
    connect?: kyc_audit_logWhereUniqueInput | kyc_audit_logWhereUniqueInput[]
    update?: kyc_audit_logUpdateWithWhereUniqueWithoutKyc_applicantsInput | kyc_audit_logUpdateWithWhereUniqueWithoutKyc_applicantsInput[]
    updateMany?: kyc_audit_logUpdateManyWithWhereWithoutKyc_applicantsInput | kyc_audit_logUpdateManyWithWhereWithoutKyc_applicantsInput[]
    deleteMany?: kyc_audit_logScalarWhereInput | kyc_audit_logScalarWhereInput[]
  }

  export type kyc_raw_dataUncheckedUpdateManyWithoutKyc_applicantsNestedInput = {
    create?: XOR<kyc_raw_dataCreateWithoutKyc_applicantsInput, kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput> | kyc_raw_dataCreateWithoutKyc_applicantsInput[] | kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_raw_dataCreateOrConnectWithoutKyc_applicantsInput | kyc_raw_dataCreateOrConnectWithoutKyc_applicantsInput[]
    upsert?: kyc_raw_dataUpsertWithWhereUniqueWithoutKyc_applicantsInput | kyc_raw_dataUpsertWithWhereUniqueWithoutKyc_applicantsInput[]
    createMany?: kyc_raw_dataCreateManyKyc_applicantsInputEnvelope
    set?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
    disconnect?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
    delete?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
    connect?: kyc_raw_dataWhereUniqueInput | kyc_raw_dataWhereUniqueInput[]
    update?: kyc_raw_dataUpdateWithWhereUniqueWithoutKyc_applicantsInput | kyc_raw_dataUpdateWithWhereUniqueWithoutKyc_applicantsInput[]
    updateMany?: kyc_raw_dataUpdateManyWithWhereWithoutKyc_applicantsInput | kyc_raw_dataUpdateManyWithWhereWithoutKyc_applicantsInput[]
    deleteMany?: kyc_raw_dataScalarWhereInput | kyc_raw_dataScalarWhereInput[]
  }

  export type kyc_verification_historyUncheckedUpdateManyWithoutKyc_applicantsNestedInput = {
    create?: XOR<kyc_verification_historyCreateWithoutKyc_applicantsInput, kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput> | kyc_verification_historyCreateWithoutKyc_applicantsInput[] | kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput[]
    connectOrCreate?: kyc_verification_historyCreateOrConnectWithoutKyc_applicantsInput | kyc_verification_historyCreateOrConnectWithoutKyc_applicantsInput[]
    upsert?: kyc_verification_historyUpsertWithWhereUniqueWithoutKyc_applicantsInput | kyc_verification_historyUpsertWithWhereUniqueWithoutKyc_applicantsInput[]
    createMany?: kyc_verification_historyCreateManyKyc_applicantsInputEnvelope
    set?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
    disconnect?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
    delete?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
    connect?: kyc_verification_historyWhereUniqueInput | kyc_verification_historyWhereUniqueInput[]
    update?: kyc_verification_historyUpdateWithWhereUniqueWithoutKyc_applicantsInput | kyc_verification_historyUpdateWithWhereUniqueWithoutKyc_applicantsInput[]
    updateMany?: kyc_verification_historyUpdateManyWithWhereWithoutKyc_applicantsInput | kyc_verification_historyUpdateManyWithWhereWithoutKyc_applicantsInput[]
    deleteMany?: kyc_verification_historyScalarWhereInput | kyc_verification_historyScalarWhereInput[]
  }

  export type kyc_applicantsCreateNestedOneWithoutKyc_audit_logInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_audit_logInput, kyc_applicantsUncheckedCreateWithoutKyc_audit_logInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_audit_logInput
    connect?: kyc_applicantsWhereUniqueInput
  }

  export type kyc_applicantsUpdateOneRequiredWithoutKyc_audit_logNestedInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_audit_logInput, kyc_applicantsUncheckedCreateWithoutKyc_audit_logInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_audit_logInput
    upsert?: kyc_applicantsUpsertWithoutKyc_audit_logInput
    connect?: kyc_applicantsWhereUniqueInput
    update?: XOR<XOR<kyc_applicantsUpdateToOneWithWhereWithoutKyc_audit_logInput, kyc_applicantsUpdateWithoutKyc_audit_logInput>, kyc_applicantsUncheckedUpdateWithoutKyc_audit_logInput>
  }

  export type kyc_addressesCreateNestedManyWithoutKyc_complete_recordsInput = {
    create?: XOR<kyc_addressesCreateWithoutKyc_complete_recordsInput, kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput> | kyc_addressesCreateWithoutKyc_complete_recordsInput[] | kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: kyc_addressesCreateOrConnectWithoutKyc_complete_recordsInput | kyc_addressesCreateOrConnectWithoutKyc_complete_recordsInput[]
    createMany?: kyc_addressesCreateManyKyc_complete_recordsInputEnvelope
    connect?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutKyc_complete_recordsInput = {
    create?: XOR<usersCreateWithoutKyc_complete_recordsInput, usersUncheckedCreateWithoutKyc_complete_recordsInput>
    connectOrCreate?: usersCreateOrConnectWithoutKyc_complete_recordsInput
    connect?: usersWhereUniqueInput
  }

  export type KycDocumentCreateNestedManyWithoutKyc_complete_recordsInput = {
    create?: XOR<KycDocumentCreateWithoutKyc_complete_recordsInput, KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput> | KycDocumentCreateWithoutKyc_complete_recordsInput[] | KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: KycDocumentCreateOrConnectWithoutKyc_complete_recordsInput | KycDocumentCreateOrConnectWithoutKyc_complete_recordsInput[]
    createMany?: KycDocumentCreateManyKyc_complete_recordsInputEnvelope
    connect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
  }

  export type kyc_personal_infoCreateNestedOneWithoutKyc_complete_recordsInput = {
    create?: XOR<kyc_personal_infoCreateWithoutKyc_complete_recordsInput, kyc_personal_infoUncheckedCreateWithoutKyc_complete_recordsInput>
    connectOrCreate?: kyc_personal_infoCreateOrConnectWithoutKyc_complete_recordsInput
    connect?: kyc_personal_infoWhereUniqueInput
  }

  export type kyc_verification_eventsCreateNestedManyWithoutKyc_complete_recordsInput = {
    create?: XOR<kyc_verification_eventsCreateWithoutKyc_complete_recordsInput, kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput> | kyc_verification_eventsCreateWithoutKyc_complete_recordsInput[] | kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: kyc_verification_eventsCreateOrConnectWithoutKyc_complete_recordsInput | kyc_verification_eventsCreateOrConnectWithoutKyc_complete_recordsInput[]
    createMany?: kyc_verification_eventsCreateManyKyc_complete_recordsInputEnvelope
    connect?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
  }

  export type kyc_addressesUncheckedCreateNestedManyWithoutKyc_complete_recordsInput = {
    create?: XOR<kyc_addressesCreateWithoutKyc_complete_recordsInput, kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput> | kyc_addressesCreateWithoutKyc_complete_recordsInput[] | kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: kyc_addressesCreateOrConnectWithoutKyc_complete_recordsInput | kyc_addressesCreateOrConnectWithoutKyc_complete_recordsInput[]
    createMany?: kyc_addressesCreateManyKyc_complete_recordsInputEnvelope
    connect?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
  }

  export type KycDocumentUncheckedCreateNestedManyWithoutKyc_complete_recordsInput = {
    create?: XOR<KycDocumentCreateWithoutKyc_complete_recordsInput, KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput> | KycDocumentCreateWithoutKyc_complete_recordsInput[] | KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: KycDocumentCreateOrConnectWithoutKyc_complete_recordsInput | KycDocumentCreateOrConnectWithoutKyc_complete_recordsInput[]
    createMany?: KycDocumentCreateManyKyc_complete_recordsInputEnvelope
    connect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
  }

  export type kyc_personal_infoUncheckedCreateNestedOneWithoutKyc_complete_recordsInput = {
    create?: XOR<kyc_personal_infoCreateWithoutKyc_complete_recordsInput, kyc_personal_infoUncheckedCreateWithoutKyc_complete_recordsInput>
    connectOrCreate?: kyc_personal_infoCreateOrConnectWithoutKyc_complete_recordsInput
    connect?: kyc_personal_infoWhereUniqueInput
  }

  export type kyc_verification_eventsUncheckedCreateNestedManyWithoutKyc_complete_recordsInput = {
    create?: XOR<kyc_verification_eventsCreateWithoutKyc_complete_recordsInput, kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput> | kyc_verification_eventsCreateWithoutKyc_complete_recordsInput[] | kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: kyc_verification_eventsCreateOrConnectWithoutKyc_complete_recordsInput | kyc_verification_eventsCreateOrConnectWithoutKyc_complete_recordsInput[]
    createMany?: kyc_verification_eventsCreateManyKyc_complete_recordsInputEnvelope
    connect?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
  }

  export type kyc_addressesUpdateManyWithoutKyc_complete_recordsNestedInput = {
    create?: XOR<kyc_addressesCreateWithoutKyc_complete_recordsInput, kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput> | kyc_addressesCreateWithoutKyc_complete_recordsInput[] | kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: kyc_addressesCreateOrConnectWithoutKyc_complete_recordsInput | kyc_addressesCreateOrConnectWithoutKyc_complete_recordsInput[]
    upsert?: kyc_addressesUpsertWithWhereUniqueWithoutKyc_complete_recordsInput | kyc_addressesUpsertWithWhereUniqueWithoutKyc_complete_recordsInput[]
    createMany?: kyc_addressesCreateManyKyc_complete_recordsInputEnvelope
    set?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
    disconnect?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
    delete?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
    connect?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
    update?: kyc_addressesUpdateWithWhereUniqueWithoutKyc_complete_recordsInput | kyc_addressesUpdateWithWhereUniqueWithoutKyc_complete_recordsInput[]
    updateMany?: kyc_addressesUpdateManyWithWhereWithoutKyc_complete_recordsInput | kyc_addressesUpdateManyWithWhereWithoutKyc_complete_recordsInput[]
    deleteMany?: kyc_addressesScalarWhereInput | kyc_addressesScalarWhereInput[]
  }

  export type usersUpdateOneWithoutKyc_complete_recordsNestedInput = {
    create?: XOR<usersCreateWithoutKyc_complete_recordsInput, usersUncheckedCreateWithoutKyc_complete_recordsInput>
    connectOrCreate?: usersCreateOrConnectWithoutKyc_complete_recordsInput
    upsert?: usersUpsertWithoutKyc_complete_recordsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutKyc_complete_recordsInput, usersUpdateWithoutKyc_complete_recordsInput>, usersUncheckedUpdateWithoutKyc_complete_recordsInput>
  }

  export type KycDocumentUpdateManyWithoutKyc_complete_recordsNestedInput = {
    create?: XOR<KycDocumentCreateWithoutKyc_complete_recordsInput, KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput> | KycDocumentCreateWithoutKyc_complete_recordsInput[] | KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: KycDocumentCreateOrConnectWithoutKyc_complete_recordsInput | KycDocumentCreateOrConnectWithoutKyc_complete_recordsInput[]
    upsert?: KycDocumentUpsertWithWhereUniqueWithoutKyc_complete_recordsInput | KycDocumentUpsertWithWhereUniqueWithoutKyc_complete_recordsInput[]
    createMany?: KycDocumentCreateManyKyc_complete_recordsInputEnvelope
    set?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    disconnect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    delete?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    connect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    update?: KycDocumentUpdateWithWhereUniqueWithoutKyc_complete_recordsInput | KycDocumentUpdateWithWhereUniqueWithoutKyc_complete_recordsInput[]
    updateMany?: KycDocumentUpdateManyWithWhereWithoutKyc_complete_recordsInput | KycDocumentUpdateManyWithWhereWithoutKyc_complete_recordsInput[]
    deleteMany?: KycDocumentScalarWhereInput | KycDocumentScalarWhereInput[]
  }

  export type kyc_personal_infoUpdateOneWithoutKyc_complete_recordsNestedInput = {
    create?: XOR<kyc_personal_infoCreateWithoutKyc_complete_recordsInput, kyc_personal_infoUncheckedCreateWithoutKyc_complete_recordsInput>
    connectOrCreate?: kyc_personal_infoCreateOrConnectWithoutKyc_complete_recordsInput
    upsert?: kyc_personal_infoUpsertWithoutKyc_complete_recordsInput
    disconnect?: kyc_personal_infoWhereInput | boolean
    delete?: kyc_personal_infoWhereInput | boolean
    connect?: kyc_personal_infoWhereUniqueInput
    update?: XOR<XOR<kyc_personal_infoUpdateToOneWithWhereWithoutKyc_complete_recordsInput, kyc_personal_infoUpdateWithoutKyc_complete_recordsInput>, kyc_personal_infoUncheckedUpdateWithoutKyc_complete_recordsInput>
  }

  export type kyc_verification_eventsUpdateManyWithoutKyc_complete_recordsNestedInput = {
    create?: XOR<kyc_verification_eventsCreateWithoutKyc_complete_recordsInput, kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput> | kyc_verification_eventsCreateWithoutKyc_complete_recordsInput[] | kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: kyc_verification_eventsCreateOrConnectWithoutKyc_complete_recordsInput | kyc_verification_eventsCreateOrConnectWithoutKyc_complete_recordsInput[]
    upsert?: kyc_verification_eventsUpsertWithWhereUniqueWithoutKyc_complete_recordsInput | kyc_verification_eventsUpsertWithWhereUniqueWithoutKyc_complete_recordsInput[]
    createMany?: kyc_verification_eventsCreateManyKyc_complete_recordsInputEnvelope
    set?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
    disconnect?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
    delete?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
    connect?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
    update?: kyc_verification_eventsUpdateWithWhereUniqueWithoutKyc_complete_recordsInput | kyc_verification_eventsUpdateWithWhereUniqueWithoutKyc_complete_recordsInput[]
    updateMany?: kyc_verification_eventsUpdateManyWithWhereWithoutKyc_complete_recordsInput | kyc_verification_eventsUpdateManyWithWhereWithoutKyc_complete_recordsInput[]
    deleteMany?: kyc_verification_eventsScalarWhereInput | kyc_verification_eventsScalarWhereInput[]
  }

  export type kyc_addressesUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput = {
    create?: XOR<kyc_addressesCreateWithoutKyc_complete_recordsInput, kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput> | kyc_addressesCreateWithoutKyc_complete_recordsInput[] | kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: kyc_addressesCreateOrConnectWithoutKyc_complete_recordsInput | kyc_addressesCreateOrConnectWithoutKyc_complete_recordsInput[]
    upsert?: kyc_addressesUpsertWithWhereUniqueWithoutKyc_complete_recordsInput | kyc_addressesUpsertWithWhereUniqueWithoutKyc_complete_recordsInput[]
    createMany?: kyc_addressesCreateManyKyc_complete_recordsInputEnvelope
    set?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
    disconnect?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
    delete?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
    connect?: kyc_addressesWhereUniqueInput | kyc_addressesWhereUniqueInput[]
    update?: kyc_addressesUpdateWithWhereUniqueWithoutKyc_complete_recordsInput | kyc_addressesUpdateWithWhereUniqueWithoutKyc_complete_recordsInput[]
    updateMany?: kyc_addressesUpdateManyWithWhereWithoutKyc_complete_recordsInput | kyc_addressesUpdateManyWithWhereWithoutKyc_complete_recordsInput[]
    deleteMany?: kyc_addressesScalarWhereInput | kyc_addressesScalarWhereInput[]
  }

  export type KycDocumentUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput = {
    create?: XOR<KycDocumentCreateWithoutKyc_complete_recordsInput, KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput> | KycDocumentCreateWithoutKyc_complete_recordsInput[] | KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: KycDocumentCreateOrConnectWithoutKyc_complete_recordsInput | KycDocumentCreateOrConnectWithoutKyc_complete_recordsInput[]
    upsert?: KycDocumentUpsertWithWhereUniqueWithoutKyc_complete_recordsInput | KycDocumentUpsertWithWhereUniqueWithoutKyc_complete_recordsInput[]
    createMany?: KycDocumentCreateManyKyc_complete_recordsInputEnvelope
    set?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    disconnect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    delete?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    connect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    update?: KycDocumentUpdateWithWhereUniqueWithoutKyc_complete_recordsInput | KycDocumentUpdateWithWhereUniqueWithoutKyc_complete_recordsInput[]
    updateMany?: KycDocumentUpdateManyWithWhereWithoutKyc_complete_recordsInput | KycDocumentUpdateManyWithWhereWithoutKyc_complete_recordsInput[]
    deleteMany?: KycDocumentScalarWhereInput | KycDocumentScalarWhereInput[]
  }

  export type kyc_personal_infoUncheckedUpdateOneWithoutKyc_complete_recordsNestedInput = {
    create?: XOR<kyc_personal_infoCreateWithoutKyc_complete_recordsInput, kyc_personal_infoUncheckedCreateWithoutKyc_complete_recordsInput>
    connectOrCreate?: kyc_personal_infoCreateOrConnectWithoutKyc_complete_recordsInput
    upsert?: kyc_personal_infoUpsertWithoutKyc_complete_recordsInput
    disconnect?: kyc_personal_infoWhereInput | boolean
    delete?: kyc_personal_infoWhereInput | boolean
    connect?: kyc_personal_infoWhereUniqueInput
    update?: XOR<XOR<kyc_personal_infoUpdateToOneWithWhereWithoutKyc_complete_recordsInput, kyc_personal_infoUpdateWithoutKyc_complete_recordsInput>, kyc_personal_infoUncheckedUpdateWithoutKyc_complete_recordsInput>
  }

  export type kyc_verification_eventsUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput = {
    create?: XOR<kyc_verification_eventsCreateWithoutKyc_complete_recordsInput, kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput> | kyc_verification_eventsCreateWithoutKyc_complete_recordsInput[] | kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput[]
    connectOrCreate?: kyc_verification_eventsCreateOrConnectWithoutKyc_complete_recordsInput | kyc_verification_eventsCreateOrConnectWithoutKyc_complete_recordsInput[]
    upsert?: kyc_verification_eventsUpsertWithWhereUniqueWithoutKyc_complete_recordsInput | kyc_verification_eventsUpsertWithWhereUniqueWithoutKyc_complete_recordsInput[]
    createMany?: kyc_verification_eventsCreateManyKyc_complete_recordsInputEnvelope
    set?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
    disconnect?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
    delete?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
    connect?: kyc_verification_eventsWhereUniqueInput | kyc_verification_eventsWhereUniqueInput[]
    update?: kyc_verification_eventsUpdateWithWhereUniqueWithoutKyc_complete_recordsInput | kyc_verification_eventsUpdateWithWhereUniqueWithoutKyc_complete_recordsInput[]
    updateMany?: kyc_verification_eventsUpdateManyWithWhereWithoutKyc_complete_recordsInput | kyc_verification_eventsUpdateManyWithWhereWithoutKyc_complete_recordsInput[]
    deleteMany?: kyc_verification_eventsScalarWhereInput | kyc_verification_eventsScalarWhereInput[]
  }

  export type kyc_applicantsCreateNestedOneWithoutKyc_personal_infoInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_personal_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_personal_infoInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_personal_infoInput
    connect?: kyc_applicantsWhereUniqueInput
  }

  export type kyc_complete_recordsCreateNestedOneWithoutKyc_personal_infoInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutKyc_personal_infoInput, kyc_complete_recordsUncheckedCreateWithoutKyc_personal_infoInput>
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutKyc_personal_infoInput
    connect?: kyc_complete_recordsWhereUniqueInput
  }

  export type kyc_applicantsUncheckedCreateNestedOneWithoutKyc_personal_infoInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_personal_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_personal_infoInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_personal_infoInput
    connect?: kyc_applicantsWhereUniqueInput
  }

  export type kyc_applicantsUpdateOneWithoutKyc_personal_infoNestedInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_personal_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_personal_infoInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_personal_infoInput
    upsert?: kyc_applicantsUpsertWithoutKyc_personal_infoInput
    disconnect?: kyc_applicantsWhereInput | boolean
    delete?: kyc_applicantsWhereInput | boolean
    connect?: kyc_applicantsWhereUniqueInput
    update?: XOR<XOR<kyc_applicantsUpdateToOneWithWhereWithoutKyc_personal_infoInput, kyc_applicantsUpdateWithoutKyc_personal_infoInput>, kyc_applicantsUncheckedUpdateWithoutKyc_personal_infoInput>
  }

  export type kyc_complete_recordsUpdateOneWithoutKyc_personal_infoNestedInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutKyc_personal_infoInput, kyc_complete_recordsUncheckedCreateWithoutKyc_personal_infoInput>
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutKyc_personal_infoInput
    upsert?: kyc_complete_recordsUpsertWithoutKyc_personal_infoInput
    disconnect?: kyc_complete_recordsWhereInput | boolean
    delete?: kyc_complete_recordsWhereInput | boolean
    connect?: kyc_complete_recordsWhereUniqueInput
    update?: XOR<XOR<kyc_complete_recordsUpdateToOneWithWhereWithoutKyc_personal_infoInput, kyc_complete_recordsUpdateWithoutKyc_personal_infoInput>, kyc_complete_recordsUncheckedUpdateWithoutKyc_personal_infoInput>
  }

  export type kyc_applicantsUncheckedUpdateOneWithoutKyc_personal_infoNestedInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_personal_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_personal_infoInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_personal_infoInput
    upsert?: kyc_applicantsUpsertWithoutKyc_personal_infoInput
    disconnect?: kyc_applicantsWhereInput | boolean
    delete?: kyc_applicantsWhereInput | boolean
    connect?: kyc_applicantsWhereUniqueInput
    update?: XOR<XOR<kyc_applicantsUpdateToOneWithWhereWithoutKyc_personal_infoInput, kyc_applicantsUpdateWithoutKyc_personal_infoInput>, kyc_applicantsUncheckedUpdateWithoutKyc_personal_infoInput>
  }

  export type kyc_applicantsCreateNestedOneWithoutKyc_raw_dataInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_raw_dataInput, kyc_applicantsUncheckedCreateWithoutKyc_raw_dataInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_raw_dataInput
    connect?: kyc_applicantsWhereUniqueInput
  }

  export type kyc_applicantsUpdateOneRequiredWithoutKyc_raw_dataNestedInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_raw_dataInput, kyc_applicantsUncheckedCreateWithoutKyc_raw_dataInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_raw_dataInput
    upsert?: kyc_applicantsUpsertWithoutKyc_raw_dataInput
    connect?: kyc_applicantsWhereUniqueInput
    update?: XOR<XOR<kyc_applicantsUpdateToOneWithWhereWithoutKyc_raw_dataInput, kyc_applicantsUpdateWithoutKyc_raw_dataInput>, kyc_applicantsUncheckedUpdateWithoutKyc_raw_dataInput>
  }

  export type kyc_complete_recordsCreateNestedOneWithoutKyc_verification_eventsInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutKyc_verification_eventsInput, kyc_complete_recordsUncheckedCreateWithoutKyc_verification_eventsInput>
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutKyc_verification_eventsInput
    connect?: kyc_complete_recordsWhereUniqueInput
  }

  export type kyc_complete_recordsUpdateOneRequiredWithoutKyc_verification_eventsNestedInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutKyc_verification_eventsInput, kyc_complete_recordsUncheckedCreateWithoutKyc_verification_eventsInput>
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutKyc_verification_eventsInput
    upsert?: kyc_complete_recordsUpsertWithoutKyc_verification_eventsInput
    connect?: kyc_complete_recordsWhereUniqueInput
    update?: XOR<XOR<kyc_complete_recordsUpdateToOneWithWhereWithoutKyc_verification_eventsInput, kyc_complete_recordsUpdateWithoutKyc_verification_eventsInput>, kyc_complete_recordsUncheckedUpdateWithoutKyc_verification_eventsInput>
  }

  export type kyc_applicantsCreateNestedOneWithoutKyc_verification_historyInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_verification_historyInput, kyc_applicantsUncheckedCreateWithoutKyc_verification_historyInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_verification_historyInput
    connect?: kyc_applicantsWhereUniqueInput
  }

  export type kyc_applicantsUpdateOneRequiredWithoutKyc_verification_historyNestedInput = {
    create?: XOR<kyc_applicantsCreateWithoutKyc_verification_historyInput, kyc_applicantsUncheckedCreateWithoutKyc_verification_historyInput>
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutKyc_verification_historyInput
    upsert?: kyc_applicantsUpsertWithoutKyc_verification_historyInput
    connect?: kyc_applicantsWhereUniqueInput
    update?: XOR<XOR<kyc_applicantsUpdateToOneWithWhereWithoutKyc_verification_historyInput, kyc_applicantsUpdateWithoutKyc_verification_historyInput>, kyc_applicantsUncheckedUpdateWithoutKyc_verification_historyInput>
  }

  export type usersCreateNestedOneWithoutRefreshtokenInput = {
    create?: XOR<usersCreateWithoutRefreshtokenInput, usersUncheckedCreateWithoutRefreshtokenInput>
    connectOrCreate?: usersCreateOrConnectWithoutRefreshtokenInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutRefreshtokenNestedInput = {
    create?: XOR<usersCreateWithoutRefreshtokenInput, usersUncheckedCreateWithoutRefreshtokenInput>
    connectOrCreate?: usersCreateOrConnectWithoutRefreshtokenInput
    upsert?: usersUpsertWithoutRefreshtokenInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRefreshtokenInput, usersUpdateWithoutRefreshtokenInput>, usersUncheckedUpdateWithoutRefreshtokenInput>
  }

  export type usersCreateNestedOneWithoutUserroleInput = {
    create?: XOR<usersCreateWithoutUserroleInput, usersUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserroleInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUserroleNestedInput = {
    create?: XOR<usersCreateWithoutUserroleInput, usersUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserroleInput
    upsert?: usersUpsertWithoutUserroleInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUserroleInput, usersUpdateWithoutUserroleInput>, usersUncheckedUpdateWithoutUserroleInput>
  }

  export type adminCreateNestedOneWithoutUsersInput = {
    create?: XOR<adminCreateWithoutUsersInput, adminUncheckedCreateWithoutUsersInput>
    connectOrCreate?: adminCreateOrConnectWithoutUsersInput
    connect?: adminWhereUniqueInput
  }

  export type authproviderCreateNestedManyWithoutUsersInput = {
    create?: XOR<authproviderCreateWithoutUsersInput, authproviderUncheckedCreateWithoutUsersInput> | authproviderCreateWithoutUsersInput[] | authproviderUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: authproviderCreateOrConnectWithoutUsersInput | authproviderCreateOrConnectWithoutUsersInput[]
    createMany?: authproviderCreateManyUsersInputEnvelope
    connect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
  }

  export type didwalletCreateNestedManyWithoutUsersInput = {
    create?: XOR<didwalletCreateWithoutUsersInput, didwalletUncheckedCreateWithoutUsersInput> | didwalletCreateWithoutUsersInput[] | didwalletUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: didwalletCreateOrConnectWithoutUsersInput | didwalletCreateOrConnectWithoutUsersInput[]
    createMany?: didwalletCreateManyUsersInputEnvelope
    connect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
  }

  export type investorCreateNestedOneWithoutUsersInput = {
    create?: XOR<investorCreateWithoutUsersInput, investorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: investorCreateOrConnectWithoutUsersInput
    connect?: investorWhereUniqueInput
  }

  export type issuerCreateNestedOneWithoutUsersInput = {
    create?: XOR<issuerCreateWithoutUsersInput, issuerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: issuerCreateOrConnectWithoutUsersInput
    connect?: issuerWhereUniqueInput
  }

  export type kyc_applicantsCreateNestedManyWithoutUsersInput = {
    create?: XOR<kyc_applicantsCreateWithoutUsersInput, kyc_applicantsUncheckedCreateWithoutUsersInput> | kyc_applicantsCreateWithoutUsersInput[] | kyc_applicantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutUsersInput | kyc_applicantsCreateOrConnectWithoutUsersInput[]
    createMany?: kyc_applicantsCreateManyUsersInputEnvelope
    connect?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
  }

  export type kyc_complete_recordsCreateNestedManyWithoutUsersInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutUsersInput, kyc_complete_recordsUncheckedCreateWithoutUsersInput> | kyc_complete_recordsCreateWithoutUsersInput[] | kyc_complete_recordsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutUsersInput | kyc_complete_recordsCreateOrConnectWithoutUsersInput[]
    createMany?: kyc_complete_recordsCreateManyUsersInputEnvelope
    connect?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
  }

  export type KycDocumentCreateNestedManyWithoutUsersInput = {
    create?: XOR<KycDocumentCreateWithoutUsersInput, KycDocumentUncheckedCreateWithoutUsersInput> | KycDocumentCreateWithoutUsersInput[] | KycDocumentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: KycDocumentCreateOrConnectWithoutUsersInput | KycDocumentCreateOrConnectWithoutUsersInput[]
    createMany?: KycDocumentCreateManyUsersInputEnvelope
    connect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
  }

  export type kycVerificationCreateNestedManyWithoutUsersInput = {
    create?: XOR<kycVerificationCreateWithoutUsersInput, kycVerificationUncheckedCreateWithoutUsersInput> | kycVerificationCreateWithoutUsersInput[] | kycVerificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kycVerificationCreateOrConnectWithoutUsersInput | kycVerificationCreateOrConnectWithoutUsersInput[]
    createMany?: kycVerificationCreateManyUsersInputEnvelope
    connect?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
  }

  export type refreshtokenCreateNestedManyWithoutUsersInput = {
    create?: XOR<refreshtokenCreateWithoutUsersInput, refreshtokenUncheckedCreateWithoutUsersInput> | refreshtokenCreateWithoutUsersInput[] | refreshtokenUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUsersInput | refreshtokenCreateOrConnectWithoutUsersInput[]
    createMany?: refreshtokenCreateManyUsersInputEnvelope
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
  }

  export type userroleCreateNestedManyWithoutUsersInput = {
    create?: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput> | userroleCreateWithoutUsersInput[] | userroleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUsersInput | userroleCreateOrConnectWithoutUsersInput[]
    createMany?: userroleCreateManyUsersInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type walletCreateNestedOneWithoutUsersInput = {
    create?: XOR<walletCreateWithoutUsersInput, walletUncheckedCreateWithoutUsersInput>
    connectOrCreate?: walletCreateOrConnectWithoutUsersInput
    connect?: walletWhereUniqueInput
  }

  export type adminUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<adminCreateWithoutUsersInput, adminUncheckedCreateWithoutUsersInput>
    connectOrCreate?: adminCreateOrConnectWithoutUsersInput
    connect?: adminWhereUniqueInput
  }

  export type authproviderUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<authproviderCreateWithoutUsersInput, authproviderUncheckedCreateWithoutUsersInput> | authproviderCreateWithoutUsersInput[] | authproviderUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: authproviderCreateOrConnectWithoutUsersInput | authproviderCreateOrConnectWithoutUsersInput[]
    createMany?: authproviderCreateManyUsersInputEnvelope
    connect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
  }

  export type didwalletUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<didwalletCreateWithoutUsersInput, didwalletUncheckedCreateWithoutUsersInput> | didwalletCreateWithoutUsersInput[] | didwalletUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: didwalletCreateOrConnectWithoutUsersInput | didwalletCreateOrConnectWithoutUsersInput[]
    createMany?: didwalletCreateManyUsersInputEnvelope
    connect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
  }

  export type investorUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<investorCreateWithoutUsersInput, investorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: investorCreateOrConnectWithoutUsersInput
    connect?: investorWhereUniqueInput
  }

  export type issuerUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<issuerCreateWithoutUsersInput, issuerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: issuerCreateOrConnectWithoutUsersInput
    connect?: issuerWhereUniqueInput
  }

  export type kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<kyc_applicantsCreateWithoutUsersInput, kyc_applicantsUncheckedCreateWithoutUsersInput> | kyc_applicantsCreateWithoutUsersInput[] | kyc_applicantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutUsersInput | kyc_applicantsCreateOrConnectWithoutUsersInput[]
    createMany?: kyc_applicantsCreateManyUsersInputEnvelope
    connect?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
  }

  export type kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutUsersInput, kyc_complete_recordsUncheckedCreateWithoutUsersInput> | kyc_complete_recordsCreateWithoutUsersInput[] | kyc_complete_recordsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutUsersInput | kyc_complete_recordsCreateOrConnectWithoutUsersInput[]
    createMany?: kyc_complete_recordsCreateManyUsersInputEnvelope
    connect?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
  }

  export type KycDocumentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<KycDocumentCreateWithoutUsersInput, KycDocumentUncheckedCreateWithoutUsersInput> | KycDocumentCreateWithoutUsersInput[] | KycDocumentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: KycDocumentCreateOrConnectWithoutUsersInput | KycDocumentCreateOrConnectWithoutUsersInput[]
    createMany?: KycDocumentCreateManyUsersInputEnvelope
    connect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
  }

  export type kycVerificationUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<kycVerificationCreateWithoutUsersInput, kycVerificationUncheckedCreateWithoutUsersInput> | kycVerificationCreateWithoutUsersInput[] | kycVerificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kycVerificationCreateOrConnectWithoutUsersInput | kycVerificationCreateOrConnectWithoutUsersInput[]
    createMany?: kycVerificationCreateManyUsersInputEnvelope
    connect?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
  }

  export type refreshtokenUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<refreshtokenCreateWithoutUsersInput, refreshtokenUncheckedCreateWithoutUsersInput> | refreshtokenCreateWithoutUsersInput[] | refreshtokenUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUsersInput | refreshtokenCreateOrConnectWithoutUsersInput[]
    createMany?: refreshtokenCreateManyUsersInputEnvelope
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput> | userroleCreateWithoutUsersInput[] | userroleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUsersInput | userroleCreateOrConnectWithoutUsersInput[]
    createMany?: userroleCreateManyUsersInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type walletUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<walletCreateWithoutUsersInput, walletUncheckedCreateWithoutUsersInput>
    connectOrCreate?: walletCreateOrConnectWithoutUsersInput
    connect?: walletWhereUniqueInput
  }

  export type adminUpdateOneWithoutUsersNestedInput = {
    create?: XOR<adminCreateWithoutUsersInput, adminUncheckedCreateWithoutUsersInput>
    connectOrCreate?: adminCreateOrConnectWithoutUsersInput
    upsert?: adminUpsertWithoutUsersInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUsersInput, adminUpdateWithoutUsersInput>, adminUncheckedUpdateWithoutUsersInput>
  }

  export type authproviderUpdateManyWithoutUsersNestedInput = {
    create?: XOR<authproviderCreateWithoutUsersInput, authproviderUncheckedCreateWithoutUsersInput> | authproviderCreateWithoutUsersInput[] | authproviderUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: authproviderCreateOrConnectWithoutUsersInput | authproviderCreateOrConnectWithoutUsersInput[]
    upsert?: authproviderUpsertWithWhereUniqueWithoutUsersInput | authproviderUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: authproviderCreateManyUsersInputEnvelope
    set?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    disconnect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    delete?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    connect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    update?: authproviderUpdateWithWhereUniqueWithoutUsersInput | authproviderUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: authproviderUpdateManyWithWhereWithoutUsersInput | authproviderUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: authproviderScalarWhereInput | authproviderScalarWhereInput[]
  }

  export type didwalletUpdateManyWithoutUsersNestedInput = {
    create?: XOR<didwalletCreateWithoutUsersInput, didwalletUncheckedCreateWithoutUsersInput> | didwalletCreateWithoutUsersInput[] | didwalletUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: didwalletCreateOrConnectWithoutUsersInput | didwalletCreateOrConnectWithoutUsersInput[]
    upsert?: didwalletUpsertWithWhereUniqueWithoutUsersInput | didwalletUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: didwalletCreateManyUsersInputEnvelope
    set?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    disconnect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    delete?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    connect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    update?: didwalletUpdateWithWhereUniqueWithoutUsersInput | didwalletUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: didwalletUpdateManyWithWhereWithoutUsersInput | didwalletUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: didwalletScalarWhereInput | didwalletScalarWhereInput[]
  }

  export type investorUpdateOneWithoutUsersNestedInput = {
    create?: XOR<investorCreateWithoutUsersInput, investorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: investorCreateOrConnectWithoutUsersInput
    upsert?: investorUpsertWithoutUsersInput
    disconnect?: investorWhereInput | boolean
    delete?: investorWhereInput | boolean
    connect?: investorWhereUniqueInput
    update?: XOR<XOR<investorUpdateToOneWithWhereWithoutUsersInput, investorUpdateWithoutUsersInput>, investorUncheckedUpdateWithoutUsersInput>
  }

  export type issuerUpdateOneWithoutUsersNestedInput = {
    create?: XOR<issuerCreateWithoutUsersInput, issuerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: issuerCreateOrConnectWithoutUsersInput
    upsert?: issuerUpsertWithoutUsersInput
    disconnect?: issuerWhereInput | boolean
    delete?: issuerWhereInput | boolean
    connect?: issuerWhereUniqueInput
    update?: XOR<XOR<issuerUpdateToOneWithWhereWithoutUsersInput, issuerUpdateWithoutUsersInput>, issuerUncheckedUpdateWithoutUsersInput>
  }

  export type kyc_applicantsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<kyc_applicantsCreateWithoutUsersInput, kyc_applicantsUncheckedCreateWithoutUsersInput> | kyc_applicantsCreateWithoutUsersInput[] | kyc_applicantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutUsersInput | kyc_applicantsCreateOrConnectWithoutUsersInput[]
    upsert?: kyc_applicantsUpsertWithWhereUniqueWithoutUsersInput | kyc_applicantsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: kyc_applicantsCreateManyUsersInputEnvelope
    set?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
    disconnect?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
    delete?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
    connect?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
    update?: kyc_applicantsUpdateWithWhereUniqueWithoutUsersInput | kyc_applicantsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: kyc_applicantsUpdateManyWithWhereWithoutUsersInput | kyc_applicantsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: kyc_applicantsScalarWhereInput | kyc_applicantsScalarWhereInput[]
  }

  export type kyc_complete_recordsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutUsersInput, kyc_complete_recordsUncheckedCreateWithoutUsersInput> | kyc_complete_recordsCreateWithoutUsersInput[] | kyc_complete_recordsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutUsersInput | kyc_complete_recordsCreateOrConnectWithoutUsersInput[]
    upsert?: kyc_complete_recordsUpsertWithWhereUniqueWithoutUsersInput | kyc_complete_recordsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: kyc_complete_recordsCreateManyUsersInputEnvelope
    set?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
    disconnect?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
    delete?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
    connect?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
    update?: kyc_complete_recordsUpdateWithWhereUniqueWithoutUsersInput | kyc_complete_recordsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: kyc_complete_recordsUpdateManyWithWhereWithoutUsersInput | kyc_complete_recordsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: kyc_complete_recordsScalarWhereInput | kyc_complete_recordsScalarWhereInput[]
  }

  export type KycDocumentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<KycDocumentCreateWithoutUsersInput, KycDocumentUncheckedCreateWithoutUsersInput> | KycDocumentCreateWithoutUsersInput[] | KycDocumentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: KycDocumentCreateOrConnectWithoutUsersInput | KycDocumentCreateOrConnectWithoutUsersInput[]
    upsert?: KycDocumentUpsertWithWhereUniqueWithoutUsersInput | KycDocumentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: KycDocumentCreateManyUsersInputEnvelope
    set?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    disconnect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    delete?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    connect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    update?: KycDocumentUpdateWithWhereUniqueWithoutUsersInput | KycDocumentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: KycDocumentUpdateManyWithWhereWithoutUsersInput | KycDocumentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: KycDocumentScalarWhereInput | KycDocumentScalarWhereInput[]
  }

  export type kycVerificationUpdateManyWithoutUsersNestedInput = {
    create?: XOR<kycVerificationCreateWithoutUsersInput, kycVerificationUncheckedCreateWithoutUsersInput> | kycVerificationCreateWithoutUsersInput[] | kycVerificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kycVerificationCreateOrConnectWithoutUsersInput | kycVerificationCreateOrConnectWithoutUsersInput[]
    upsert?: kycVerificationUpsertWithWhereUniqueWithoutUsersInput | kycVerificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: kycVerificationCreateManyUsersInputEnvelope
    set?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
    disconnect?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
    delete?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
    connect?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
    update?: kycVerificationUpdateWithWhereUniqueWithoutUsersInput | kycVerificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: kycVerificationUpdateManyWithWhereWithoutUsersInput | kycVerificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: kycVerificationScalarWhereInput | kycVerificationScalarWhereInput[]
  }

  export type refreshtokenUpdateManyWithoutUsersNestedInput = {
    create?: XOR<refreshtokenCreateWithoutUsersInput, refreshtokenUncheckedCreateWithoutUsersInput> | refreshtokenCreateWithoutUsersInput[] | refreshtokenUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUsersInput | refreshtokenCreateOrConnectWithoutUsersInput[]
    upsert?: refreshtokenUpsertWithWhereUniqueWithoutUsersInput | refreshtokenUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: refreshtokenCreateManyUsersInputEnvelope
    set?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    disconnect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    delete?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    update?: refreshtokenUpdateWithWhereUniqueWithoutUsersInput | refreshtokenUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: refreshtokenUpdateManyWithWhereWithoutUsersInput | refreshtokenUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
  }

  export type userroleUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput> | userroleCreateWithoutUsersInput[] | userroleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUsersInput | userroleCreateOrConnectWithoutUsersInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUsersInput | userroleUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userroleCreateManyUsersInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUsersInput | userroleUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUsersInput | userroleUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type walletUpdateOneWithoutUsersNestedInput = {
    create?: XOR<walletCreateWithoutUsersInput, walletUncheckedCreateWithoutUsersInput>
    connectOrCreate?: walletCreateOrConnectWithoutUsersInput
    upsert?: walletUpsertWithoutUsersInput
    disconnect?: walletWhereInput | boolean
    delete?: walletWhereInput | boolean
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutUsersInput, walletUpdateWithoutUsersInput>, walletUncheckedUpdateWithoutUsersInput>
  }

  export type adminUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<adminCreateWithoutUsersInput, adminUncheckedCreateWithoutUsersInput>
    connectOrCreate?: adminCreateOrConnectWithoutUsersInput
    upsert?: adminUpsertWithoutUsersInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUsersInput, adminUpdateWithoutUsersInput>, adminUncheckedUpdateWithoutUsersInput>
  }

  export type authproviderUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<authproviderCreateWithoutUsersInput, authproviderUncheckedCreateWithoutUsersInput> | authproviderCreateWithoutUsersInput[] | authproviderUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: authproviderCreateOrConnectWithoutUsersInput | authproviderCreateOrConnectWithoutUsersInput[]
    upsert?: authproviderUpsertWithWhereUniqueWithoutUsersInput | authproviderUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: authproviderCreateManyUsersInputEnvelope
    set?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    disconnect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    delete?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    connect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    update?: authproviderUpdateWithWhereUniqueWithoutUsersInput | authproviderUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: authproviderUpdateManyWithWhereWithoutUsersInput | authproviderUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: authproviderScalarWhereInput | authproviderScalarWhereInput[]
  }

  export type didwalletUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<didwalletCreateWithoutUsersInput, didwalletUncheckedCreateWithoutUsersInput> | didwalletCreateWithoutUsersInput[] | didwalletUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: didwalletCreateOrConnectWithoutUsersInput | didwalletCreateOrConnectWithoutUsersInput[]
    upsert?: didwalletUpsertWithWhereUniqueWithoutUsersInput | didwalletUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: didwalletCreateManyUsersInputEnvelope
    set?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    disconnect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    delete?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    connect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    update?: didwalletUpdateWithWhereUniqueWithoutUsersInput | didwalletUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: didwalletUpdateManyWithWhereWithoutUsersInput | didwalletUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: didwalletScalarWhereInput | didwalletScalarWhereInput[]
  }

  export type investorUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<investorCreateWithoutUsersInput, investorUncheckedCreateWithoutUsersInput>
    connectOrCreate?: investorCreateOrConnectWithoutUsersInput
    upsert?: investorUpsertWithoutUsersInput
    disconnect?: investorWhereInput | boolean
    delete?: investorWhereInput | boolean
    connect?: investorWhereUniqueInput
    update?: XOR<XOR<investorUpdateToOneWithWhereWithoutUsersInput, investorUpdateWithoutUsersInput>, investorUncheckedUpdateWithoutUsersInput>
  }

  export type issuerUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<issuerCreateWithoutUsersInput, issuerUncheckedCreateWithoutUsersInput>
    connectOrCreate?: issuerCreateOrConnectWithoutUsersInput
    upsert?: issuerUpsertWithoutUsersInput
    disconnect?: issuerWhereInput | boolean
    delete?: issuerWhereInput | boolean
    connect?: issuerWhereUniqueInput
    update?: XOR<XOR<issuerUpdateToOneWithWhereWithoutUsersInput, issuerUpdateWithoutUsersInput>, issuerUncheckedUpdateWithoutUsersInput>
  }

  export type kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<kyc_applicantsCreateWithoutUsersInput, kyc_applicantsUncheckedCreateWithoutUsersInput> | kyc_applicantsCreateWithoutUsersInput[] | kyc_applicantsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kyc_applicantsCreateOrConnectWithoutUsersInput | kyc_applicantsCreateOrConnectWithoutUsersInput[]
    upsert?: kyc_applicantsUpsertWithWhereUniqueWithoutUsersInput | kyc_applicantsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: kyc_applicantsCreateManyUsersInputEnvelope
    set?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
    disconnect?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
    delete?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
    connect?: kyc_applicantsWhereUniqueInput | kyc_applicantsWhereUniqueInput[]
    update?: kyc_applicantsUpdateWithWhereUniqueWithoutUsersInput | kyc_applicantsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: kyc_applicantsUpdateManyWithWhereWithoutUsersInput | kyc_applicantsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: kyc_applicantsScalarWhereInput | kyc_applicantsScalarWhereInput[]
  }

  export type kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<kyc_complete_recordsCreateWithoutUsersInput, kyc_complete_recordsUncheckedCreateWithoutUsersInput> | kyc_complete_recordsCreateWithoutUsersInput[] | kyc_complete_recordsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kyc_complete_recordsCreateOrConnectWithoutUsersInput | kyc_complete_recordsCreateOrConnectWithoutUsersInput[]
    upsert?: kyc_complete_recordsUpsertWithWhereUniqueWithoutUsersInput | kyc_complete_recordsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: kyc_complete_recordsCreateManyUsersInputEnvelope
    set?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
    disconnect?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
    delete?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
    connect?: kyc_complete_recordsWhereUniqueInput | kyc_complete_recordsWhereUniqueInput[]
    update?: kyc_complete_recordsUpdateWithWhereUniqueWithoutUsersInput | kyc_complete_recordsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: kyc_complete_recordsUpdateManyWithWhereWithoutUsersInput | kyc_complete_recordsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: kyc_complete_recordsScalarWhereInput | kyc_complete_recordsScalarWhereInput[]
  }

  export type KycDocumentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<KycDocumentCreateWithoutUsersInput, KycDocumentUncheckedCreateWithoutUsersInput> | KycDocumentCreateWithoutUsersInput[] | KycDocumentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: KycDocumentCreateOrConnectWithoutUsersInput | KycDocumentCreateOrConnectWithoutUsersInput[]
    upsert?: KycDocumentUpsertWithWhereUniqueWithoutUsersInput | KycDocumentUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: KycDocumentCreateManyUsersInputEnvelope
    set?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    disconnect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    delete?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    connect?: KycDocumentWhereUniqueInput | KycDocumentWhereUniqueInput[]
    update?: KycDocumentUpdateWithWhereUniqueWithoutUsersInput | KycDocumentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: KycDocumentUpdateManyWithWhereWithoutUsersInput | KycDocumentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: KycDocumentScalarWhereInput | KycDocumentScalarWhereInput[]
  }

  export type kycVerificationUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<kycVerificationCreateWithoutUsersInput, kycVerificationUncheckedCreateWithoutUsersInput> | kycVerificationCreateWithoutUsersInput[] | kycVerificationUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: kycVerificationCreateOrConnectWithoutUsersInput | kycVerificationCreateOrConnectWithoutUsersInput[]
    upsert?: kycVerificationUpsertWithWhereUniqueWithoutUsersInput | kycVerificationUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: kycVerificationCreateManyUsersInputEnvelope
    set?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
    disconnect?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
    delete?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
    connect?: kycVerificationWhereUniqueInput | kycVerificationWhereUniqueInput[]
    update?: kycVerificationUpdateWithWhereUniqueWithoutUsersInput | kycVerificationUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: kycVerificationUpdateManyWithWhereWithoutUsersInput | kycVerificationUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: kycVerificationScalarWhereInput | kycVerificationScalarWhereInput[]
  }

  export type refreshtokenUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<refreshtokenCreateWithoutUsersInput, refreshtokenUncheckedCreateWithoutUsersInput> | refreshtokenCreateWithoutUsersInput[] | refreshtokenUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUsersInput | refreshtokenCreateOrConnectWithoutUsersInput[]
    upsert?: refreshtokenUpsertWithWhereUniqueWithoutUsersInput | refreshtokenUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: refreshtokenCreateManyUsersInputEnvelope
    set?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    disconnect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    delete?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    update?: refreshtokenUpdateWithWhereUniqueWithoutUsersInput | refreshtokenUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: refreshtokenUpdateManyWithWhereWithoutUsersInput | refreshtokenUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput> | userroleCreateWithoutUsersInput[] | userroleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUsersInput | userroleCreateOrConnectWithoutUsersInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUsersInput | userroleUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userroleCreateManyUsersInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUsersInput | userroleUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUsersInput | userroleUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type walletUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<walletCreateWithoutUsersInput, walletUncheckedCreateWithoutUsersInput>
    connectOrCreate?: walletCreateOrConnectWithoutUsersInput
    upsert?: walletUpsertWithoutUsersInput
    disconnect?: walletWhereInput | boolean
    delete?: walletWhereInput | boolean
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutUsersInput, walletUpdateWithoutUsersInput>, walletUncheckedUpdateWithoutUsersInput>
  }

  export type usersCreateNestedOneWithoutWalletInput = {
    create?: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletInput
    connect?: usersWhereUniqueInput
  }

  export type issuerCreateNestedOneWithoutWalletInput = {
    create?: XOR<issuerCreateWithoutWalletInput, issuerUncheckedCreateWithoutWalletInput>
    connectOrCreate?: issuerCreateOrConnectWithoutWalletInput
    connect?: issuerWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
    connectOrCreate?: usersCreateOrConnectWithoutWalletInput
    upsert?: usersUpsertWithoutWalletInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWalletInput, usersUpdateWithoutWalletInput>, usersUncheckedUpdateWithoutWalletInput>
  }

  export type issuerUpdateOneWithoutWalletNestedInput = {
    create?: XOR<issuerCreateWithoutWalletInput, issuerUncheckedCreateWithoutWalletInput>
    connectOrCreate?: issuerCreateOrConnectWithoutWalletInput
    upsert?: issuerUpsertWithoutWalletInput
    disconnect?: issuerWhereInput | boolean
    delete?: issuerWhereInput | boolean
    connect?: issuerWhereUniqueInput
    update?: XOR<XOR<issuerUpdateToOneWithWhereWithoutWalletInput, issuerUpdateWithoutWalletInput>, issuerUncheckedUpdateWithoutWalletInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type usersCreateWithoutKyc_verificationsInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutKyc_verificationsInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutKyc_verificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutKyc_verificationsInput, usersUncheckedCreateWithoutKyc_verificationsInput>
  }

  export type usersUpsertWithoutKyc_verificationsInput = {
    update: XOR<usersUpdateWithoutKyc_verificationsInput, usersUncheckedUpdateWithoutKyc_verificationsInput>
    create: XOR<usersCreateWithoutKyc_verificationsInput, usersUncheckedCreateWithoutKyc_verificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutKyc_verificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutKyc_verificationsInput, usersUncheckedUpdateWithoutKyc_verificationsInput>
  }

  export type usersUpdateWithoutKyc_verificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutKyc_verificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type kyc_complete_recordsCreateWithoutKyc_documentsInput = {
    applicant_id: string
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesCreateNestedManyWithoutKyc_complete_recordsInput
    users?: usersCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsUncheckedCreateWithoutKyc_documentsInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoUncheckedCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsCreateOrConnectWithoutKyc_documentsInput = {
    where: kyc_complete_recordsWhereUniqueInput
    create: XOR<kyc_complete_recordsCreateWithoutKyc_documentsInput, kyc_complete_recordsUncheckedCreateWithoutKyc_documentsInput>
  }

  export type usersCreateWithoutKyc_documentsInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutKyc_documentsInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutKyc_documentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutKyc_documentsInput, usersUncheckedCreateWithoutKyc_documentsInput>
  }

  export type kyc_complete_recordsUpsertWithoutKyc_documentsInput = {
    update: XOR<kyc_complete_recordsUpdateWithoutKyc_documentsInput, kyc_complete_recordsUncheckedUpdateWithoutKyc_documentsInput>
    create: XOR<kyc_complete_recordsCreateWithoutKyc_documentsInput, kyc_complete_recordsUncheckedCreateWithoutKyc_documentsInput>
    where?: kyc_complete_recordsWhereInput
  }

  export type kyc_complete_recordsUpdateToOneWithWhereWithoutKyc_documentsInput = {
    where?: kyc_complete_recordsWhereInput
    data: XOR<kyc_complete_recordsUpdateWithoutKyc_documentsInput, kyc_complete_recordsUncheckedUpdateWithoutKyc_documentsInput>
  }

  export type kyc_complete_recordsUpdateWithoutKyc_documentsInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUpdateManyWithoutKyc_complete_recordsNestedInput
    users?: usersUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_complete_recordsUncheckedUpdateWithoutKyc_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUncheckedUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type usersUpsertWithoutKyc_documentsInput = {
    update: XOR<usersUpdateWithoutKyc_documentsInput, usersUncheckedUpdateWithoutKyc_documentsInput>
    create: XOR<usersCreateWithoutKyc_documentsInput, usersUncheckedCreateWithoutKyc_documentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutKyc_documentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutKyc_documentsInput, usersUncheckedUpdateWithoutKyc_documentsInput>
  }

  export type usersUpdateWithoutKyc_documentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutKyc_documentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutAdminInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAdminInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAdminInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAdminInput, usersUncheckedCreateWithoutAdminInput>
  }

  export type usersUpsertWithoutAdminInput = {
    update: XOR<usersUpdateWithoutAdminInput, usersUncheckedUpdateWithoutAdminInput>
    create: XOR<usersCreateWithoutAdminInput, usersUncheckedCreateWithoutAdminInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAdminInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAdminInput, usersUncheckedUpdateWithoutAdminInput>
  }

  export type usersUpdateWithoutAdminInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutAuthproviderInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAuthproviderInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAuthproviderInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAuthproviderInput, usersUncheckedCreateWithoutAuthproviderInput>
  }

  export type usersUpsertWithoutAuthproviderInput = {
    update: XOR<usersUpdateWithoutAuthproviderInput, usersUncheckedUpdateWithoutAuthproviderInput>
    create: XOR<usersCreateWithoutAuthproviderInput, usersUncheckedCreateWithoutAuthproviderInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAuthproviderInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAuthproviderInput, usersUncheckedUpdateWithoutAuthproviderInput>
  }

  export type usersUpdateWithoutAuthproviderInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAuthproviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutDidwalletInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutDidwalletInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutDidwalletInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutDidwalletInput, usersUncheckedCreateWithoutDidwalletInput>
  }

  export type usersUpsertWithoutDidwalletInput = {
    update: XOR<usersUpdateWithoutDidwalletInput, usersUncheckedUpdateWithoutDidwalletInput>
    create: XOR<usersCreateWithoutDidwalletInput, usersUncheckedCreateWithoutDidwalletInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutDidwalletInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutDidwalletInput, usersUncheckedUpdateWithoutDidwalletInput>
  }

  export type usersUpdateWithoutDidwalletInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutDidwalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutInvestorInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutInvestorInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutInvestorInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInvestorInput, usersUncheckedCreateWithoutInvestorInput>
  }

  export type usersUpsertWithoutInvestorInput = {
    update: XOR<usersUpdateWithoutInvestorInput, usersUncheckedUpdateWithoutInvestorInput>
    create: XOR<usersCreateWithoutInvestorInput, usersUncheckedCreateWithoutInvestorInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutInvestorInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutInvestorInput, usersUncheckedUpdateWithoutInvestorInput>
  }

  export type usersUpdateWithoutInvestorInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutInvestorInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutIssuerInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutIssuerInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutIssuerInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutIssuerInput, usersUncheckedCreateWithoutIssuerInput>
  }

  export type walletCreateWithoutIssuerInput = {
    id?: string
    address: string
    chain?: string
    type?: string
    provider?: string
    did?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutWalletInput
  }

  export type walletUncheckedCreateWithoutIssuerInput = {
    id?: string
    user_id: number
    address: string
    chain?: string
    type?: string
    provider?: string
    did?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type walletCreateOrConnectWithoutIssuerInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutIssuerInput, walletUncheckedCreateWithoutIssuerInput>
  }

  export type usersUpsertWithoutIssuerInput = {
    update: XOR<usersUpdateWithoutIssuerInput, usersUncheckedUpdateWithoutIssuerInput>
    create: XOR<usersCreateWithoutIssuerInput, usersUncheckedCreateWithoutIssuerInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutIssuerInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutIssuerInput, usersUncheckedUpdateWithoutIssuerInput>
  }

  export type usersUpdateWithoutIssuerInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutIssuerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type walletUpsertWithoutIssuerInput = {
    update: XOR<walletUpdateWithoutIssuerInput, walletUncheckedUpdateWithoutIssuerInput>
    create: XOR<walletCreateWithoutIssuerInput, walletUncheckedCreateWithoutIssuerInput>
    where?: walletWhereInput
  }

  export type walletUpdateToOneWithWhereWithoutIssuerInput = {
    where?: walletWhereInput
    data: XOR<walletUpdateWithoutIssuerInput, walletUncheckedUpdateWithoutIssuerInput>
  }

  export type walletUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    did?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateWithoutIssuerInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    did?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_applicantsCreateWithoutKyc_address_infoInput = {
    applicant_id: string
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_applicantsInput
    users?: usersCreateNestedOneWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsUncheckedCreateWithoutKyc_address_infoInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    personal_info_id?: number | null
    kyc_audit_log?: kyc_audit_logUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyUncheckedCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsCreateOrConnectWithoutKyc_address_infoInput = {
    where: kyc_applicantsWhereUniqueInput
    create: XOR<kyc_applicantsCreateWithoutKyc_address_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_address_infoInput>
  }

  export type kyc_applicantsUpsertWithoutKyc_address_infoInput = {
    update: XOR<kyc_applicantsUpdateWithoutKyc_address_infoInput, kyc_applicantsUncheckedUpdateWithoutKyc_address_infoInput>
    create: XOR<kyc_applicantsCreateWithoutKyc_address_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_address_infoInput>
    where?: kyc_applicantsWhereInput
  }

  export type kyc_applicantsUpdateToOneWithWhereWithoutKyc_address_infoInput = {
    where?: kyc_applicantsWhereInput
    data: XOR<kyc_applicantsUpdateWithoutKyc_address_infoInput, kyc_applicantsUncheckedUpdateWithoutKyc_address_infoInput>
  }

  export type kyc_applicantsUpdateWithoutKyc_address_infoInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_applicantsNestedInput
    users?: usersUpdateOneWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_applicantsUncheckedUpdateWithoutKyc_address_infoInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    personal_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    kyc_audit_log?: kyc_audit_logUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUncheckedUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_complete_recordsCreateWithoutKyc_addressesInput = {
    applicant_id: string
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    users?: usersCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsUncheckedCreateWithoutKyc_addressesInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoUncheckedCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsCreateOrConnectWithoutKyc_addressesInput = {
    where: kyc_complete_recordsWhereUniqueInput
    create: XOR<kyc_complete_recordsCreateWithoutKyc_addressesInput, kyc_complete_recordsUncheckedCreateWithoutKyc_addressesInput>
  }

  export type kyc_complete_recordsUpsertWithoutKyc_addressesInput = {
    update: XOR<kyc_complete_recordsUpdateWithoutKyc_addressesInput, kyc_complete_recordsUncheckedUpdateWithoutKyc_addressesInput>
    create: XOR<kyc_complete_recordsCreateWithoutKyc_addressesInput, kyc_complete_recordsUncheckedCreateWithoutKyc_addressesInput>
    where?: kyc_complete_recordsWhereInput
  }

  export type kyc_complete_recordsUpdateToOneWithWhereWithoutKyc_addressesInput = {
    where?: kyc_complete_recordsWhereInput
    data: XOR<kyc_complete_recordsUpdateWithoutKyc_addressesInput, kyc_complete_recordsUncheckedUpdateWithoutKyc_addressesInput>
  }

  export type kyc_complete_recordsUpdateWithoutKyc_addressesInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_complete_recordsUncheckedUpdateWithoutKyc_addressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUncheckedUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_address_infoCreateWithoutKyc_applicantsInput = {
    address_type: string
    is_primary?: boolean
    street?: string | null
    street_line2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    verification_method?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput = {
    id?: number
    address_type: string
    is_primary?: boolean
    street?: string | null
    street_line2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    verification_method?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type kyc_address_infoCreateOrConnectWithoutKyc_applicantsInput = {
    where: kyc_address_infoWhereUniqueInput
    create: XOR<kyc_address_infoCreateWithoutKyc_applicantsInput, kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type kyc_address_infoCreateManyKyc_applicantsInputEnvelope = {
    data: kyc_address_infoCreateManyKyc_applicantsInput | kyc_address_infoCreateManyKyc_applicantsInput[]
    skipDuplicates?: boolean
  }

  export type kyc_personal_infoCreateWithoutKyc_applicantsInput = {
    applicant_id?: string | null
    first_name?: string | null
    last_name?: string | null
    middle_name?: string | null
    full_name?: string | null
    legal_name?: string | null
    gender?: string | null
    date_of_birth?: Date | string | null
    place_of_birth?: string | null
    country_of_birth?: string | null
    state_of_birth?: string | null
    nationality?: string | null
    phone?: string | null
    email?: string | null
    country?: string | null
    tax_residence_country?: string | null
    tax_identification_number?: string | null
    id_number?: string | null
    created_at?: Date | string
    updated_at: Date | string
    kyc_complete_records?: kyc_complete_recordsCreateNestedOneWithoutKyc_personal_infoInput
  }

  export type kyc_personal_infoUncheckedCreateWithoutKyc_applicantsInput = {
    id?: number
    applicant_id?: string | null
    record_id?: number | null
    first_name?: string | null
    last_name?: string | null
    middle_name?: string | null
    full_name?: string | null
    legal_name?: string | null
    gender?: string | null
    date_of_birth?: Date | string | null
    place_of_birth?: string | null
    country_of_birth?: string | null
    state_of_birth?: string | null
    nationality?: string | null
    phone?: string | null
    email?: string | null
    country?: string | null
    tax_residence_country?: string | null
    tax_identification_number?: string | null
    id_number?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type kyc_personal_infoCreateOrConnectWithoutKyc_applicantsInput = {
    where: kyc_personal_infoWhereUniqueInput
    create: XOR<kyc_personal_infoCreateWithoutKyc_applicantsInput, kyc_personal_infoUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type usersCreateWithoutKyc_applicantsInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutKyc_applicantsInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutKyc_applicantsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutKyc_applicantsInput, usersUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type kyc_audit_logCreateWithoutKyc_applicantsInput = {
    action: string
    performed_by?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput = {
    id?: number
    action: string
    performed_by?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type kyc_audit_logCreateOrConnectWithoutKyc_applicantsInput = {
    where: kyc_audit_logWhereUniqueInput
    create: XOR<kyc_audit_logCreateWithoutKyc_applicantsInput, kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type kyc_audit_logCreateManyKyc_applicantsInputEnvelope = {
    data: kyc_audit_logCreateManyKyc_applicantsInput | kyc_audit_logCreateManyKyc_applicantsInput[]
    skipDuplicates?: boolean
  }

  export type kyc_raw_dataCreateWithoutKyc_applicantsInput = {
    data_type: string
    source: string
    raw_data: string
    created_at?: Date | string
  }

  export type kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput = {
    id?: number
    data_type: string
    source: string
    raw_data: string
    created_at?: Date | string
  }

  export type kyc_raw_dataCreateOrConnectWithoutKyc_applicantsInput = {
    where: kyc_raw_dataWhereUniqueInput
    create: XOR<kyc_raw_dataCreateWithoutKyc_applicantsInput, kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type kyc_raw_dataCreateManyKyc_applicantsInputEnvelope = {
    data: kyc_raw_dataCreateManyKyc_applicantsInput | kyc_raw_dataCreateManyKyc_applicantsInput[]
    skipDuplicates?: boolean
  }

  export type kyc_verification_historyCreateWithoutKyc_applicantsInput = {
    type: string
    review_status: string
    review_result?: string | null
    review_answer?: string | null
    reject_type?: string | null
    reject_labels?: string | null
    timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput = {
    id?: number
    type: string
    review_status: string
    review_result?: string | null
    review_answer?: string | null
    reject_type?: string | null
    reject_labels?: string | null
    timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_verification_historyCreateOrConnectWithoutKyc_applicantsInput = {
    where: kyc_verification_historyWhereUniqueInput
    create: XOR<kyc_verification_historyCreateWithoutKyc_applicantsInput, kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type kyc_verification_historyCreateManyKyc_applicantsInputEnvelope = {
    data: kyc_verification_historyCreateManyKyc_applicantsInput | kyc_verification_historyCreateManyKyc_applicantsInput[]
    skipDuplicates?: boolean
  }

  export type kyc_address_infoUpsertWithWhereUniqueWithoutKyc_applicantsInput = {
    where: kyc_address_infoWhereUniqueInput
    update: XOR<kyc_address_infoUpdateWithoutKyc_applicantsInput, kyc_address_infoUncheckedUpdateWithoutKyc_applicantsInput>
    create: XOR<kyc_address_infoCreateWithoutKyc_applicantsInput, kyc_address_infoUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type kyc_address_infoUpdateWithWhereUniqueWithoutKyc_applicantsInput = {
    where: kyc_address_infoWhereUniqueInput
    data: XOR<kyc_address_infoUpdateWithoutKyc_applicantsInput, kyc_address_infoUncheckedUpdateWithoutKyc_applicantsInput>
  }

  export type kyc_address_infoUpdateManyWithWhereWithoutKyc_applicantsInput = {
    where: kyc_address_infoScalarWhereInput
    data: XOR<kyc_address_infoUpdateManyMutationInput, kyc_address_infoUncheckedUpdateManyWithoutKyc_applicantsInput>
  }

  export type kyc_address_infoScalarWhereInput = {
    AND?: kyc_address_infoScalarWhereInput | kyc_address_infoScalarWhereInput[]
    OR?: kyc_address_infoScalarWhereInput[]
    NOT?: kyc_address_infoScalarWhereInput | kyc_address_infoScalarWhereInput[]
    id?: IntFilter<"kyc_address_info"> | number
    applicant_id?: StringFilter<"kyc_address_info"> | string
    address_type?: StringFilter<"kyc_address_info"> | string
    is_primary?: BoolFilter<"kyc_address_info"> | boolean
    street?: StringNullableFilter<"kyc_address_info"> | string | null
    street_line2?: StringNullableFilter<"kyc_address_info"> | string | null
    city?: StringNullableFilter<"kyc_address_info"> | string | null
    state?: StringNullableFilter<"kyc_address_info"> | string | null
    postal_code?: StringNullableFilter<"kyc_address_info"> | string | null
    country?: StringNullableFilter<"kyc_address_info"> | string | null
    is_verified?: BoolFilter<"kyc_address_info"> | boolean
    verification_method?: StringNullableFilter<"kyc_address_info"> | string | null
    created_at?: DateTimeFilter<"kyc_address_info"> | Date | string
    updated_at?: DateTimeFilter<"kyc_address_info"> | Date | string
  }

  export type kyc_personal_infoUpsertWithoutKyc_applicantsInput = {
    update: XOR<kyc_personal_infoUpdateWithoutKyc_applicantsInput, kyc_personal_infoUncheckedUpdateWithoutKyc_applicantsInput>
    create: XOR<kyc_personal_infoCreateWithoutKyc_applicantsInput, kyc_personal_infoUncheckedCreateWithoutKyc_applicantsInput>
    where?: kyc_personal_infoWhereInput
  }

  export type kyc_personal_infoUpdateToOneWithWhereWithoutKyc_applicantsInput = {
    where?: kyc_personal_infoWhereInput
    data: XOR<kyc_personal_infoUpdateWithoutKyc_applicantsInput, kyc_personal_infoUncheckedUpdateWithoutKyc_applicantsInput>
  }

  export type kyc_personal_infoUpdateWithoutKyc_applicantsInput = {
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    country_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    state_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_residence_country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_identification_number?: NullableStringFieldUpdateOperationsInput | string | null
    id_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_complete_records?: kyc_complete_recordsUpdateOneWithoutKyc_personal_infoNestedInput
  }

  export type kyc_personal_infoUncheckedUpdateWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    country_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    state_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_residence_country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_identification_number?: NullableStringFieldUpdateOperationsInput | string | null
    id_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutKyc_applicantsInput = {
    update: XOR<usersUpdateWithoutKyc_applicantsInput, usersUncheckedUpdateWithoutKyc_applicantsInput>
    create: XOR<usersCreateWithoutKyc_applicantsInput, usersUncheckedCreateWithoutKyc_applicantsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutKyc_applicantsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutKyc_applicantsInput, usersUncheckedUpdateWithoutKyc_applicantsInput>
  }

  export type usersUpdateWithoutKyc_applicantsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type kyc_audit_logUpsertWithWhereUniqueWithoutKyc_applicantsInput = {
    where: kyc_audit_logWhereUniqueInput
    update: XOR<kyc_audit_logUpdateWithoutKyc_applicantsInput, kyc_audit_logUncheckedUpdateWithoutKyc_applicantsInput>
    create: XOR<kyc_audit_logCreateWithoutKyc_applicantsInput, kyc_audit_logUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type kyc_audit_logUpdateWithWhereUniqueWithoutKyc_applicantsInput = {
    where: kyc_audit_logWhereUniqueInput
    data: XOR<kyc_audit_logUpdateWithoutKyc_applicantsInput, kyc_audit_logUncheckedUpdateWithoutKyc_applicantsInput>
  }

  export type kyc_audit_logUpdateManyWithWhereWithoutKyc_applicantsInput = {
    where: kyc_audit_logScalarWhereInput
    data: XOR<kyc_audit_logUpdateManyMutationInput, kyc_audit_logUncheckedUpdateManyWithoutKyc_applicantsInput>
  }

  export type kyc_audit_logScalarWhereInput = {
    AND?: kyc_audit_logScalarWhereInput | kyc_audit_logScalarWhereInput[]
    OR?: kyc_audit_logScalarWhereInput[]
    NOT?: kyc_audit_logScalarWhereInput | kyc_audit_logScalarWhereInput[]
    id?: IntFilter<"kyc_audit_log"> | number
    applicant_id?: StringFilter<"kyc_audit_log"> | string
    action?: StringFilter<"kyc_audit_log"> | string
    performed_by?: StringNullableFilter<"kyc_audit_log"> | string | null
    details?: StringNullableFilter<"kyc_audit_log"> | string | null
    timestamp?: DateTimeFilter<"kyc_audit_log"> | Date | string
  }

  export type kyc_raw_dataUpsertWithWhereUniqueWithoutKyc_applicantsInput = {
    where: kyc_raw_dataWhereUniqueInput
    update: XOR<kyc_raw_dataUpdateWithoutKyc_applicantsInput, kyc_raw_dataUncheckedUpdateWithoutKyc_applicantsInput>
    create: XOR<kyc_raw_dataCreateWithoutKyc_applicantsInput, kyc_raw_dataUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type kyc_raw_dataUpdateWithWhereUniqueWithoutKyc_applicantsInput = {
    where: kyc_raw_dataWhereUniqueInput
    data: XOR<kyc_raw_dataUpdateWithoutKyc_applicantsInput, kyc_raw_dataUncheckedUpdateWithoutKyc_applicantsInput>
  }

  export type kyc_raw_dataUpdateManyWithWhereWithoutKyc_applicantsInput = {
    where: kyc_raw_dataScalarWhereInput
    data: XOR<kyc_raw_dataUpdateManyMutationInput, kyc_raw_dataUncheckedUpdateManyWithoutKyc_applicantsInput>
  }

  export type kyc_raw_dataScalarWhereInput = {
    AND?: kyc_raw_dataScalarWhereInput | kyc_raw_dataScalarWhereInput[]
    OR?: kyc_raw_dataScalarWhereInput[]
    NOT?: kyc_raw_dataScalarWhereInput | kyc_raw_dataScalarWhereInput[]
    id?: IntFilter<"kyc_raw_data"> | number
    applicant_id?: StringFilter<"kyc_raw_data"> | string
    data_type?: StringFilter<"kyc_raw_data"> | string
    source?: StringFilter<"kyc_raw_data"> | string
    raw_data?: StringFilter<"kyc_raw_data"> | string
    created_at?: DateTimeFilter<"kyc_raw_data"> | Date | string
  }

  export type kyc_verification_historyUpsertWithWhereUniqueWithoutKyc_applicantsInput = {
    where: kyc_verification_historyWhereUniqueInput
    update: XOR<kyc_verification_historyUpdateWithoutKyc_applicantsInput, kyc_verification_historyUncheckedUpdateWithoutKyc_applicantsInput>
    create: XOR<kyc_verification_historyCreateWithoutKyc_applicantsInput, kyc_verification_historyUncheckedCreateWithoutKyc_applicantsInput>
  }

  export type kyc_verification_historyUpdateWithWhereUniqueWithoutKyc_applicantsInput = {
    where: kyc_verification_historyWhereUniqueInput
    data: XOR<kyc_verification_historyUpdateWithoutKyc_applicantsInput, kyc_verification_historyUncheckedUpdateWithoutKyc_applicantsInput>
  }

  export type kyc_verification_historyUpdateManyWithWhereWithoutKyc_applicantsInput = {
    where: kyc_verification_historyScalarWhereInput
    data: XOR<kyc_verification_historyUpdateManyMutationInput, kyc_verification_historyUncheckedUpdateManyWithoutKyc_applicantsInput>
  }

  export type kyc_verification_historyScalarWhereInput = {
    AND?: kyc_verification_historyScalarWhereInput | kyc_verification_historyScalarWhereInput[]
    OR?: kyc_verification_historyScalarWhereInput[]
    NOT?: kyc_verification_historyScalarWhereInput | kyc_verification_historyScalarWhereInput[]
    id?: IntFilter<"kyc_verification_history"> | number
    applicant_id?: StringFilter<"kyc_verification_history"> | string
    type?: StringFilter<"kyc_verification_history"> | string
    review_status?: StringFilter<"kyc_verification_history"> | string
    review_result?: StringNullableFilter<"kyc_verification_history"> | string | null
    review_answer?: StringNullableFilter<"kyc_verification_history"> | string | null
    reject_type?: StringNullableFilter<"kyc_verification_history"> | string | null
    reject_labels?: StringNullableFilter<"kyc_verification_history"> | string | null
    timestamp?: DateTimeFilter<"kyc_verification_history"> | Date | string
    created_at?: DateTimeFilter<"kyc_verification_history"> | Date | string
  }

  export type kyc_applicantsCreateWithoutKyc_audit_logInput = {
    applicant_id: string
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    kyc_address_info?: kyc_address_infoCreateNestedManyWithoutKyc_applicantsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_applicantsInput
    users?: usersCreateNestedOneWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsUncheckedCreateWithoutKyc_audit_logInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    personal_info_id?: number | null
    kyc_address_info?: kyc_address_infoUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyUncheckedCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsCreateOrConnectWithoutKyc_audit_logInput = {
    where: kyc_applicantsWhereUniqueInput
    create: XOR<kyc_applicantsCreateWithoutKyc_audit_logInput, kyc_applicantsUncheckedCreateWithoutKyc_audit_logInput>
  }

  export type kyc_applicantsUpsertWithoutKyc_audit_logInput = {
    update: XOR<kyc_applicantsUpdateWithoutKyc_audit_logInput, kyc_applicantsUncheckedUpdateWithoutKyc_audit_logInput>
    create: XOR<kyc_applicantsCreateWithoutKyc_audit_logInput, kyc_applicantsUncheckedCreateWithoutKyc_audit_logInput>
    where?: kyc_applicantsWhereInput
  }

  export type kyc_applicantsUpdateToOneWithWhereWithoutKyc_audit_logInput = {
    where?: kyc_applicantsWhereInput
    data: XOR<kyc_applicantsUpdateWithoutKyc_audit_logInput, kyc_applicantsUncheckedUpdateWithoutKyc_audit_logInput>
  }

  export type kyc_applicantsUpdateWithoutKyc_audit_logInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    kyc_address_info?: kyc_address_infoUpdateManyWithoutKyc_applicantsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_applicantsNestedInput
    users?: usersUpdateOneWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_applicantsUncheckedUpdateWithoutKyc_audit_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    personal_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    kyc_address_info?: kyc_address_infoUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUncheckedUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_addressesCreateWithoutKyc_complete_recordsInput = {
    address_type?: string
    is_primary?: boolean
    street?: string | null
    street_line_2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    updated_at: Date | string
    created_at?: Date | string
  }

  export type kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput = {
    id?: number
    address_type?: string
    is_primary?: boolean
    street?: string | null
    street_line_2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    updated_at: Date | string
    created_at?: Date | string
  }

  export type kyc_addressesCreateOrConnectWithoutKyc_complete_recordsInput = {
    where: kyc_addressesWhereUniqueInput
    create: XOR<kyc_addressesCreateWithoutKyc_complete_recordsInput, kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput>
  }

  export type kyc_addressesCreateManyKyc_complete_recordsInputEnvelope = {
    data: kyc_addressesCreateManyKyc_complete_recordsInput | kyc_addressesCreateManyKyc_complete_recordsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutKyc_complete_recordsInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutKyc_complete_recordsInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutKyc_complete_recordsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutKyc_complete_recordsInput, usersUncheckedCreateWithoutKyc_complete_recordsInput>
  }

  export type KycDocumentCreateWithoutKyc_complete_recordsInput = {
    applicant_id?: string | null
    country?: string | null
    created_at?: Date | string
    document_id?: string | null
    document_sub_type?: string | null
    document_type: string
    field_name?: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url?: string | null
    id_doc_type?: string | null
    issued_date?: Date | string | null
    number?: string | null
    page_type?: string | null
    status?: string
    updated_at: Date | string
    valid_until?: Date | string | null
    users?: usersCreateNestedOneWithoutKyc_documentsInput
  }

  export type KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput = {
    id?: number
    applicant_id?: string | null
    country?: string | null
    created_at?: Date | string
    document_id?: string | null
    document_sub_type?: string | null
    document_type: string
    field_name?: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url?: string | null
    id_doc_type?: string | null
    issued_date?: Date | string | null
    number?: string | null
    page_type?: string | null
    status?: string
    updated_at: Date | string
    user_id?: number | null
    valid_until?: Date | string | null
  }

  export type KycDocumentCreateOrConnectWithoutKyc_complete_recordsInput = {
    where: KycDocumentWhereUniqueInput
    create: XOR<KycDocumentCreateWithoutKyc_complete_recordsInput, KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput>
  }

  export type KycDocumentCreateManyKyc_complete_recordsInputEnvelope = {
    data: KycDocumentCreateManyKyc_complete_recordsInput | KycDocumentCreateManyKyc_complete_recordsInput[]
    skipDuplicates?: boolean
  }

  export type kyc_personal_infoCreateWithoutKyc_complete_recordsInput = {
    applicant_id?: string | null
    first_name?: string | null
    last_name?: string | null
    middle_name?: string | null
    full_name?: string | null
    legal_name?: string | null
    gender?: string | null
    date_of_birth?: Date | string | null
    place_of_birth?: string | null
    country_of_birth?: string | null
    state_of_birth?: string | null
    nationality?: string | null
    phone?: string | null
    email?: string | null
    country?: string | null
    tax_residence_country?: string | null
    tax_identification_number?: string | null
    id_number?: string | null
    created_at?: Date | string
    updated_at: Date | string
    kyc_applicants?: kyc_applicantsCreateNestedOneWithoutKyc_personal_infoInput
  }

  export type kyc_personal_infoUncheckedCreateWithoutKyc_complete_recordsInput = {
    id?: number
    applicant_id?: string | null
    first_name?: string | null
    last_name?: string | null
    middle_name?: string | null
    full_name?: string | null
    legal_name?: string | null
    gender?: string | null
    date_of_birth?: Date | string | null
    place_of_birth?: string | null
    country_of_birth?: string | null
    state_of_birth?: string | null
    nationality?: string | null
    phone?: string | null
    email?: string | null
    country?: string | null
    tax_residence_country?: string | null
    tax_identification_number?: string | null
    id_number?: string | null
    created_at?: Date | string
    updated_at: Date | string
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedOneWithoutKyc_personal_infoInput
  }

  export type kyc_personal_infoCreateOrConnectWithoutKyc_complete_recordsInput = {
    where: kyc_personal_infoWhereUniqueInput
    create: XOR<kyc_personal_infoCreateWithoutKyc_complete_recordsInput, kyc_personal_infoUncheckedCreateWithoutKyc_complete_recordsInput>
  }

  export type kyc_verification_eventsCreateWithoutKyc_complete_recordsInput = {
    type?: string
    review_status?: string | null
    review_result?: string | null
    inspection_id?: string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput = {
    id?: number
    type?: string
    review_status?: string | null
    review_result?: string | null
    inspection_id?: string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_verification_eventsCreateOrConnectWithoutKyc_complete_recordsInput = {
    where: kyc_verification_eventsWhereUniqueInput
    create: XOR<kyc_verification_eventsCreateWithoutKyc_complete_recordsInput, kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput>
  }

  export type kyc_verification_eventsCreateManyKyc_complete_recordsInputEnvelope = {
    data: kyc_verification_eventsCreateManyKyc_complete_recordsInput | kyc_verification_eventsCreateManyKyc_complete_recordsInput[]
    skipDuplicates?: boolean
  }

  export type kyc_addressesUpsertWithWhereUniqueWithoutKyc_complete_recordsInput = {
    where: kyc_addressesWhereUniqueInput
    update: XOR<kyc_addressesUpdateWithoutKyc_complete_recordsInput, kyc_addressesUncheckedUpdateWithoutKyc_complete_recordsInput>
    create: XOR<kyc_addressesCreateWithoutKyc_complete_recordsInput, kyc_addressesUncheckedCreateWithoutKyc_complete_recordsInput>
  }

  export type kyc_addressesUpdateWithWhereUniqueWithoutKyc_complete_recordsInput = {
    where: kyc_addressesWhereUniqueInput
    data: XOR<kyc_addressesUpdateWithoutKyc_complete_recordsInput, kyc_addressesUncheckedUpdateWithoutKyc_complete_recordsInput>
  }

  export type kyc_addressesUpdateManyWithWhereWithoutKyc_complete_recordsInput = {
    where: kyc_addressesScalarWhereInput
    data: XOR<kyc_addressesUpdateManyMutationInput, kyc_addressesUncheckedUpdateManyWithoutKyc_complete_recordsInput>
  }

  export type kyc_addressesScalarWhereInput = {
    AND?: kyc_addressesScalarWhereInput | kyc_addressesScalarWhereInput[]
    OR?: kyc_addressesScalarWhereInput[]
    NOT?: kyc_addressesScalarWhereInput | kyc_addressesScalarWhereInput[]
    id?: IntFilter<"kyc_addresses"> | number
    record_id?: IntFilter<"kyc_addresses"> | number
    address_type?: StringFilter<"kyc_addresses"> | string
    is_primary?: BoolFilter<"kyc_addresses"> | boolean
    street?: StringNullableFilter<"kyc_addresses"> | string | null
    street_line_2?: StringNullableFilter<"kyc_addresses"> | string | null
    city?: StringNullableFilter<"kyc_addresses"> | string | null
    state?: StringNullableFilter<"kyc_addresses"> | string | null
    postal_code?: StringNullableFilter<"kyc_addresses"> | string | null
    country?: StringNullableFilter<"kyc_addresses"> | string | null
    is_verified?: BoolFilter<"kyc_addresses"> | boolean
    updated_at?: DateTimeFilter<"kyc_addresses"> | Date | string
    created_at?: DateTimeFilter<"kyc_addresses"> | Date | string
  }

  export type usersUpsertWithoutKyc_complete_recordsInput = {
    update: XOR<usersUpdateWithoutKyc_complete_recordsInput, usersUncheckedUpdateWithoutKyc_complete_recordsInput>
    create: XOR<usersCreateWithoutKyc_complete_recordsInput, usersUncheckedCreateWithoutKyc_complete_recordsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutKyc_complete_recordsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutKyc_complete_recordsInput, usersUncheckedUpdateWithoutKyc_complete_recordsInput>
  }

  export type usersUpdateWithoutKyc_complete_recordsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutKyc_complete_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type KycDocumentUpsertWithWhereUniqueWithoutKyc_complete_recordsInput = {
    where: KycDocumentWhereUniqueInput
    update: XOR<KycDocumentUpdateWithoutKyc_complete_recordsInput, KycDocumentUncheckedUpdateWithoutKyc_complete_recordsInput>
    create: XOR<KycDocumentCreateWithoutKyc_complete_recordsInput, KycDocumentUncheckedCreateWithoutKyc_complete_recordsInput>
  }

  export type KycDocumentUpdateWithWhereUniqueWithoutKyc_complete_recordsInput = {
    where: KycDocumentWhereUniqueInput
    data: XOR<KycDocumentUpdateWithoutKyc_complete_recordsInput, KycDocumentUncheckedUpdateWithoutKyc_complete_recordsInput>
  }

  export type KycDocumentUpdateManyWithWhereWithoutKyc_complete_recordsInput = {
    where: KycDocumentScalarWhereInput
    data: XOR<KycDocumentUpdateManyMutationInput, KycDocumentUncheckedUpdateManyWithoutKyc_complete_recordsInput>
  }

  export type KycDocumentScalarWhereInput = {
    AND?: KycDocumentScalarWhereInput | KycDocumentScalarWhereInput[]
    OR?: KycDocumentScalarWhereInput[]
    NOT?: KycDocumentScalarWhereInput | KycDocumentScalarWhereInput[]
    id?: IntFilter<"KycDocument"> | number
    applicant_id?: StringNullableFilter<"KycDocument"> | string | null
    country?: StringNullableFilter<"KycDocument"> | string | null
    created_at?: DateTimeFilter<"KycDocument"> | Date | string
    document_id?: StringNullableFilter<"KycDocument"> | string | null
    document_sub_type?: StringNullableFilter<"KycDocument"> | string | null
    document_type?: StringFilter<"KycDocument"> | string
    field_name?: StringNullableFilter<"KycDocument"> | string | null
    file_name?: StringFilter<"KycDocument"> | string
    file_path?: StringFilter<"KycDocument"> | string
    file_type?: StringFilter<"KycDocument"> | string
    file_url?: StringNullableFilter<"KycDocument"> | string | null
    id_doc_type?: StringNullableFilter<"KycDocument"> | string | null
    issued_date?: DateTimeNullableFilter<"KycDocument"> | Date | string | null
    number?: StringNullableFilter<"KycDocument"> | string | null
    page_type?: StringNullableFilter<"KycDocument"> | string | null
    record_id?: IntNullableFilter<"KycDocument"> | number | null
    status?: StringFilter<"KycDocument"> | string
    updated_at?: DateTimeFilter<"KycDocument"> | Date | string
    user_id?: IntNullableFilter<"KycDocument"> | number | null
    valid_until?: DateTimeNullableFilter<"KycDocument"> | Date | string | null
  }

  export type kyc_personal_infoUpsertWithoutKyc_complete_recordsInput = {
    update: XOR<kyc_personal_infoUpdateWithoutKyc_complete_recordsInput, kyc_personal_infoUncheckedUpdateWithoutKyc_complete_recordsInput>
    create: XOR<kyc_personal_infoCreateWithoutKyc_complete_recordsInput, kyc_personal_infoUncheckedCreateWithoutKyc_complete_recordsInput>
    where?: kyc_personal_infoWhereInput
  }

  export type kyc_personal_infoUpdateToOneWithWhereWithoutKyc_complete_recordsInput = {
    where?: kyc_personal_infoWhereInput
    data: XOR<kyc_personal_infoUpdateWithoutKyc_complete_recordsInput, kyc_personal_infoUncheckedUpdateWithoutKyc_complete_recordsInput>
  }

  export type kyc_personal_infoUpdateWithoutKyc_complete_recordsInput = {
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    country_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    state_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_residence_country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_identification_number?: NullableStringFieldUpdateOperationsInput | string | null
    id_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_applicants?: kyc_applicantsUpdateOneWithoutKyc_personal_infoNestedInput
  }

  export type kyc_personal_infoUncheckedUpdateWithoutKyc_complete_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    middle_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    legal_name?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    date_of_birth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    place_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    country_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    state_of_birth?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_residence_country?: NullableStringFieldUpdateOperationsInput | string | null
    tax_identification_number?: NullableStringFieldUpdateOperationsInput | string | null
    id_number?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_applicants?: kyc_applicantsUncheckedUpdateOneWithoutKyc_personal_infoNestedInput
  }

  export type kyc_verification_eventsUpsertWithWhereUniqueWithoutKyc_complete_recordsInput = {
    where: kyc_verification_eventsWhereUniqueInput
    update: XOR<kyc_verification_eventsUpdateWithoutKyc_complete_recordsInput, kyc_verification_eventsUncheckedUpdateWithoutKyc_complete_recordsInput>
    create: XOR<kyc_verification_eventsCreateWithoutKyc_complete_recordsInput, kyc_verification_eventsUncheckedCreateWithoutKyc_complete_recordsInput>
  }

  export type kyc_verification_eventsUpdateWithWhereUniqueWithoutKyc_complete_recordsInput = {
    where: kyc_verification_eventsWhereUniqueInput
    data: XOR<kyc_verification_eventsUpdateWithoutKyc_complete_recordsInput, kyc_verification_eventsUncheckedUpdateWithoutKyc_complete_recordsInput>
  }

  export type kyc_verification_eventsUpdateManyWithWhereWithoutKyc_complete_recordsInput = {
    where: kyc_verification_eventsScalarWhereInput
    data: XOR<kyc_verification_eventsUpdateManyMutationInput, kyc_verification_eventsUncheckedUpdateManyWithoutKyc_complete_recordsInput>
  }

  export type kyc_verification_eventsScalarWhereInput = {
    AND?: kyc_verification_eventsScalarWhereInput | kyc_verification_eventsScalarWhereInput[]
    OR?: kyc_verification_eventsScalarWhereInput[]
    NOT?: kyc_verification_eventsScalarWhereInput | kyc_verification_eventsScalarWhereInput[]
    id?: IntFilter<"kyc_verification_events"> | number
    record_id?: IntFilter<"kyc_verification_events"> | number
    type?: StringFilter<"kyc_verification_events"> | string
    review_status?: StringNullableFilter<"kyc_verification_events"> | string | null
    review_result?: StringNullableFilter<"kyc_verification_events"> | string | null
    inspection_id?: StringNullableFilter<"kyc_verification_events"> | string | null
    event_data?: JsonNullableFilter<"kyc_verification_events">
    event_timestamp?: DateTimeFilter<"kyc_verification_events"> | Date | string
    created_at?: DateTimeFilter<"kyc_verification_events"> | Date | string
  }

  export type kyc_applicantsCreateWithoutKyc_personal_infoInput = {
    applicant_id: string
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    kyc_address_info?: kyc_address_infoCreateNestedManyWithoutKyc_applicantsInput
    users?: usersCreateNestedOneWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsUncheckedCreateWithoutKyc_personal_infoInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    kyc_address_info?: kyc_address_infoUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyUncheckedCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsCreateOrConnectWithoutKyc_personal_infoInput = {
    where: kyc_applicantsWhereUniqueInput
    create: XOR<kyc_applicantsCreateWithoutKyc_personal_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_personal_infoInput>
  }

  export type kyc_complete_recordsCreateWithoutKyc_personal_infoInput = {
    applicant_id: string
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesCreateNestedManyWithoutKyc_complete_recordsInput
    users?: usersCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsUncheckedCreateWithoutKyc_personal_infoInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsCreateOrConnectWithoutKyc_personal_infoInput = {
    where: kyc_complete_recordsWhereUniqueInput
    create: XOR<kyc_complete_recordsCreateWithoutKyc_personal_infoInput, kyc_complete_recordsUncheckedCreateWithoutKyc_personal_infoInput>
  }

  export type kyc_applicantsUpsertWithoutKyc_personal_infoInput = {
    update: XOR<kyc_applicantsUpdateWithoutKyc_personal_infoInput, kyc_applicantsUncheckedUpdateWithoutKyc_personal_infoInput>
    create: XOR<kyc_applicantsCreateWithoutKyc_personal_infoInput, kyc_applicantsUncheckedCreateWithoutKyc_personal_infoInput>
    where?: kyc_applicantsWhereInput
  }

  export type kyc_applicantsUpdateToOneWithWhereWithoutKyc_personal_infoInput = {
    where?: kyc_applicantsWhereInput
    data: XOR<kyc_applicantsUpdateWithoutKyc_personal_infoInput, kyc_applicantsUncheckedUpdateWithoutKyc_personal_infoInput>
  }

  export type kyc_applicantsUpdateWithoutKyc_personal_infoInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    kyc_address_info?: kyc_address_infoUpdateManyWithoutKyc_applicantsNestedInput
    users?: usersUpdateOneWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_applicantsUncheckedUpdateWithoutKyc_personal_infoInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    kyc_address_info?: kyc_address_infoUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUncheckedUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_complete_recordsUpsertWithoutKyc_personal_infoInput = {
    update: XOR<kyc_complete_recordsUpdateWithoutKyc_personal_infoInput, kyc_complete_recordsUncheckedUpdateWithoutKyc_personal_infoInput>
    create: XOR<kyc_complete_recordsCreateWithoutKyc_personal_infoInput, kyc_complete_recordsUncheckedCreateWithoutKyc_personal_infoInput>
    where?: kyc_complete_recordsWhereInput
  }

  export type kyc_complete_recordsUpdateToOneWithWhereWithoutKyc_personal_infoInput = {
    where?: kyc_complete_recordsWhereInput
    data: XOR<kyc_complete_recordsUpdateWithoutKyc_personal_infoInput, kyc_complete_recordsUncheckedUpdateWithoutKyc_personal_infoInput>
  }

  export type kyc_complete_recordsUpdateWithoutKyc_personal_infoInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUpdateManyWithoutKyc_complete_recordsNestedInput
    users?: usersUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_complete_recordsUncheckedUpdateWithoutKyc_personal_infoInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_applicantsCreateWithoutKyc_raw_dataInput = {
    applicant_id: string
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    kyc_address_info?: kyc_address_infoCreateNestedManyWithoutKyc_applicantsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_applicantsInput
    users?: usersCreateNestedOneWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsUncheckedCreateWithoutKyc_raw_dataInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    personal_info_id?: number | null
    kyc_address_info?: kyc_address_infoUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyUncheckedCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsCreateOrConnectWithoutKyc_raw_dataInput = {
    where: kyc_applicantsWhereUniqueInput
    create: XOR<kyc_applicantsCreateWithoutKyc_raw_dataInput, kyc_applicantsUncheckedCreateWithoutKyc_raw_dataInput>
  }

  export type kyc_applicantsUpsertWithoutKyc_raw_dataInput = {
    update: XOR<kyc_applicantsUpdateWithoutKyc_raw_dataInput, kyc_applicantsUncheckedUpdateWithoutKyc_raw_dataInput>
    create: XOR<kyc_applicantsCreateWithoutKyc_raw_dataInput, kyc_applicantsUncheckedCreateWithoutKyc_raw_dataInput>
    where?: kyc_applicantsWhereInput
  }

  export type kyc_applicantsUpdateToOneWithWhereWithoutKyc_raw_dataInput = {
    where?: kyc_applicantsWhereInput
    data: XOR<kyc_applicantsUpdateWithoutKyc_raw_dataInput, kyc_applicantsUncheckedUpdateWithoutKyc_raw_dataInput>
  }

  export type kyc_applicantsUpdateWithoutKyc_raw_dataInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    kyc_address_info?: kyc_address_infoUpdateManyWithoutKyc_applicantsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_applicantsNestedInput
    users?: usersUpdateOneWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_applicantsUncheckedUpdateWithoutKyc_raw_dataInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    personal_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    kyc_address_info?: kyc_address_infoUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUncheckedUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_complete_recordsCreateWithoutKyc_verification_eventsInput = {
    applicant_id: string
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesCreateNestedManyWithoutKyc_complete_recordsInput
    users?: usersCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsUncheckedCreateWithoutKyc_verification_eventsInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoUncheckedCreateNestedOneWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsCreateOrConnectWithoutKyc_verification_eventsInput = {
    where: kyc_complete_recordsWhereUniqueInput
    create: XOR<kyc_complete_recordsCreateWithoutKyc_verification_eventsInput, kyc_complete_recordsUncheckedCreateWithoutKyc_verification_eventsInput>
  }

  export type kyc_complete_recordsUpsertWithoutKyc_verification_eventsInput = {
    update: XOR<kyc_complete_recordsUpdateWithoutKyc_verification_eventsInput, kyc_complete_recordsUncheckedUpdateWithoutKyc_verification_eventsInput>
    create: XOR<kyc_complete_recordsCreateWithoutKyc_verification_eventsInput, kyc_complete_recordsUncheckedCreateWithoutKyc_verification_eventsInput>
    where?: kyc_complete_recordsWhereInput
  }

  export type kyc_complete_recordsUpdateToOneWithWhereWithoutKyc_verification_eventsInput = {
    where?: kyc_complete_recordsWhereInput
    data: XOR<kyc_complete_recordsUpdateWithoutKyc_verification_eventsInput, kyc_complete_recordsUncheckedUpdateWithoutKyc_verification_eventsInput>
  }

  export type kyc_complete_recordsUpdateWithoutKyc_verification_eventsInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUpdateManyWithoutKyc_complete_recordsNestedInput
    users?: usersUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_complete_recordsUncheckedUpdateWithoutKyc_verification_eventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUncheckedUpdateOneWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_applicantsCreateWithoutKyc_verification_historyInput = {
    applicant_id: string
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    kyc_address_info?: kyc_address_infoCreateNestedManyWithoutKyc_applicantsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_applicantsInput
    users?: usersCreateNestedOneWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsUncheckedCreateWithoutKyc_verification_historyInput = {
    id?: number
    applicant_id: string
    user_id?: number | null
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    personal_info_id?: number | null
    kyc_address_info?: kyc_address_infoUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataUncheckedCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsCreateOrConnectWithoutKyc_verification_historyInput = {
    where: kyc_applicantsWhereUniqueInput
    create: XOR<kyc_applicantsCreateWithoutKyc_verification_historyInput, kyc_applicantsUncheckedCreateWithoutKyc_verification_historyInput>
  }

  export type kyc_applicantsUpsertWithoutKyc_verification_historyInput = {
    update: XOR<kyc_applicantsUpdateWithoutKyc_verification_historyInput, kyc_applicantsUncheckedUpdateWithoutKyc_verification_historyInput>
    create: XOR<kyc_applicantsCreateWithoutKyc_verification_historyInput, kyc_applicantsUncheckedCreateWithoutKyc_verification_historyInput>
    where?: kyc_applicantsWhereInput
  }

  export type kyc_applicantsUpdateToOneWithWhereWithoutKyc_verification_historyInput = {
    where?: kyc_applicantsWhereInput
    data: XOR<kyc_applicantsUpdateWithoutKyc_verification_historyInput, kyc_applicantsUncheckedUpdateWithoutKyc_verification_historyInput>
  }

  export type kyc_applicantsUpdateWithoutKyc_verification_historyInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    kyc_address_info?: kyc_address_infoUpdateManyWithoutKyc_applicantsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_applicantsNestedInput
    users?: usersUpdateOneWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_applicantsUncheckedUpdateWithoutKyc_verification_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    personal_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    kyc_address_info?: kyc_address_infoUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUncheckedUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type usersCreateWithoutRefreshtokenInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRefreshtokenInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRefreshtokenInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRefreshtokenInput, usersUncheckedCreateWithoutRefreshtokenInput>
  }

  export type usersUpsertWithoutRefreshtokenInput = {
    update: XOR<usersUpdateWithoutRefreshtokenInput, usersUncheckedUpdateWithoutRefreshtokenInput>
    create: XOR<usersCreateWithoutRefreshtokenInput, usersUncheckedCreateWithoutRefreshtokenInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRefreshtokenInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRefreshtokenInput, usersUncheckedUpdateWithoutRefreshtokenInput>
  }

  export type usersUpdateWithoutRefreshtokenInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRefreshtokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type usersCreateWithoutUserroleInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    wallet?: walletCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUserroleInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    wallet?: walletUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUserroleInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserroleInput, usersUncheckedCreateWithoutUserroleInput>
  }

  export type usersUpsertWithoutUserroleInput = {
    update: XOR<usersUpdateWithoutUserroleInput, usersUncheckedUpdateWithoutUserroleInput>
    create: XOR<usersCreateWithoutUserroleInput, usersUncheckedCreateWithoutUserroleInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUserroleInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUserroleInput, usersUncheckedUpdateWithoutUserroleInput>
  }

  export type usersUpdateWithoutUserroleInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    wallet?: walletUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUserroleInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    wallet?: walletUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type adminCreateWithoutUsersInput = {
    department: string
    position: string
    last_login?: Date | string | null
  }

  export type adminUncheckedCreateWithoutUsersInput = {
    id?: number
    department: string
    position: string
    last_login?: Date | string | null
  }

  export type adminCreateOrConnectWithoutUsersInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutUsersInput, adminUncheckedCreateWithoutUsersInput>
  }

  export type authproviderCreateWithoutUsersInput = {
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type authproviderUncheckedCreateWithoutUsersInput = {
    id?: number
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type authproviderCreateOrConnectWithoutUsersInput = {
    where: authproviderWhereUniqueInput
    create: XOR<authproviderCreateWithoutUsersInput, authproviderUncheckedCreateWithoutUsersInput>
  }

  export type authproviderCreateManyUsersInputEnvelope = {
    data: authproviderCreateManyUsersInput | authproviderCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type didwalletCreateWithoutUsersInput = {
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletUncheckedCreateWithoutUsersInput = {
    id?: number
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletCreateOrConnectWithoutUsersInput = {
    where: didwalletWhereUniqueInput
    create: XOR<didwalletCreateWithoutUsersInput, didwalletUncheckedCreateWithoutUsersInput>
  }

  export type didwalletCreateManyUsersInputEnvelope = {
    data: didwalletCreateManyUsersInput | didwalletCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type investorCreateWithoutUsersInput = {
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorUncheckedCreateWithoutUsersInput = {
    id?: number
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorCreateOrConnectWithoutUsersInput = {
    where: investorWhereUniqueInput
    create: XOR<investorCreateWithoutUsersInput, investorUncheckedCreateWithoutUsersInput>
  }

  export type issuerCreateWithoutUsersInput = {
    id?: string
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_kyb_completed?: boolean
    mobile_number?: string | null
    platform_client_id?: string | null
    registration_date?: Date | string
    sumsub_applicant_id?: string | null
    sumsub_correlation_id?: string | null
    sumsub_external_id?: string | null
    sumsub_inspection_id?: string | null
    did?: string | null
    did_created_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    wallet?: walletCreateNestedOneWithoutIssuerInput
  }

  export type issuerUncheckedCreateWithoutUsersInput = {
    id?: string
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_kyb_completed?: boolean
    mobile_number?: string | null
    platform_client_id?: string | null
    registration_date?: Date | string
    sumsub_applicant_id?: string | null
    sumsub_correlation_id?: string | null
    sumsub_external_id?: string | null
    sumsub_inspection_id?: string | null
    did?: string | null
    did_created_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    wallet?: walletUncheckedCreateNestedOneWithoutIssuerInput
  }

  export type issuerCreateOrConnectWithoutUsersInput = {
    where: issuerWhereUniqueInput
    create: XOR<issuerCreateWithoutUsersInput, issuerUncheckedCreateWithoutUsersInput>
  }

  export type kyc_applicantsCreateWithoutUsersInput = {
    applicant_id: string
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    kyc_address_info?: kyc_address_infoCreateNestedManyWithoutKyc_applicantsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsUncheckedCreateWithoutUsersInput = {
    id?: number
    applicant_id: string
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    personal_info_id?: number | null
    kyc_address_info?: kyc_address_infoUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_audit_log?: kyc_audit_logUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_raw_data?: kyc_raw_dataUncheckedCreateNestedManyWithoutKyc_applicantsInput
    kyc_verification_history?: kyc_verification_historyUncheckedCreateNestedManyWithoutKyc_applicantsInput
  }

  export type kyc_applicantsCreateOrConnectWithoutUsersInput = {
    where: kyc_applicantsWhereUniqueInput
    create: XOR<kyc_applicantsCreateWithoutUsersInput, kyc_applicantsUncheckedCreateWithoutUsersInput>
  }

  export type kyc_applicantsCreateManyUsersInputEnvelope = {
    data: kyc_applicantsCreateManyUsersInput | kyc_applicantsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type kyc_complete_recordsCreateWithoutUsersInput = {
    applicant_id: string
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsUncheckedCreateWithoutUsersInput = {
    id?: number
    applicant_id: string
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
    kyc_addresses?: kyc_addressesUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
    kyc_personal_info?: kyc_personal_infoUncheckedCreateNestedOneWithoutKyc_complete_recordsInput
    kyc_verification_events?: kyc_verification_eventsUncheckedCreateNestedManyWithoutKyc_complete_recordsInput
  }

  export type kyc_complete_recordsCreateOrConnectWithoutUsersInput = {
    where: kyc_complete_recordsWhereUniqueInput
    create: XOR<kyc_complete_recordsCreateWithoutUsersInput, kyc_complete_recordsUncheckedCreateWithoutUsersInput>
  }

  export type kyc_complete_recordsCreateManyUsersInputEnvelope = {
    data: kyc_complete_recordsCreateManyUsersInput | kyc_complete_recordsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type KycDocumentCreateWithoutUsersInput = {
    applicant_id?: string | null
    country?: string | null
    created_at?: Date | string
    document_id?: string | null
    document_sub_type?: string | null
    document_type: string
    field_name?: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url?: string | null
    id_doc_type?: string | null
    issued_date?: Date | string | null
    number?: string | null
    page_type?: string | null
    status?: string
    updated_at: Date | string
    valid_until?: Date | string | null
    kyc_complete_records?: kyc_complete_recordsCreateNestedOneWithoutKyc_documentsInput
  }

  export type KycDocumentUncheckedCreateWithoutUsersInput = {
    id?: number
    applicant_id?: string | null
    country?: string | null
    created_at?: Date | string
    document_id?: string | null
    document_sub_type?: string | null
    document_type: string
    field_name?: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url?: string | null
    id_doc_type?: string | null
    issued_date?: Date | string | null
    number?: string | null
    page_type?: string | null
    record_id?: number | null
    status?: string
    updated_at: Date | string
    valid_until?: Date | string | null
  }

  export type KycDocumentCreateOrConnectWithoutUsersInput = {
    where: KycDocumentWhereUniqueInput
    create: XOR<KycDocumentCreateWithoutUsersInput, KycDocumentUncheckedCreateWithoutUsersInput>
  }

  export type KycDocumentCreateManyUsersInputEnvelope = {
    data: KycDocumentCreateManyUsersInput | KycDocumentCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type kycVerificationCreateWithoutUsersInput = {
    type: string
    applicant_id: string
    correlation_id?: string | null
    created_at?: Date | string
    error_message?: string | null
    event_timestamp: Date | string
    external_user_id?: string | null
    inspection_id?: string | null
    processing_status?: string | null
    raw_data: string
    review_result?: string | null
    review_status: string
    signature_valid: boolean
    updated_at: Date | string
    webhook_type: string
  }

  export type kycVerificationUncheckedCreateWithoutUsersInput = {
    id?: number
    type: string
    applicant_id: string
    correlation_id?: string | null
    created_at?: Date | string
    error_message?: string | null
    event_timestamp: Date | string
    external_user_id?: string | null
    inspection_id?: string | null
    processing_status?: string | null
    raw_data: string
    review_result?: string | null
    review_status: string
    signature_valid: boolean
    updated_at: Date | string
    webhook_type: string
  }

  export type kycVerificationCreateOrConnectWithoutUsersInput = {
    where: kycVerificationWhereUniqueInput
    create: XOR<kycVerificationCreateWithoutUsersInput, kycVerificationUncheckedCreateWithoutUsersInput>
  }

  export type kycVerificationCreateManyUsersInputEnvelope = {
    data: kycVerificationCreateManyUsersInput | kycVerificationCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type refreshtokenCreateWithoutUsersInput = {
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type refreshtokenUncheckedCreateWithoutUsersInput = {
    id?: number
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type refreshtokenCreateOrConnectWithoutUsersInput = {
    where: refreshtokenWhereUniqueInput
    create: XOR<refreshtokenCreateWithoutUsersInput, refreshtokenUncheckedCreateWithoutUsersInput>
  }

  export type refreshtokenCreateManyUsersInputEnvelope = {
    data: refreshtokenCreateManyUsersInput | refreshtokenCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type userroleCreateWithoutUsersInput = {
    role: string
    created_at?: Date | string
  }

  export type userroleUncheckedCreateWithoutUsersInput = {
    id?: number
    role: string
    created_at?: Date | string
  }

  export type userroleCreateOrConnectWithoutUsersInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput>
  }

  export type userroleCreateManyUsersInputEnvelope = {
    data: userroleCreateManyUsersInput | userroleCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type walletCreateWithoutUsersInput = {
    id?: string
    address: string
    chain?: string
    type?: string
    provider?: string
    did?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    issuer?: issuerCreateNestedOneWithoutWalletInput
  }

  export type walletUncheckedCreateWithoutUsersInput = {
    id?: string
    issuer_id?: string | null
    address: string
    chain?: string
    type?: string
    provider?: string
    did?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type walletCreateOrConnectWithoutUsersInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutUsersInput, walletUncheckedCreateWithoutUsersInput>
  }

  export type adminUpsertWithoutUsersInput = {
    update: XOR<adminUpdateWithoutUsersInput, adminUncheckedUpdateWithoutUsersInput>
    create: XOR<adminCreateWithoutUsersInput, adminUncheckedCreateWithoutUsersInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutUsersInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutUsersInput, adminUncheckedUpdateWithoutUsersInput>
  }

  export type adminUpdateWithoutUsersInput = {
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type authproviderUpsertWithWhereUniqueWithoutUsersInput = {
    where: authproviderWhereUniqueInput
    update: XOR<authproviderUpdateWithoutUsersInput, authproviderUncheckedUpdateWithoutUsersInput>
    create: XOR<authproviderCreateWithoutUsersInput, authproviderUncheckedCreateWithoutUsersInput>
  }

  export type authproviderUpdateWithWhereUniqueWithoutUsersInput = {
    where: authproviderWhereUniqueInput
    data: XOR<authproviderUpdateWithoutUsersInput, authproviderUncheckedUpdateWithoutUsersInput>
  }

  export type authproviderUpdateManyWithWhereWithoutUsersInput = {
    where: authproviderScalarWhereInput
    data: XOR<authproviderUpdateManyMutationInput, authproviderUncheckedUpdateManyWithoutUsersInput>
  }

  export type authproviderScalarWhereInput = {
    AND?: authproviderScalarWhereInput | authproviderScalarWhereInput[]
    OR?: authproviderScalarWhereInput[]
    NOT?: authproviderScalarWhereInput | authproviderScalarWhereInput[]
    id?: IntFilter<"authprovider"> | number
    user_id?: IntFilter<"authprovider"> | number
    provider_name?: StringFilter<"authprovider"> | string
    provider_user_id?: StringFilter<"authprovider"> | string
    provider_data?: JsonNullableFilter<"authprovider">
    created_at?: DateTimeFilter<"authprovider"> | Date | string
    last_used?: DateTimeFilter<"authprovider"> | Date | string
  }

  export type didwalletUpsertWithWhereUniqueWithoutUsersInput = {
    where: didwalletWhereUniqueInput
    update: XOR<didwalletUpdateWithoutUsersInput, didwalletUncheckedUpdateWithoutUsersInput>
    create: XOR<didwalletCreateWithoutUsersInput, didwalletUncheckedCreateWithoutUsersInput>
  }

  export type didwalletUpdateWithWhereUniqueWithoutUsersInput = {
    where: didwalletWhereUniqueInput
    data: XOR<didwalletUpdateWithoutUsersInput, didwalletUncheckedUpdateWithoutUsersInput>
  }

  export type didwalletUpdateManyWithWhereWithoutUsersInput = {
    where: didwalletScalarWhereInput
    data: XOR<didwalletUpdateManyMutationInput, didwalletUncheckedUpdateManyWithoutUsersInput>
  }

  export type didwalletScalarWhereInput = {
    AND?: didwalletScalarWhereInput | didwalletScalarWhereInput[]
    OR?: didwalletScalarWhereInput[]
    NOT?: didwalletScalarWhereInput | didwalletScalarWhereInput[]
    id?: IntFilter<"didwallet"> | number
    user_id?: IntFilter<"didwallet"> | number
    wallet_address?: StringFilter<"didwallet"> | string
    did?: StringFilter<"didwallet"> | string
    is_primary?: BoolFilter<"didwallet"> | boolean
    created_at?: DateTimeFilter<"didwallet"> | Date | string
    last_used?: DateTimeFilter<"didwallet"> | Date | string
  }

  export type investorUpsertWithoutUsersInput = {
    update: XOR<investorUpdateWithoutUsersInput, investorUncheckedUpdateWithoutUsersInput>
    create: XOR<investorCreateWithoutUsersInput, investorUncheckedCreateWithoutUsersInput>
    where?: investorWhereInput
  }

  export type investorUpdateToOneWithWhereWithoutUsersInput = {
    where?: investorWhereInput
    data: XOR<investorUpdateWithoutUsersInput, investorUncheckedUpdateWithoutUsersInput>
  }

  export type investorUpdateWithoutUsersInput = {
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type investorUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type issuerUpsertWithoutUsersInput = {
    update: XOR<issuerUpdateWithoutUsersInput, issuerUncheckedUpdateWithoutUsersInput>
    create: XOR<issuerCreateWithoutUsersInput, issuerUncheckedCreateWithoutUsersInput>
    where?: issuerWhereInput
  }

  export type issuerUpdateToOneWithWhereWithoutUsersInput = {
    where?: issuerWhereInput
    data: XOR<issuerUpdateWithoutUsersInput, issuerUncheckedUpdateWithoutUsersInput>
  }

  export type issuerUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_kyb_completed?: BoolFieldUpdateOperationsInput | boolean
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    platform_client_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sumsub_applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_external_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    did?: NullableStringFieldUpdateOperationsInput | string | null
    did_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: walletUpdateOneWithoutIssuerNestedInput
  }

  export type issuerUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_kyb_completed?: BoolFieldUpdateOperationsInput | boolean
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    platform_client_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sumsub_applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_external_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    did?: NullableStringFieldUpdateOperationsInput | string | null
    did_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: walletUncheckedUpdateOneWithoutIssuerNestedInput
  }

  export type kyc_applicantsUpsertWithWhereUniqueWithoutUsersInput = {
    where: kyc_applicantsWhereUniqueInput
    update: XOR<kyc_applicantsUpdateWithoutUsersInput, kyc_applicantsUncheckedUpdateWithoutUsersInput>
    create: XOR<kyc_applicantsCreateWithoutUsersInput, kyc_applicantsUncheckedCreateWithoutUsersInput>
  }

  export type kyc_applicantsUpdateWithWhereUniqueWithoutUsersInput = {
    where: kyc_applicantsWhereUniqueInput
    data: XOR<kyc_applicantsUpdateWithoutUsersInput, kyc_applicantsUncheckedUpdateWithoutUsersInput>
  }

  export type kyc_applicantsUpdateManyWithWhereWithoutUsersInput = {
    where: kyc_applicantsScalarWhereInput
    data: XOR<kyc_applicantsUpdateManyMutationInput, kyc_applicantsUncheckedUpdateManyWithoutUsersInput>
  }

  export type kyc_applicantsScalarWhereInput = {
    AND?: kyc_applicantsScalarWhereInput | kyc_applicantsScalarWhereInput[]
    OR?: kyc_applicantsScalarWhereInput[]
    NOT?: kyc_applicantsScalarWhereInput | kyc_applicantsScalarWhereInput[]
    id?: IntFilter<"kyc_applicants"> | number
    applicant_id?: StringFilter<"kyc_applicants"> | string
    user_id?: IntNullableFilter<"kyc_applicants"> | number | null
    external_user_id?: StringNullableFilter<"kyc_applicants"> | string | null
    inspection_id?: StringNullableFilter<"kyc_applicants"> | string | null
    correlation_id?: StringNullableFilter<"kyc_applicants"> | string | null
    status?: StringFilter<"kyc_applicants"> | string
    result?: StringNullableFilter<"kyc_applicants"> | string | null
    id_doc_status?: StringNullableFilter<"kyc_applicants"> | string | null
    created_at?: DateTimeFilter<"kyc_applicants"> | Date | string
    updated_at?: DateTimeFilter<"kyc_applicants"> | Date | string
    sandbox_mode?: BoolFilter<"kyc_applicants"> | boolean
    personal_info_id?: IntNullableFilter<"kyc_applicants"> | number | null
  }

  export type kyc_complete_recordsUpsertWithWhereUniqueWithoutUsersInput = {
    where: kyc_complete_recordsWhereUniqueInput
    update: XOR<kyc_complete_recordsUpdateWithoutUsersInput, kyc_complete_recordsUncheckedUpdateWithoutUsersInput>
    create: XOR<kyc_complete_recordsCreateWithoutUsersInput, kyc_complete_recordsUncheckedCreateWithoutUsersInput>
  }

  export type kyc_complete_recordsUpdateWithWhereUniqueWithoutUsersInput = {
    where: kyc_complete_recordsWhereUniqueInput
    data: XOR<kyc_complete_recordsUpdateWithoutUsersInput, kyc_complete_recordsUncheckedUpdateWithoutUsersInput>
  }

  export type kyc_complete_recordsUpdateManyWithWhereWithoutUsersInput = {
    where: kyc_complete_recordsScalarWhereInput
    data: XOR<kyc_complete_recordsUpdateManyMutationInput, kyc_complete_recordsUncheckedUpdateManyWithoutUsersInput>
  }

  export type kyc_complete_recordsScalarWhereInput = {
    AND?: kyc_complete_recordsScalarWhereInput | kyc_complete_recordsScalarWhereInput[]
    OR?: kyc_complete_recordsScalarWhereInput[]
    NOT?: kyc_complete_recordsScalarWhereInput | kyc_complete_recordsScalarWhereInput[]
    id?: IntFilter<"kyc_complete_records"> | number
    applicant_id?: StringFilter<"kyc_complete_records"> | string
    user_id?: IntNullableFilter<"kyc_complete_records"> | number | null
    status?: StringFilter<"kyc_complete_records"> | string
    result?: StringNullableFilter<"kyc_complete_records"> | string | null
    complete_data?: JsonNullableFilter<"kyc_complete_records">
    collected_at?: DateTimeFilter<"kyc_complete_records"> | Date | string
    updated_at?: DateTimeFilter<"kyc_complete_records"> | Date | string
    created_at?: DateTimeFilter<"kyc_complete_records"> | Date | string
  }

  export type KycDocumentUpsertWithWhereUniqueWithoutUsersInput = {
    where: KycDocumentWhereUniqueInput
    update: XOR<KycDocumentUpdateWithoutUsersInput, KycDocumentUncheckedUpdateWithoutUsersInput>
    create: XOR<KycDocumentCreateWithoutUsersInput, KycDocumentUncheckedCreateWithoutUsersInput>
  }

  export type KycDocumentUpdateWithWhereUniqueWithoutUsersInput = {
    where: KycDocumentWhereUniqueInput
    data: XOR<KycDocumentUpdateWithoutUsersInput, KycDocumentUncheckedUpdateWithoutUsersInput>
  }

  export type KycDocumentUpdateManyWithWhereWithoutUsersInput = {
    where: KycDocumentScalarWhereInput
    data: XOR<KycDocumentUpdateManyMutationInput, KycDocumentUncheckedUpdateManyWithoutUsersInput>
  }

  export type kycVerificationUpsertWithWhereUniqueWithoutUsersInput = {
    where: kycVerificationWhereUniqueInput
    update: XOR<kycVerificationUpdateWithoutUsersInput, kycVerificationUncheckedUpdateWithoutUsersInput>
    create: XOR<kycVerificationCreateWithoutUsersInput, kycVerificationUncheckedCreateWithoutUsersInput>
  }

  export type kycVerificationUpdateWithWhereUniqueWithoutUsersInput = {
    where: kycVerificationWhereUniqueInput
    data: XOR<kycVerificationUpdateWithoutUsersInput, kycVerificationUncheckedUpdateWithoutUsersInput>
  }

  export type kycVerificationUpdateManyWithWhereWithoutUsersInput = {
    where: kycVerificationScalarWhereInput
    data: XOR<kycVerificationUpdateManyMutationInput, kycVerificationUncheckedUpdateManyWithoutUsersInput>
  }

  export type kycVerificationScalarWhereInput = {
    AND?: kycVerificationScalarWhereInput | kycVerificationScalarWhereInput[]
    OR?: kycVerificationScalarWhereInput[]
    NOT?: kycVerificationScalarWhereInput | kycVerificationScalarWhereInput[]
    id?: IntFilter<"kycVerification"> | number
    type?: StringFilter<"kycVerification"> | string
    applicant_id?: StringFilter<"kycVerification"> | string
    correlation_id?: StringNullableFilter<"kycVerification"> | string | null
    created_at?: DateTimeFilter<"kycVerification"> | Date | string
    error_message?: StringNullableFilter<"kycVerification"> | string | null
    event_timestamp?: DateTimeFilter<"kycVerification"> | Date | string
    external_user_id?: StringNullableFilter<"kycVerification"> | string | null
    inspection_id?: StringNullableFilter<"kycVerification"> | string | null
    processing_status?: StringNullableFilter<"kycVerification"> | string | null
    raw_data?: StringFilter<"kycVerification"> | string
    review_result?: StringNullableFilter<"kycVerification"> | string | null
    review_status?: StringFilter<"kycVerification"> | string
    signature_valid?: BoolFilter<"kycVerification"> | boolean
    updated_at?: DateTimeFilter<"kycVerification"> | Date | string
    user_id?: IntNullableFilter<"kycVerification"> | number | null
    webhook_type?: StringFilter<"kycVerification"> | string
  }

  export type refreshtokenUpsertWithWhereUniqueWithoutUsersInput = {
    where: refreshtokenWhereUniqueInput
    update: XOR<refreshtokenUpdateWithoutUsersInput, refreshtokenUncheckedUpdateWithoutUsersInput>
    create: XOR<refreshtokenCreateWithoutUsersInput, refreshtokenUncheckedCreateWithoutUsersInput>
  }

  export type refreshtokenUpdateWithWhereUniqueWithoutUsersInput = {
    where: refreshtokenWhereUniqueInput
    data: XOR<refreshtokenUpdateWithoutUsersInput, refreshtokenUncheckedUpdateWithoutUsersInput>
  }

  export type refreshtokenUpdateManyWithWhereWithoutUsersInput = {
    where: refreshtokenScalarWhereInput
    data: XOR<refreshtokenUpdateManyMutationInput, refreshtokenUncheckedUpdateManyWithoutUsersInput>
  }

  export type refreshtokenScalarWhereInput = {
    AND?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
    OR?: refreshtokenScalarWhereInput[]
    NOT?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
    id?: IntFilter<"refreshtoken"> | number
    user_id?: IntFilter<"refreshtoken"> | number
    token?: StringFilter<"refreshtoken"> | string
    expires_at?: DateTimeFilter<"refreshtoken"> | Date | string
    created_at?: DateTimeFilter<"refreshtoken"> | Date | string
    device_info?: StringNullableFilter<"refreshtoken"> | string | null
  }

  export type userroleUpsertWithWhereUniqueWithoutUsersInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutUsersInput, userroleUncheckedUpdateWithoutUsersInput>
    create: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutUsersInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutUsersInput, userroleUncheckedUpdateWithoutUsersInput>
  }

  export type userroleUpdateManyWithWhereWithoutUsersInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutUsersInput>
  }

  export type userroleScalarWhereInput = {
    AND?: userroleScalarWhereInput | userroleScalarWhereInput[]
    OR?: userroleScalarWhereInput[]
    NOT?: userroleScalarWhereInput | userroleScalarWhereInput[]
    id?: IntFilter<"userrole"> | number
    user_id?: IntFilter<"userrole"> | number
    role?: StringFilter<"userrole"> | string
    created_at?: DateTimeFilter<"userrole"> | Date | string
  }

  export type walletUpsertWithoutUsersInput = {
    update: XOR<walletUpdateWithoutUsersInput, walletUncheckedUpdateWithoutUsersInput>
    create: XOR<walletCreateWithoutUsersInput, walletUncheckedCreateWithoutUsersInput>
    where?: walletWhereInput
  }

  export type walletUpdateToOneWithWhereWithoutUsersInput = {
    where?: walletWhereInput
    data: XOR<walletUpdateWithoutUsersInput, walletUncheckedUpdateWithoutUsersInput>
  }

  export type walletUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    did?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    issuer?: issuerUpdateOneWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    issuer_id?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    did?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateWithoutWalletInput = {
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminCreateNestedOneWithoutUsersInput
    authprovider?: authproviderCreateNestedManyWithoutUsersInput
    didwallet?: didwalletCreateNestedManyWithoutUsersInput
    investor?: investorCreateNestedOneWithoutUsersInput
    issuer?: issuerCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutWalletInput = {
    id?: number
    email: string
    password: string
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    applicant_id?: string | null
    is_verified?: boolean
    verification_result?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUsersInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUsersInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUsersInput
    investor?: investorUncheckedCreateNestedOneWithoutUsersInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUsersInput
    kyc_applicants?: kyc_applicantsUncheckedCreateNestedManyWithoutUsersInput
    kyc_complete_records?: kyc_complete_recordsUncheckedCreateNestedManyWithoutUsersInput
    kyc_documents?: KycDocumentUncheckedCreateNestedManyWithoutUsersInput
    kyc_verifications?: kycVerificationUncheckedCreateNestedManyWithoutUsersInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutWalletInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
  }

  export type issuerCreateWithoutWalletInput = {
    id?: string
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_kyb_completed?: boolean
    mobile_number?: string | null
    platform_client_id?: string | null
    registration_date?: Date | string
    sumsub_applicant_id?: string | null
    sumsub_correlation_id?: string | null
    sumsub_external_id?: string | null
    sumsub_inspection_id?: string | null
    did?: string | null
    did_created_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutIssuerInput
  }

  export type issuerUncheckedCreateWithoutWalletInput = {
    id?: string
    user_id: number
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: boolean
    is_kyb_completed?: boolean
    mobile_number?: string | null
    platform_client_id?: string | null
    registration_date?: Date | string
    sumsub_applicant_id?: string | null
    sumsub_correlation_id?: string | null
    sumsub_external_id?: string | null
    sumsub_inspection_id?: string | null
    did?: string | null
    did_created_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type issuerCreateOrConnectWithoutWalletInput = {
    where: issuerWhereUniqueInput
    create: XOR<issuerCreateWithoutWalletInput, issuerUncheckedCreateWithoutWalletInput>
  }

  export type usersUpsertWithoutWalletInput = {
    update: XOR<usersUpdateWithoutWalletInput, usersUncheckedUpdateWithoutWalletInput>
    create: XOR<usersCreateWithoutWalletInput, usersUncheckedCreateWithoutWalletInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWalletInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWalletInput, usersUncheckedUpdateWithoutWalletInput>
  }

  export type usersUpdateWithoutWalletInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUpdateManyWithoutUsersNestedInput
    investor?: investorUpdateOneWithoutUsersNestedInput
    issuer?: issuerUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutWalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_result?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUsersNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUsersNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUsersNestedInput
    investor?: investorUncheckedUpdateOneWithoutUsersNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUsersNestedInput
    kyc_applicants?: kyc_applicantsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_complete_records?: kyc_complete_recordsUncheckedUpdateManyWithoutUsersNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutUsersNestedInput
    kyc_verifications?: kycVerificationUncheckedUpdateManyWithoutUsersNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type issuerUpsertWithoutWalletInput = {
    update: XOR<issuerUpdateWithoutWalletInput, issuerUncheckedUpdateWithoutWalletInput>
    create: XOR<issuerCreateWithoutWalletInput, issuerUncheckedCreateWithoutWalletInput>
    where?: issuerWhereInput
  }

  export type issuerUpdateToOneWithWhereWithoutWalletInput = {
    where?: issuerWhereInput
    data: XOR<issuerUpdateWithoutWalletInput, issuerUncheckedUpdateWithoutWalletInput>
  }

  export type issuerUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_kyb_completed?: BoolFieldUpdateOperationsInput | boolean
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    platform_client_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sumsub_applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_external_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    did?: NullableStringFieldUpdateOperationsInput | string | null
    did_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutIssuerNestedInput
  }

  export type issuerUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    is_active?: BoolFieldUpdateOperationsInput | boolean
    is_kyb_completed?: BoolFieldUpdateOperationsInput | boolean
    mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    platform_client_id?: NullableStringFieldUpdateOperationsInput | string | null
    registration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sumsub_applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_external_id?: NullableStringFieldUpdateOperationsInput | string | null
    sumsub_inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    did?: NullableStringFieldUpdateOperationsInput | string | null
    did_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_address_infoCreateManyKyc_applicantsInput = {
    id?: number
    address_type: string
    is_primary?: boolean
    street?: string | null
    street_line2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    verification_method?: string | null
    created_at?: Date | string
    updated_at: Date | string
  }

  export type kyc_audit_logCreateManyKyc_applicantsInput = {
    id?: number
    action: string
    performed_by?: string | null
    details?: string | null
    timestamp?: Date | string
  }

  export type kyc_raw_dataCreateManyKyc_applicantsInput = {
    id?: number
    data_type: string
    source: string
    raw_data: string
    created_at?: Date | string
  }

  export type kyc_verification_historyCreateManyKyc_applicantsInput = {
    id?: number
    type: string
    review_status: string
    review_result?: string | null
    review_answer?: string | null
    reject_type?: string | null
    reject_labels?: string | null
    timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_address_infoUpdateWithoutKyc_applicantsInput = {
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_method?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_address_infoUncheckedUpdateWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_method?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_address_infoUncheckedUpdateManyWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    verification_method?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_audit_logUpdateWithoutKyc_applicantsInput = {
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_audit_logUncheckedUpdateWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_audit_logUncheckedUpdateManyWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    performed_by?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_raw_dataUpdateWithoutKyc_applicantsInput = {
    data_type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    raw_data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_raw_dataUncheckedUpdateWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    data_type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    raw_data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_raw_dataUncheckedUpdateManyWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    data_type?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    raw_data?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_historyUpdateWithoutKyc_applicantsInput = {
    type?: StringFieldUpdateOperationsInput | string
    review_status?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_answer?: NullableStringFieldUpdateOperationsInput | string | null
    reject_type?: NullableStringFieldUpdateOperationsInput | string | null
    reject_labels?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_historyUncheckedUpdateWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    review_status?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_answer?: NullableStringFieldUpdateOperationsInput | string | null
    reject_type?: NullableStringFieldUpdateOperationsInput | string | null
    reject_labels?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_historyUncheckedUpdateManyWithoutKyc_applicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    review_status?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_answer?: NullableStringFieldUpdateOperationsInput | string | null
    reject_type?: NullableStringFieldUpdateOperationsInput | string | null
    reject_labels?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_addressesCreateManyKyc_complete_recordsInput = {
    id?: number
    address_type?: string
    is_primary?: boolean
    street?: string | null
    street_line_2?: string | null
    city?: string | null
    state?: string | null
    postal_code?: string | null
    country?: string | null
    is_verified?: boolean
    updated_at: Date | string
    created_at?: Date | string
  }

  export type KycDocumentCreateManyKyc_complete_recordsInput = {
    id?: number
    applicant_id?: string | null
    country?: string | null
    created_at?: Date | string
    document_id?: string | null
    document_sub_type?: string | null
    document_type: string
    field_name?: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url?: string | null
    id_doc_type?: string | null
    issued_date?: Date | string | null
    number?: string | null
    page_type?: string | null
    status?: string
    updated_at: Date | string
    user_id?: number | null
    valid_until?: Date | string | null
  }

  export type kyc_verification_eventsCreateManyKyc_complete_recordsInput = {
    id?: number
    type?: string
    review_status?: string | null
    review_result?: string | null
    inspection_id?: string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp: Date | string
    created_at?: Date | string
  }

  export type kyc_addressesUpdateWithoutKyc_complete_recordsInput = {
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_addressesUncheckedUpdateWithoutKyc_complete_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_addressesUncheckedUpdateManyWithoutKyc_complete_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    address_type?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    street?: NullableStringFieldUpdateOperationsInput | string | null
    street_line_2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postal_code?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycDocumentUpdateWithoutKyc_complete_recordsInput = {
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutKyc_documentsNestedInput
  }

  export type KycDocumentUncheckedUpdateWithoutKyc_complete_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KycDocumentUncheckedUpdateManyWithoutKyc_complete_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type kyc_verification_eventsUpdateWithoutKyc_complete_recordsInput = {
    type?: StringFieldUpdateOperationsInput | string
    review_status?: NullableStringFieldUpdateOperationsInput | string | null
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_eventsUncheckedUpdateWithoutKyc_complete_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    review_status?: NullableStringFieldUpdateOperationsInput | string | null
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_verification_eventsUncheckedUpdateManyWithoutKyc_complete_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    review_status?: NullableStringFieldUpdateOperationsInput | string | null
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    event_data?: NullableJsonNullValueInput | InputJsonValue
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authproviderCreateManyUsersInput = {
    id?: number
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletCreateManyUsersInput = {
    id?: number
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type kyc_applicantsCreateManyUsersInput = {
    id?: number
    applicant_id: string
    external_user_id?: string | null
    inspection_id?: string | null
    correlation_id?: string | null
    status?: string
    result?: string | null
    id_doc_status?: string | null
    created_at?: Date | string
    updated_at: Date | string
    sandbox_mode?: boolean
    personal_info_id?: number | null
  }

  export type kyc_complete_recordsCreateManyUsersInput = {
    id?: number
    applicant_id: string
    status?: string
    result?: string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: Date | string
    updated_at: Date | string
    created_at?: Date | string
  }

  export type KycDocumentCreateManyUsersInput = {
    id?: number
    applicant_id?: string | null
    country?: string | null
    created_at?: Date | string
    document_id?: string | null
    document_sub_type?: string | null
    document_type: string
    field_name?: string | null
    file_name: string
    file_path: string
    file_type: string
    file_url?: string | null
    id_doc_type?: string | null
    issued_date?: Date | string | null
    number?: string | null
    page_type?: string | null
    record_id?: number | null
    status?: string
    updated_at: Date | string
    valid_until?: Date | string | null
  }

  export type kycVerificationCreateManyUsersInput = {
    id?: number
    type: string
    applicant_id: string
    correlation_id?: string | null
    created_at?: Date | string
    error_message?: string | null
    event_timestamp: Date | string
    external_user_id?: string | null
    inspection_id?: string | null
    processing_status?: string | null
    raw_data: string
    review_result?: string | null
    review_status: string
    signature_valid: boolean
    updated_at: Date | string
    webhook_type: string
  }

  export type refreshtokenCreateManyUsersInput = {
    id?: number
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type userroleCreateManyUsersInput = {
    id?: number
    role: string
    created_at?: Date | string
  }

  export type authproviderUpdateWithoutUsersInput = {
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authproviderUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authproviderUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletUpdateWithoutUsersInput = {
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type kyc_applicantsUpdateWithoutUsersInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    kyc_address_info?: kyc_address_infoUpdateManyWithoutKyc_applicantsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_applicantsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    personal_info_id?: NullableIntFieldUpdateOperationsInput | number | null
    kyc_address_info?: kyc_address_infoUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_audit_log?: kyc_audit_logUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_raw_data?: kyc_raw_dataUncheckedUpdateManyWithoutKyc_applicantsNestedInput
    kyc_verification_history?: kyc_verification_historyUncheckedUpdateManyWithoutKyc_applicantsNestedInput
  }

  export type kyc_applicantsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sandbox_mode?: BoolFieldUpdateOperationsInput | boolean
    personal_info_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type kyc_complete_recordsUpdateWithoutUsersInput = {
    applicant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_documents?: KycDocumentUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_complete_recordsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc_addresses?: kyc_addressesUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_documents?: KycDocumentUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
    kyc_personal_info?: kyc_personal_infoUncheckedUpdateOneWithoutKyc_complete_recordsNestedInput
    kyc_verification_events?: kyc_verification_eventsUncheckedUpdateManyWithoutKyc_complete_recordsNestedInput
  }

  export type kyc_complete_recordsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    complete_data?: NullableJsonNullValueInput | InputJsonValue
    collected_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KycDocumentUpdateWithoutUsersInput = {
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_complete_records?: kyc_complete_recordsUpdateOneWithoutKyc_documentsNestedInput
  }

  export type KycDocumentUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KycDocumentUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    applicant_id?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    document_id?: NullableStringFieldUpdateOperationsInput | string | null
    document_sub_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_type?: StringFieldUpdateOperationsInput | string
    field_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: StringFieldUpdateOperationsInput | string
    file_path?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    file_url?: NullableStringFieldUpdateOperationsInput | string | null
    id_doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    number?: NullableStringFieldUpdateOperationsInput | string | null
    page_type?: NullableStringFieldUpdateOperationsInput | string | null
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    valid_until?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type kycVerificationUpdateWithoutUsersInput = {
    type?: StringFieldUpdateOperationsInput | string
    applicant_id?: StringFieldUpdateOperationsInput | string
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    processing_status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_data?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_status?: StringFieldUpdateOperationsInput | string
    signature_valid?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_type?: StringFieldUpdateOperationsInput | string
  }

  export type kycVerificationUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    applicant_id?: StringFieldUpdateOperationsInput | string
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    processing_status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_data?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_status?: StringFieldUpdateOperationsInput | string
    signature_valid?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_type?: StringFieldUpdateOperationsInput | string
  }

  export type kycVerificationUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    applicant_id?: StringFieldUpdateOperationsInput | string
    correlation_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    error_message?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    external_user_id?: NullableStringFieldUpdateOperationsInput | string | null
    inspection_id?: NullableStringFieldUpdateOperationsInput | string | null
    processing_status?: NullableStringFieldUpdateOperationsInput | string | null
    raw_data?: StringFieldUpdateOperationsInput | string
    review_result?: NullableStringFieldUpdateOperationsInput | string | null
    review_status?: StringFieldUpdateOperationsInput | string
    signature_valid?: BoolFieldUpdateOperationsInput | boolean
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    webhook_type?: StringFieldUpdateOperationsInput | string
  }

  export type refreshtokenUpdateWithoutUsersInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refreshtokenUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refreshtokenUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userroleUpdateWithoutUsersInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroleUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Kyc_applicantsCountOutputTypeDefaultArgs instead
     */
    export type Kyc_applicantsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Kyc_applicantsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Kyc_complete_recordsCountOutputTypeDefaultArgs instead
     */
    export type Kyc_complete_recordsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Kyc_complete_recordsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kycVerificationDefaultArgs instead
     */
    export type kycVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kycVerificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KycDocumentDefaultArgs instead
     */
    export type KycDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KycDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use adminDefaultArgs instead
     */
    export type adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = adminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use authproviderDefaultArgs instead
     */
    export type authproviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = authproviderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use didwalletDefaultArgs instead
     */
    export type didwalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = didwalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use investorDefaultArgs instead
     */
    export type investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = investorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use issuerDefaultArgs instead
     */
    export type issuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = issuerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kyc_address_infoDefaultArgs instead
     */
    export type kyc_address_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kyc_address_infoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kyc_addressesDefaultArgs instead
     */
    export type kyc_addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kyc_addressesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kyc_applicantsDefaultArgs instead
     */
    export type kyc_applicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kyc_applicantsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kyc_audit_logDefaultArgs instead
     */
    export type kyc_audit_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kyc_audit_logDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kyc_complete_recordsDefaultArgs instead
     */
    export type kyc_complete_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kyc_complete_recordsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kyc_personal_infoDefaultArgs instead
     */
    export type kyc_personal_infoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kyc_personal_infoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kyc_raw_dataDefaultArgs instead
     */
    export type kyc_raw_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kyc_raw_dataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kyc_verification_eventsDefaultArgs instead
     */
    export type kyc_verification_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kyc_verification_eventsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use kyc_verification_historyDefaultArgs instead
     */
    export type kyc_verification_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = kyc_verification_historyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use refreshtokenDefaultArgs instead
     */
    export type refreshtokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = refreshtokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userroleDefaultArgs instead
     */
    export type userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userroleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use walletDefaultArgs instead
     */
    export type walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = walletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use webhookLogDefaultArgs instead
     */
    export type webhookLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = webhookLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}