
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model authprovider
 * 
 */
export type authprovider = $Result.DefaultSelection<Prisma.$authproviderPayload>
/**
 * Model didwallet
 * 
 */
export type didwallet = $Result.DefaultSelection<Prisma.$didwalletPayload>
/**
 * Model investor
 * 
 */
export type investor = $Result.DefaultSelection<Prisma.$investorPayload>
/**
 * Model issuer
 * 
 */
export type issuer = $Result.DefaultSelection<Prisma.$issuerPayload>
/**
 * Model offering
 * 
 */
export type offering = $Result.DefaultSelection<Prisma.$offeringPayload>
/**
 * Model refreshtoken
 * 
 */
export type refreshtoken = $Result.DefaultSelection<Prisma.$refreshtokenPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model userrole
 * 
 */
export type userrole = $Result.DefaultSelection<Prisma.$userrolePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs>;

  /**
   * `prisma.authprovider`: Exposes CRUD operations for the **authprovider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authproviders
    * const authproviders = await prisma.authprovider.findMany()
    * ```
    */
  get authprovider(): Prisma.authproviderDelegate<ExtArgs>;

  /**
   * `prisma.didwallet`: Exposes CRUD operations for the **didwallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Didwallets
    * const didwallets = await prisma.didwallet.findMany()
    * ```
    */
  get didwallet(): Prisma.didwalletDelegate<ExtArgs>;

  /**
   * `prisma.investor`: Exposes CRUD operations for the **investor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Investors
    * const investors = await prisma.investor.findMany()
    * ```
    */
  get investor(): Prisma.investorDelegate<ExtArgs>;

  /**
   * `prisma.issuer`: Exposes CRUD operations for the **issuer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issuers
    * const issuers = await prisma.issuer.findMany()
    * ```
    */
  get issuer(): Prisma.issuerDelegate<ExtArgs>;

  /**
   * `prisma.offering`: Exposes CRUD operations for the **offering** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offerings
    * const offerings = await prisma.offering.findMany()
    * ```
    */
  get offering(): Prisma.offeringDelegate<ExtArgs>;

  /**
   * `prisma.refreshtoken`: Exposes CRUD operations for the **refreshtoken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refreshtokens
    * const refreshtokens = await prisma.refreshtoken.findMany()
    * ```
    */
  get refreshtoken(): Prisma.refreshtokenDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.userrole`: Exposes CRUD operations for the **userrole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userroles
    * const userroles = await prisma.userrole.findMany()
    * ```
    */
  get userrole(): Prisma.userroleDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    admin: 'admin',
    authprovider: 'authprovider',
    didwallet: 'didwallet',
    investor: 'investor',
    issuer: 'issuer',
    offering: 'offering',
    refreshtoken: 'refreshtoken',
    user: 'user',
    userrole: 'userrole'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "admin" | "authprovider" | "didwallet" | "investor" | "issuer" | "offering" | "refreshtoken" | "user" | "userrole"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      authprovider: {
        payload: Prisma.$authproviderPayload<ExtArgs>
        fields: Prisma.authproviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.authproviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.authproviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          findFirst: {
            args: Prisma.authproviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.authproviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          findMany: {
            args: Prisma.authproviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>[]
          }
          create: {
            args: Prisma.authproviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          createMany: {
            args: Prisma.authproviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.authproviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          update: {
            args: Prisma.authproviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          deleteMany: {
            args: Prisma.authproviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.authproviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.authproviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authproviderPayload>
          }
          aggregate: {
            args: Prisma.AuthproviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthprovider>
          }
          groupBy: {
            args: Prisma.authproviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthproviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.authproviderCountArgs<ExtArgs>
            result: $Utils.Optional<AuthproviderCountAggregateOutputType> | number
          }
        }
      }
      didwallet: {
        payload: Prisma.$didwalletPayload<ExtArgs>
        fields: Prisma.didwalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.didwalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.didwalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          findFirst: {
            args: Prisma.didwalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.didwalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          findMany: {
            args: Prisma.didwalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>[]
          }
          create: {
            args: Prisma.didwalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          createMany: {
            args: Prisma.didwalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.didwalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          update: {
            args: Prisma.didwalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          deleteMany: {
            args: Prisma.didwalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.didwalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.didwalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$didwalletPayload>
          }
          aggregate: {
            args: Prisma.DidwalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDidwallet>
          }
          groupBy: {
            args: Prisma.didwalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<DidwalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.didwalletCountArgs<ExtArgs>
            result: $Utils.Optional<DidwalletCountAggregateOutputType> | number
          }
        }
      }
      investor: {
        payload: Prisma.$investorPayload<ExtArgs>
        fields: Prisma.investorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.investorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.investorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          findFirst: {
            args: Prisma.investorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.investorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          findMany: {
            args: Prisma.investorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>[]
          }
          create: {
            args: Prisma.investorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          createMany: {
            args: Prisma.investorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.investorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          update: {
            args: Prisma.investorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          deleteMany: {
            args: Prisma.investorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.investorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.investorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$investorPayload>
          }
          aggregate: {
            args: Prisma.InvestorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestor>
          }
          groupBy: {
            args: Prisma.investorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestorGroupByOutputType>[]
          }
          count: {
            args: Prisma.investorCountArgs<ExtArgs>
            result: $Utils.Optional<InvestorCountAggregateOutputType> | number
          }
        }
      }
      issuer: {
        payload: Prisma.$issuerPayload<ExtArgs>
        fields: Prisma.issuerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.issuerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.issuerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          findFirst: {
            args: Prisma.issuerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.issuerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          findMany: {
            args: Prisma.issuerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>[]
          }
          create: {
            args: Prisma.issuerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          createMany: {
            args: Prisma.issuerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.issuerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          update: {
            args: Prisma.issuerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          deleteMany: {
            args: Prisma.issuerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.issuerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.issuerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$issuerPayload>
          }
          aggregate: {
            args: Prisma.IssuerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIssuer>
          }
          groupBy: {
            args: Prisma.issuerGroupByArgs<ExtArgs>
            result: $Utils.Optional<IssuerGroupByOutputType>[]
          }
          count: {
            args: Prisma.issuerCountArgs<ExtArgs>
            result: $Utils.Optional<IssuerCountAggregateOutputType> | number
          }
        }
      }
      offering: {
        payload: Prisma.$offeringPayload<ExtArgs>
        fields: Prisma.offeringFieldRefs
        operations: {
          findUnique: {
            args: Prisma.offeringFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offeringPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.offeringFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offeringPayload>
          }
          findFirst: {
            args: Prisma.offeringFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offeringPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.offeringFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offeringPayload>
          }
          findMany: {
            args: Prisma.offeringFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offeringPayload>[]
          }
          create: {
            args: Prisma.offeringCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offeringPayload>
          }
          createMany: {
            args: Prisma.offeringCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.offeringDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offeringPayload>
          }
          update: {
            args: Prisma.offeringUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offeringPayload>
          }
          deleteMany: {
            args: Prisma.offeringDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.offeringUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.offeringUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offeringPayload>
          }
          aggregate: {
            args: Prisma.OfferingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffering>
          }
          groupBy: {
            args: Prisma.offeringGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferingGroupByOutputType>[]
          }
          count: {
            args: Prisma.offeringCountArgs<ExtArgs>
            result: $Utils.Optional<OfferingCountAggregateOutputType> | number
          }
        }
      }
      refreshtoken: {
        payload: Prisma.$refreshtokenPayload<ExtArgs>
        fields: Prisma.refreshtokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.refreshtokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.refreshtokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          findFirst: {
            args: Prisma.refreshtokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.refreshtokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          findMany: {
            args: Prisma.refreshtokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>[]
          }
          create: {
            args: Prisma.refreshtokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          createMany: {
            args: Prisma.refreshtokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.refreshtokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          update: {
            args: Prisma.refreshtokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          deleteMany: {
            args: Prisma.refreshtokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.refreshtokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.refreshtokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$refreshtokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshtokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshtoken>
          }
          groupBy: {
            args: Prisma.refreshtokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshtokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.refreshtokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshtokenCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      userrole: {
        payload: Prisma.$userrolePayload<ExtArgs>
        fields: Prisma.userroleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userroleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userroleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findFirst: {
            args: Prisma.userroleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userroleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findMany: {
            args: Prisma.userroleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          create: {
            args: Prisma.userroleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          createMany: {
            args: Prisma.userroleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userroleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          update: {
            args: Prisma.userroleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          deleteMany: {
            args: Prisma.userroleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userroleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userroleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          aggregate: {
            args: Prisma.UserroleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserrole>
          }
          groupBy: {
            args: Prisma.userroleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserroleGroupByOutputType>[]
          }
          count: {
            args: Prisma.userroleCountArgs<ExtArgs>
            result: $Utils.Optional<UserroleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type IssuerCountOutputType
   */

  export type IssuerCountOutputType = {
    offering: number
  }

  export type IssuerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offering?: boolean | IssuerCountOutputTypeCountOfferingArgs
  }

  // Custom InputTypes
  /**
   * IssuerCountOutputType without action
   */
  export type IssuerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssuerCountOutputType
     */
    select?: IssuerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IssuerCountOutputType without action
   */
  export type IssuerCountOutputTypeCountOfferingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offeringWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    authprovider: number
    didwallet: number
    refreshtoken: number
    userrole: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authprovider?: boolean | UserCountOutputTypeCountAuthproviderArgs
    didwallet?: boolean | UserCountOutputTypeCountDidwalletArgs
    refreshtoken?: boolean | UserCountOutputTypeCountRefreshtokenArgs
    userrole?: boolean | UserCountOutputTypeCountUserroleArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthproviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authproviderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDidwalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: didwalletWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshtokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refreshtokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    department: string | null
    position: string | null
    last_login: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    department: string | null
    position: string | null
    last_login: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    user_id: number
    department: number
    position: number
    last_login: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    user_id?: true
    department?: true
    position?: true
    last_login?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    user_id?: true
    department?: true
    position?: true
    last_login?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    user_id?: true
    department?: true
    position?: true
    last_login?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    user_id: number
    department: string
    position: string
    last_login: Date | null
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    department?: boolean
    position?: boolean
    last_login?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>


  export type adminSelectScalar = {
    id?: boolean
    user_id?: boolean
    department?: boolean
    position?: boolean
    last_login?: boolean
  }

  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      department: string
      position: string
      last_login: Date | null
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */ 
  interface adminFieldRefs {
    readonly id: FieldRef<"admin", 'Int'>
    readonly user_id: FieldRef<"admin", 'Int'>
    readonly department: FieldRef<"admin", 'String'>
    readonly position: FieldRef<"admin", 'String'>
    readonly last_login: FieldRef<"admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
  }


  /**
   * Model authprovider
   */

  export type AggregateAuthprovider = {
    _count: AuthproviderCountAggregateOutputType | null
    _avg: AuthproviderAvgAggregateOutputType | null
    _sum: AuthproviderSumAggregateOutputType | null
    _min: AuthproviderMinAggregateOutputType | null
    _max: AuthproviderMaxAggregateOutputType | null
  }

  export type AuthproviderAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AuthproviderSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AuthproviderMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    provider_name: string | null
    provider_user_id: string | null
    created_at: Date | null
    last_used: Date | null
  }

  export type AuthproviderMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    provider_name: string | null
    provider_user_id: string | null
    created_at: Date | null
    last_used: Date | null
  }

  export type AuthproviderCountAggregateOutputType = {
    id: number
    user_id: number
    provider_name: number
    provider_user_id: number
    provider_data: number
    created_at: number
    last_used: number
    _all: number
  }


  export type AuthproviderAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AuthproviderSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AuthproviderMinAggregateInputType = {
    id?: true
    user_id?: true
    provider_name?: true
    provider_user_id?: true
    created_at?: true
    last_used?: true
  }

  export type AuthproviderMaxAggregateInputType = {
    id?: true
    user_id?: true
    provider_name?: true
    provider_user_id?: true
    created_at?: true
    last_used?: true
  }

  export type AuthproviderCountAggregateInputType = {
    id?: true
    user_id?: true
    provider_name?: true
    provider_user_id?: true
    provider_data?: true
    created_at?: true
    last_used?: true
    _all?: true
  }

  export type AuthproviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authprovider to aggregate.
     */
    where?: authproviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authproviders to fetch.
     */
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: authproviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authproviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned authproviders
    **/
    _count?: true | AuthproviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthproviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthproviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthproviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthproviderMaxAggregateInputType
  }

  export type GetAuthproviderAggregateType<T extends AuthproviderAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthprovider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthprovider[P]>
      : GetScalarType<T[P], AggregateAuthprovider[P]>
  }




  export type authproviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authproviderWhereInput
    orderBy?: authproviderOrderByWithAggregationInput | authproviderOrderByWithAggregationInput[]
    by: AuthproviderScalarFieldEnum[] | AuthproviderScalarFieldEnum
    having?: authproviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthproviderCountAggregateInputType | true
    _avg?: AuthproviderAvgAggregateInputType
    _sum?: AuthproviderSumAggregateInputType
    _min?: AuthproviderMinAggregateInputType
    _max?: AuthproviderMaxAggregateInputType
  }

  export type AuthproviderGroupByOutputType = {
    id: number
    user_id: number
    provider_name: string
    provider_user_id: string
    provider_data: JsonValue | null
    created_at: Date
    last_used: Date
    _count: AuthproviderCountAggregateOutputType | null
    _avg: AuthproviderAvgAggregateOutputType | null
    _sum: AuthproviderSumAggregateOutputType | null
    _min: AuthproviderMinAggregateOutputType | null
    _max: AuthproviderMaxAggregateOutputType | null
  }

  type GetAuthproviderGroupByPayload<T extends authproviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthproviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthproviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthproviderGroupByOutputType[P]>
            : GetScalarType<T[P], AuthproviderGroupByOutputType[P]>
        }
      >
    >


  export type authproviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    provider_name?: boolean
    provider_user_id?: boolean
    provider_data?: boolean
    created_at?: boolean
    last_used?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authprovider"]>


  export type authproviderSelectScalar = {
    id?: boolean
    user_id?: boolean
    provider_name?: boolean
    provider_user_id?: boolean
    provider_data?: boolean
    created_at?: boolean
    last_used?: boolean
  }

  export type authproviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $authproviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "authprovider"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      provider_name: string
      provider_user_id: string
      provider_data: Prisma.JsonValue | null
      created_at: Date
      last_used: Date
    }, ExtArgs["result"]["authprovider"]>
    composites: {}
  }

  type authproviderGetPayload<S extends boolean | null | undefined | authproviderDefaultArgs> = $Result.GetResult<Prisma.$authproviderPayload, S>

  type authproviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<authproviderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthproviderCountAggregateInputType | true
    }

  export interface authproviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['authprovider'], meta: { name: 'authprovider' } }
    /**
     * Find zero or one Authprovider that matches the filter.
     * @param {authproviderFindUniqueArgs} args - Arguments to find a Authprovider
     * @example
     * // Get one Authprovider
     * const authprovider = await prisma.authprovider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends authproviderFindUniqueArgs>(args: SelectSubset<T, authproviderFindUniqueArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Authprovider that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {authproviderFindUniqueOrThrowArgs} args - Arguments to find a Authprovider
     * @example
     * // Get one Authprovider
     * const authprovider = await prisma.authprovider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends authproviderFindUniqueOrThrowArgs>(args: SelectSubset<T, authproviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Authprovider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderFindFirstArgs} args - Arguments to find a Authprovider
     * @example
     * // Get one Authprovider
     * const authprovider = await prisma.authprovider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends authproviderFindFirstArgs>(args?: SelectSubset<T, authproviderFindFirstArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Authprovider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderFindFirstOrThrowArgs} args - Arguments to find a Authprovider
     * @example
     * // Get one Authprovider
     * const authprovider = await prisma.authprovider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends authproviderFindFirstOrThrowArgs>(args?: SelectSubset<T, authproviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Authproviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authproviders
     * const authproviders = await prisma.authprovider.findMany()
     * 
     * // Get first 10 Authproviders
     * const authproviders = await prisma.authprovider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authproviderWithIdOnly = await prisma.authprovider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends authproviderFindManyArgs>(args?: SelectSubset<T, authproviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Authprovider.
     * @param {authproviderCreateArgs} args - Arguments to create a Authprovider.
     * @example
     * // Create one Authprovider
     * const Authprovider = await prisma.authprovider.create({
     *   data: {
     *     // ... data to create a Authprovider
     *   }
     * })
     * 
     */
    create<T extends authproviderCreateArgs>(args: SelectSubset<T, authproviderCreateArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Authproviders.
     * @param {authproviderCreateManyArgs} args - Arguments to create many Authproviders.
     * @example
     * // Create many Authproviders
     * const authprovider = await prisma.authprovider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends authproviderCreateManyArgs>(args?: SelectSubset<T, authproviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Authprovider.
     * @param {authproviderDeleteArgs} args - Arguments to delete one Authprovider.
     * @example
     * // Delete one Authprovider
     * const Authprovider = await prisma.authprovider.delete({
     *   where: {
     *     // ... filter to delete one Authprovider
     *   }
     * })
     * 
     */
    delete<T extends authproviderDeleteArgs>(args: SelectSubset<T, authproviderDeleteArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Authprovider.
     * @param {authproviderUpdateArgs} args - Arguments to update one Authprovider.
     * @example
     * // Update one Authprovider
     * const authprovider = await prisma.authprovider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends authproviderUpdateArgs>(args: SelectSubset<T, authproviderUpdateArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Authproviders.
     * @param {authproviderDeleteManyArgs} args - Arguments to filter Authproviders to delete.
     * @example
     * // Delete a few Authproviders
     * const { count } = await prisma.authprovider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends authproviderDeleteManyArgs>(args?: SelectSubset<T, authproviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authproviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authproviders
     * const authprovider = await prisma.authprovider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends authproviderUpdateManyArgs>(args: SelectSubset<T, authproviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Authprovider.
     * @param {authproviderUpsertArgs} args - Arguments to update or create a Authprovider.
     * @example
     * // Update or create a Authprovider
     * const authprovider = await prisma.authprovider.upsert({
     *   create: {
     *     // ... data to create a Authprovider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authprovider we want to update
     *   }
     * })
     */
    upsert<T extends authproviderUpsertArgs>(args: SelectSubset<T, authproviderUpsertArgs<ExtArgs>>): Prisma__authproviderClient<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Authproviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderCountArgs} args - Arguments to filter Authproviders to count.
     * @example
     * // Count the number of Authproviders
     * const count = await prisma.authprovider.count({
     *   where: {
     *     // ... the filter for the Authproviders we want to count
     *   }
     * })
    **/
    count<T extends authproviderCountArgs>(
      args?: Subset<T, authproviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthproviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authprovider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthproviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthproviderAggregateArgs>(args: Subset<T, AuthproviderAggregateArgs>): Prisma.PrismaPromise<GetAuthproviderAggregateType<T>>

    /**
     * Group by Authprovider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authproviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends authproviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: authproviderGroupByArgs['orderBy'] }
        : { orderBy?: authproviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, authproviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthproviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the authprovider model
   */
  readonly fields: authproviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for authprovider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__authproviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the authprovider model
   */ 
  interface authproviderFieldRefs {
    readonly id: FieldRef<"authprovider", 'Int'>
    readonly user_id: FieldRef<"authprovider", 'Int'>
    readonly provider_name: FieldRef<"authprovider", 'String'>
    readonly provider_user_id: FieldRef<"authprovider", 'String'>
    readonly provider_data: FieldRef<"authprovider", 'Json'>
    readonly created_at: FieldRef<"authprovider", 'DateTime'>
    readonly last_used: FieldRef<"authprovider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * authprovider findUnique
   */
  export type authproviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authprovider to fetch.
     */
    where: authproviderWhereUniqueInput
  }

  /**
   * authprovider findUniqueOrThrow
   */
  export type authproviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authprovider to fetch.
     */
    where: authproviderWhereUniqueInput
  }

  /**
   * authprovider findFirst
   */
  export type authproviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authprovider to fetch.
     */
    where?: authproviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authproviders to fetch.
     */
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authproviders.
     */
    cursor?: authproviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authproviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authproviders.
     */
    distinct?: AuthproviderScalarFieldEnum | AuthproviderScalarFieldEnum[]
  }

  /**
   * authprovider findFirstOrThrow
   */
  export type authproviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authprovider to fetch.
     */
    where?: authproviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authproviders to fetch.
     */
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authproviders.
     */
    cursor?: authproviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authproviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authproviders.
     */
    distinct?: AuthproviderScalarFieldEnum | AuthproviderScalarFieldEnum[]
  }

  /**
   * authprovider findMany
   */
  export type authproviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter, which authproviders to fetch.
     */
    where?: authproviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authproviders to fetch.
     */
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing authproviders.
     */
    cursor?: authproviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authproviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authproviders.
     */
    skip?: number
    distinct?: AuthproviderScalarFieldEnum | AuthproviderScalarFieldEnum[]
  }

  /**
   * authprovider create
   */
  export type authproviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * The data needed to create a authprovider.
     */
    data: XOR<authproviderCreateInput, authproviderUncheckedCreateInput>
  }

  /**
   * authprovider createMany
   */
  export type authproviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many authproviders.
     */
    data: authproviderCreateManyInput | authproviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * authprovider update
   */
  export type authproviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * The data needed to update a authprovider.
     */
    data: XOR<authproviderUpdateInput, authproviderUncheckedUpdateInput>
    /**
     * Choose, which authprovider to update.
     */
    where: authproviderWhereUniqueInput
  }

  /**
   * authprovider updateMany
   */
  export type authproviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update authproviders.
     */
    data: XOR<authproviderUpdateManyMutationInput, authproviderUncheckedUpdateManyInput>
    /**
     * Filter which authproviders to update
     */
    where?: authproviderWhereInput
  }

  /**
   * authprovider upsert
   */
  export type authproviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * The filter to search for the authprovider to update in case it exists.
     */
    where: authproviderWhereUniqueInput
    /**
     * In case the authprovider found by the `where` argument doesn't exist, create a new authprovider with this data.
     */
    create: XOR<authproviderCreateInput, authproviderUncheckedCreateInput>
    /**
     * In case the authprovider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<authproviderUpdateInput, authproviderUncheckedUpdateInput>
  }

  /**
   * authprovider delete
   */
  export type authproviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    /**
     * Filter which authprovider to delete.
     */
    where: authproviderWhereUniqueInput
  }

  /**
   * authprovider deleteMany
   */
  export type authproviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authproviders to delete
     */
    where?: authproviderWhereInput
  }

  /**
   * authprovider without action
   */
  export type authproviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
  }


  /**
   * Model didwallet
   */

  export type AggregateDidwallet = {
    _count: DidwalletCountAggregateOutputType | null
    _avg: DidwalletAvgAggregateOutputType | null
    _sum: DidwalletSumAggregateOutputType | null
    _min: DidwalletMinAggregateOutputType | null
    _max: DidwalletMaxAggregateOutputType | null
  }

  export type DidwalletAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type DidwalletSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type DidwalletMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    wallet_address: string | null
    did: string | null
    is_primary: boolean | null
    created_at: Date | null
    last_used: Date | null
  }

  export type DidwalletMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    wallet_address: string | null
    did: string | null
    is_primary: boolean | null
    created_at: Date | null
    last_used: Date | null
  }

  export type DidwalletCountAggregateOutputType = {
    id: number
    user_id: number
    wallet_address: number
    did: number
    is_primary: number
    created_at: number
    last_used: number
    _all: number
  }


  export type DidwalletAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type DidwalletSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type DidwalletMinAggregateInputType = {
    id?: true
    user_id?: true
    wallet_address?: true
    did?: true
    is_primary?: true
    created_at?: true
    last_used?: true
  }

  export type DidwalletMaxAggregateInputType = {
    id?: true
    user_id?: true
    wallet_address?: true
    did?: true
    is_primary?: true
    created_at?: true
    last_used?: true
  }

  export type DidwalletCountAggregateInputType = {
    id?: true
    user_id?: true
    wallet_address?: true
    did?: true
    is_primary?: true
    created_at?: true
    last_used?: true
    _all?: true
  }

  export type DidwalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which didwallet to aggregate.
     */
    where?: didwalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of didwallets to fetch.
     */
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: didwalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` didwallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` didwallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned didwallets
    **/
    _count?: true | DidwalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DidwalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DidwalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DidwalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DidwalletMaxAggregateInputType
  }

  export type GetDidwalletAggregateType<T extends DidwalletAggregateArgs> = {
        [P in keyof T & keyof AggregateDidwallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDidwallet[P]>
      : GetScalarType<T[P], AggregateDidwallet[P]>
  }




  export type didwalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: didwalletWhereInput
    orderBy?: didwalletOrderByWithAggregationInput | didwalletOrderByWithAggregationInput[]
    by: DidwalletScalarFieldEnum[] | DidwalletScalarFieldEnum
    having?: didwalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DidwalletCountAggregateInputType | true
    _avg?: DidwalletAvgAggregateInputType
    _sum?: DidwalletSumAggregateInputType
    _min?: DidwalletMinAggregateInputType
    _max?: DidwalletMaxAggregateInputType
  }

  export type DidwalletGroupByOutputType = {
    id: number
    user_id: number
    wallet_address: string
    did: string
    is_primary: boolean
    created_at: Date
    last_used: Date
    _count: DidwalletCountAggregateOutputType | null
    _avg: DidwalletAvgAggregateOutputType | null
    _sum: DidwalletSumAggregateOutputType | null
    _min: DidwalletMinAggregateOutputType | null
    _max: DidwalletMaxAggregateOutputType | null
  }

  type GetDidwalletGroupByPayload<T extends didwalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DidwalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DidwalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DidwalletGroupByOutputType[P]>
            : GetScalarType<T[P], DidwalletGroupByOutputType[P]>
        }
      >
    >


  export type didwalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    wallet_address?: boolean
    did?: boolean
    is_primary?: boolean
    created_at?: boolean
    last_used?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["didwallet"]>


  export type didwalletSelectScalar = {
    id?: boolean
    user_id?: boolean
    wallet_address?: boolean
    did?: boolean
    is_primary?: boolean
    created_at?: boolean
    last_used?: boolean
  }

  export type didwalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $didwalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "didwallet"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      wallet_address: string
      did: string
      is_primary: boolean
      created_at: Date
      last_used: Date
    }, ExtArgs["result"]["didwallet"]>
    composites: {}
  }

  type didwalletGetPayload<S extends boolean | null | undefined | didwalletDefaultArgs> = $Result.GetResult<Prisma.$didwalletPayload, S>

  type didwalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<didwalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DidwalletCountAggregateInputType | true
    }

  export interface didwalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['didwallet'], meta: { name: 'didwallet' } }
    /**
     * Find zero or one Didwallet that matches the filter.
     * @param {didwalletFindUniqueArgs} args - Arguments to find a Didwallet
     * @example
     * // Get one Didwallet
     * const didwallet = await prisma.didwallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends didwalletFindUniqueArgs>(args: SelectSubset<T, didwalletFindUniqueArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Didwallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {didwalletFindUniqueOrThrowArgs} args - Arguments to find a Didwallet
     * @example
     * // Get one Didwallet
     * const didwallet = await prisma.didwallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends didwalletFindUniqueOrThrowArgs>(args: SelectSubset<T, didwalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Didwallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletFindFirstArgs} args - Arguments to find a Didwallet
     * @example
     * // Get one Didwallet
     * const didwallet = await prisma.didwallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends didwalletFindFirstArgs>(args?: SelectSubset<T, didwalletFindFirstArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Didwallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletFindFirstOrThrowArgs} args - Arguments to find a Didwallet
     * @example
     * // Get one Didwallet
     * const didwallet = await prisma.didwallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends didwalletFindFirstOrThrowArgs>(args?: SelectSubset<T, didwalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Didwallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Didwallets
     * const didwallets = await prisma.didwallet.findMany()
     * 
     * // Get first 10 Didwallets
     * const didwallets = await prisma.didwallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const didwalletWithIdOnly = await prisma.didwallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends didwalletFindManyArgs>(args?: SelectSubset<T, didwalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Didwallet.
     * @param {didwalletCreateArgs} args - Arguments to create a Didwallet.
     * @example
     * // Create one Didwallet
     * const Didwallet = await prisma.didwallet.create({
     *   data: {
     *     // ... data to create a Didwallet
     *   }
     * })
     * 
     */
    create<T extends didwalletCreateArgs>(args: SelectSubset<T, didwalletCreateArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Didwallets.
     * @param {didwalletCreateManyArgs} args - Arguments to create many Didwallets.
     * @example
     * // Create many Didwallets
     * const didwallet = await prisma.didwallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends didwalletCreateManyArgs>(args?: SelectSubset<T, didwalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Didwallet.
     * @param {didwalletDeleteArgs} args - Arguments to delete one Didwallet.
     * @example
     * // Delete one Didwallet
     * const Didwallet = await prisma.didwallet.delete({
     *   where: {
     *     // ... filter to delete one Didwallet
     *   }
     * })
     * 
     */
    delete<T extends didwalletDeleteArgs>(args: SelectSubset<T, didwalletDeleteArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Didwallet.
     * @param {didwalletUpdateArgs} args - Arguments to update one Didwallet.
     * @example
     * // Update one Didwallet
     * const didwallet = await prisma.didwallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends didwalletUpdateArgs>(args: SelectSubset<T, didwalletUpdateArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Didwallets.
     * @param {didwalletDeleteManyArgs} args - Arguments to filter Didwallets to delete.
     * @example
     * // Delete a few Didwallets
     * const { count } = await prisma.didwallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends didwalletDeleteManyArgs>(args?: SelectSubset<T, didwalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Didwallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Didwallets
     * const didwallet = await prisma.didwallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends didwalletUpdateManyArgs>(args: SelectSubset<T, didwalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Didwallet.
     * @param {didwalletUpsertArgs} args - Arguments to update or create a Didwallet.
     * @example
     * // Update or create a Didwallet
     * const didwallet = await prisma.didwallet.upsert({
     *   create: {
     *     // ... data to create a Didwallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Didwallet we want to update
     *   }
     * })
     */
    upsert<T extends didwalletUpsertArgs>(args: SelectSubset<T, didwalletUpsertArgs<ExtArgs>>): Prisma__didwalletClient<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Didwallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletCountArgs} args - Arguments to filter Didwallets to count.
     * @example
     * // Count the number of Didwallets
     * const count = await prisma.didwallet.count({
     *   where: {
     *     // ... the filter for the Didwallets we want to count
     *   }
     * })
    **/
    count<T extends didwalletCountArgs>(
      args?: Subset<T, didwalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DidwalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Didwallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DidwalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DidwalletAggregateArgs>(args: Subset<T, DidwalletAggregateArgs>): Prisma.PrismaPromise<GetDidwalletAggregateType<T>>

    /**
     * Group by Didwallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {didwalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends didwalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: didwalletGroupByArgs['orderBy'] }
        : { orderBy?: didwalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, didwalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDidwalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the didwallet model
   */
  readonly fields: didwalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for didwallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__didwalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the didwallet model
   */ 
  interface didwalletFieldRefs {
    readonly id: FieldRef<"didwallet", 'Int'>
    readonly user_id: FieldRef<"didwallet", 'Int'>
    readonly wallet_address: FieldRef<"didwallet", 'String'>
    readonly did: FieldRef<"didwallet", 'String'>
    readonly is_primary: FieldRef<"didwallet", 'Boolean'>
    readonly created_at: FieldRef<"didwallet", 'DateTime'>
    readonly last_used: FieldRef<"didwallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * didwallet findUnique
   */
  export type didwalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallet to fetch.
     */
    where: didwalletWhereUniqueInput
  }

  /**
   * didwallet findUniqueOrThrow
   */
  export type didwalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallet to fetch.
     */
    where: didwalletWhereUniqueInput
  }

  /**
   * didwallet findFirst
   */
  export type didwalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallet to fetch.
     */
    where?: didwalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of didwallets to fetch.
     */
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for didwallets.
     */
    cursor?: didwalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` didwallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` didwallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of didwallets.
     */
    distinct?: DidwalletScalarFieldEnum | DidwalletScalarFieldEnum[]
  }

  /**
   * didwallet findFirstOrThrow
   */
  export type didwalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallet to fetch.
     */
    where?: didwalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of didwallets to fetch.
     */
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for didwallets.
     */
    cursor?: didwalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` didwallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` didwallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of didwallets.
     */
    distinct?: DidwalletScalarFieldEnum | DidwalletScalarFieldEnum[]
  }

  /**
   * didwallet findMany
   */
  export type didwalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter, which didwallets to fetch.
     */
    where?: didwalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of didwallets to fetch.
     */
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing didwallets.
     */
    cursor?: didwalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` didwallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` didwallets.
     */
    skip?: number
    distinct?: DidwalletScalarFieldEnum | DidwalletScalarFieldEnum[]
  }

  /**
   * didwallet create
   */
  export type didwalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * The data needed to create a didwallet.
     */
    data: XOR<didwalletCreateInput, didwalletUncheckedCreateInput>
  }

  /**
   * didwallet createMany
   */
  export type didwalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many didwallets.
     */
    data: didwalletCreateManyInput | didwalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * didwallet update
   */
  export type didwalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * The data needed to update a didwallet.
     */
    data: XOR<didwalletUpdateInput, didwalletUncheckedUpdateInput>
    /**
     * Choose, which didwallet to update.
     */
    where: didwalletWhereUniqueInput
  }

  /**
   * didwallet updateMany
   */
  export type didwalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update didwallets.
     */
    data: XOR<didwalletUpdateManyMutationInput, didwalletUncheckedUpdateManyInput>
    /**
     * Filter which didwallets to update
     */
    where?: didwalletWhereInput
  }

  /**
   * didwallet upsert
   */
  export type didwalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * The filter to search for the didwallet to update in case it exists.
     */
    where: didwalletWhereUniqueInput
    /**
     * In case the didwallet found by the `where` argument doesn't exist, create a new didwallet with this data.
     */
    create: XOR<didwalletCreateInput, didwalletUncheckedCreateInput>
    /**
     * In case the didwallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<didwalletUpdateInput, didwalletUncheckedUpdateInput>
  }

  /**
   * didwallet delete
   */
  export type didwalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    /**
     * Filter which didwallet to delete.
     */
    where: didwalletWhereUniqueInput
  }

  /**
   * didwallet deleteMany
   */
  export type didwalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which didwallets to delete
     */
    where?: didwalletWhereInput
  }

  /**
   * didwallet without action
   */
  export type didwalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
  }


  /**
   * Model investor
   */

  export type AggregateInvestor = {
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  export type InvestorAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type InvestorSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type InvestorMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    investor_type: string | null
    accreditation_status: string | null
    accreditation_date: Date | null
    kyc_verified: boolean | null
    aml_verified: boolean | null
  }

  export type InvestorMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    investor_type: string | null
    accreditation_status: string | null
    accreditation_date: Date | null
    kyc_verified: boolean | null
    aml_verified: boolean | null
  }

  export type InvestorCountAggregateOutputType = {
    id: number
    user_id: number
    investor_type: number
    accreditation_status: number
    accreditation_date: number
    kyc_documents: number
    aml_documents: number
    kyc_verified: number
    aml_verified: number
    _all: number
  }


  export type InvestorAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type InvestorSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type InvestorMinAggregateInputType = {
    id?: true
    user_id?: true
    investor_type?: true
    accreditation_status?: true
    accreditation_date?: true
    kyc_verified?: true
    aml_verified?: true
  }

  export type InvestorMaxAggregateInputType = {
    id?: true
    user_id?: true
    investor_type?: true
    accreditation_status?: true
    accreditation_date?: true
    kyc_verified?: true
    aml_verified?: true
  }

  export type InvestorCountAggregateInputType = {
    id?: true
    user_id?: true
    investor_type?: true
    accreditation_status?: true
    accreditation_date?: true
    kyc_documents?: true
    aml_documents?: true
    kyc_verified?: true
    aml_verified?: true
    _all?: true
  }

  export type InvestorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investor to aggregate.
     */
    where?: investorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investors to fetch.
     */
    orderBy?: investorOrderByWithRelationInput | investorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: investorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned investors
    **/
    _count?: true | InvestorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestorMaxAggregateInputType
  }

  export type GetInvestorAggregateType<T extends InvestorAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestor[P]>
      : GetScalarType<T[P], AggregateInvestor[P]>
  }




  export type investorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: investorWhereInput
    orderBy?: investorOrderByWithAggregationInput | investorOrderByWithAggregationInput[]
    by: InvestorScalarFieldEnum[] | InvestorScalarFieldEnum
    having?: investorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestorCountAggregateInputType | true
    _avg?: InvestorAvgAggregateInputType
    _sum?: InvestorSumAggregateInputType
    _min?: InvestorMinAggregateInputType
    _max?: InvestorMaxAggregateInputType
  }

  export type InvestorGroupByOutputType = {
    id: number
    user_id: number
    investor_type: string
    accreditation_status: string
    accreditation_date: Date | null
    kyc_documents: JsonValue | null
    aml_documents: JsonValue | null
    kyc_verified: boolean
    aml_verified: boolean
    _count: InvestorCountAggregateOutputType | null
    _avg: InvestorAvgAggregateOutputType | null
    _sum: InvestorSumAggregateOutputType | null
    _min: InvestorMinAggregateOutputType | null
    _max: InvestorMaxAggregateOutputType | null
  }

  type GetInvestorGroupByPayload<T extends investorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestorGroupByOutputType[P]>
            : GetScalarType<T[P], InvestorGroupByOutputType[P]>
        }
      >
    >


  export type investorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    investor_type?: boolean
    accreditation_status?: boolean
    accreditation_date?: boolean
    kyc_documents?: boolean
    aml_documents?: boolean
    kyc_verified?: boolean
    aml_verified?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investor"]>


  export type investorSelectScalar = {
    id?: boolean
    user_id?: boolean
    investor_type?: boolean
    accreditation_status?: boolean
    accreditation_date?: boolean
    kyc_documents?: boolean
    aml_documents?: boolean
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $investorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "investor"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      investor_type: string
      accreditation_status: string
      accreditation_date: Date | null
      kyc_documents: Prisma.JsonValue | null
      aml_documents: Prisma.JsonValue | null
      kyc_verified: boolean
      aml_verified: boolean
    }, ExtArgs["result"]["investor"]>
    composites: {}
  }

  type investorGetPayload<S extends boolean | null | undefined | investorDefaultArgs> = $Result.GetResult<Prisma.$investorPayload, S>

  type investorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<investorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvestorCountAggregateInputType | true
    }

  export interface investorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['investor'], meta: { name: 'investor' } }
    /**
     * Find zero or one Investor that matches the filter.
     * @param {investorFindUniqueArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends investorFindUniqueArgs>(args: SelectSubset<T, investorFindUniqueArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Investor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {investorFindUniqueOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends investorFindUniqueOrThrowArgs>(args: SelectSubset<T, investorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Investor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorFindFirstArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends investorFindFirstArgs>(args?: SelectSubset<T, investorFindFirstArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Investor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorFindFirstOrThrowArgs} args - Arguments to find a Investor
     * @example
     * // Get one Investor
     * const investor = await prisma.investor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends investorFindFirstOrThrowArgs>(args?: SelectSubset<T, investorFindFirstOrThrowArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Investors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Investors
     * const investors = await prisma.investor.findMany()
     * 
     * // Get first 10 Investors
     * const investors = await prisma.investor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investorWithIdOnly = await prisma.investor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends investorFindManyArgs>(args?: SelectSubset<T, investorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Investor.
     * @param {investorCreateArgs} args - Arguments to create a Investor.
     * @example
     * // Create one Investor
     * const Investor = await prisma.investor.create({
     *   data: {
     *     // ... data to create a Investor
     *   }
     * })
     * 
     */
    create<T extends investorCreateArgs>(args: SelectSubset<T, investorCreateArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Investors.
     * @param {investorCreateManyArgs} args - Arguments to create many Investors.
     * @example
     * // Create many Investors
     * const investor = await prisma.investor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends investorCreateManyArgs>(args?: SelectSubset<T, investorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Investor.
     * @param {investorDeleteArgs} args - Arguments to delete one Investor.
     * @example
     * // Delete one Investor
     * const Investor = await prisma.investor.delete({
     *   where: {
     *     // ... filter to delete one Investor
     *   }
     * })
     * 
     */
    delete<T extends investorDeleteArgs>(args: SelectSubset<T, investorDeleteArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Investor.
     * @param {investorUpdateArgs} args - Arguments to update one Investor.
     * @example
     * // Update one Investor
     * const investor = await prisma.investor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends investorUpdateArgs>(args: SelectSubset<T, investorUpdateArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Investors.
     * @param {investorDeleteManyArgs} args - Arguments to filter Investors to delete.
     * @example
     * // Delete a few Investors
     * const { count } = await prisma.investor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends investorDeleteManyArgs>(args?: SelectSubset<T, investorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Investors
     * const investor = await prisma.investor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends investorUpdateManyArgs>(args: SelectSubset<T, investorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Investor.
     * @param {investorUpsertArgs} args - Arguments to update or create a Investor.
     * @example
     * // Update or create a Investor
     * const investor = await prisma.investor.upsert({
     *   create: {
     *     // ... data to create a Investor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Investor we want to update
     *   }
     * })
     */
    upsert<T extends investorUpsertArgs>(args: SelectSubset<T, investorUpsertArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Investors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorCountArgs} args - Arguments to filter Investors to count.
     * @example
     * // Count the number of Investors
     * const count = await prisma.investor.count({
     *   where: {
     *     // ... the filter for the Investors we want to count
     *   }
     * })
    **/
    count<T extends investorCountArgs>(
      args?: Subset<T, investorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestorAggregateArgs>(args: Subset<T, InvestorAggregateArgs>): Prisma.PrismaPromise<GetInvestorAggregateType<T>>

    /**
     * Group by Investor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {investorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends investorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: investorGroupByArgs['orderBy'] }
        : { orderBy?: investorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, investorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the investor model
   */
  readonly fields: investorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for investor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__investorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the investor model
   */ 
  interface investorFieldRefs {
    readonly id: FieldRef<"investor", 'Int'>
    readonly user_id: FieldRef<"investor", 'Int'>
    readonly investor_type: FieldRef<"investor", 'String'>
    readonly accreditation_status: FieldRef<"investor", 'String'>
    readonly accreditation_date: FieldRef<"investor", 'DateTime'>
    readonly kyc_documents: FieldRef<"investor", 'Json'>
    readonly aml_documents: FieldRef<"investor", 'Json'>
    readonly kyc_verified: FieldRef<"investor", 'Boolean'>
    readonly aml_verified: FieldRef<"investor", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * investor findUnique
   */
  export type investorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investor to fetch.
     */
    where: investorWhereUniqueInput
  }

  /**
   * investor findUniqueOrThrow
   */
  export type investorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investor to fetch.
     */
    where: investorWhereUniqueInput
  }

  /**
   * investor findFirst
   */
  export type investorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investor to fetch.
     */
    where?: investorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investors to fetch.
     */
    orderBy?: investorOrderByWithRelationInput | investorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investors.
     */
    cursor?: investorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * investor findFirstOrThrow
   */
  export type investorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investor to fetch.
     */
    where?: investorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investors to fetch.
     */
    orderBy?: investorOrderByWithRelationInput | investorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for investors.
     */
    cursor?: investorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of investors.
     */
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * investor findMany
   */
  export type investorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter, which investors to fetch.
     */
    where?: investorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of investors to fetch.
     */
    orderBy?: investorOrderByWithRelationInput | investorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing investors.
     */
    cursor?: investorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` investors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` investors.
     */
    skip?: number
    distinct?: InvestorScalarFieldEnum | InvestorScalarFieldEnum[]
  }

  /**
   * investor create
   */
  export type investorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * The data needed to create a investor.
     */
    data: XOR<investorCreateInput, investorUncheckedCreateInput>
  }

  /**
   * investor createMany
   */
  export type investorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many investors.
     */
    data: investorCreateManyInput | investorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * investor update
   */
  export type investorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * The data needed to update a investor.
     */
    data: XOR<investorUpdateInput, investorUncheckedUpdateInput>
    /**
     * Choose, which investor to update.
     */
    where: investorWhereUniqueInput
  }

  /**
   * investor updateMany
   */
  export type investorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update investors.
     */
    data: XOR<investorUpdateManyMutationInput, investorUncheckedUpdateManyInput>
    /**
     * Filter which investors to update
     */
    where?: investorWhereInput
  }

  /**
   * investor upsert
   */
  export type investorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * The filter to search for the investor to update in case it exists.
     */
    where: investorWhereUniqueInput
    /**
     * In case the investor found by the `where` argument doesn't exist, create a new investor with this data.
     */
    create: XOR<investorCreateInput, investorUncheckedCreateInput>
    /**
     * In case the investor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<investorUpdateInput, investorUncheckedUpdateInput>
  }

  /**
   * investor delete
   */
  export type investorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    /**
     * Filter which investor to delete.
     */
    where: investorWhereUniqueInput
  }

  /**
   * investor deleteMany
   */
  export type investorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which investors to delete
     */
    where?: investorWhereInput
  }

  /**
   * investor without action
   */
  export type investorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
  }


  /**
   * Model issuer
   */

  export type AggregateIssuer = {
    _count: IssuerCountAggregateOutputType | null
    _avg: IssuerAvgAggregateOutputType | null
    _sum: IssuerSumAggregateOutputType | null
    _min: IssuerMinAggregateOutputType | null
    _max: IssuerMaxAggregateOutputType | null
  }

  export type IssuerAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type IssuerSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type IssuerMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    company_name: string | null
    company_registration_number: string | null
    jurisdiction: string | null
    verification_status: boolean | null
    verification_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    wallet_address: string | null
    wallet_created_at: Date | null
    ethereum_address: string | null
    ethereum_wallet_created_at: Date | null
    solana_address: string | null
    solana_wallet_created_at: Date | null
  }

  export type IssuerMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    company_name: string | null
    company_registration_number: string | null
    jurisdiction: string | null
    verification_status: boolean | null
    verification_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    wallet_address: string | null
    wallet_created_at: Date | null
    ethereum_address: string | null
    ethereum_wallet_created_at: Date | null
    solana_address: string | null
    solana_wallet_created_at: Date | null
  }

  export type IssuerCountAggregateOutputType = {
    id: number
    user_id: number
    company_name: number
    company_registration_number: number
    jurisdiction: number
    verification_status: number
    verification_date: number
    company_documents: number
    created_at: number
    updated_at: number
    wallet_address: number
    wallet_created_at: number
    ethereum_address: number
    ethereum_wallet_created_at: number
    solana_address: number
    solana_wallet_created_at: number
    _all: number
  }


  export type IssuerAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type IssuerSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type IssuerMinAggregateInputType = {
    id?: true
    user_id?: true
    company_name?: true
    company_registration_number?: true
    jurisdiction?: true
    verification_status?: true
    verification_date?: true
    created_at?: true
    updated_at?: true
    wallet_address?: true
    wallet_created_at?: true
    ethereum_address?: true
    ethereum_wallet_created_at?: true
    solana_address?: true
    solana_wallet_created_at?: true
  }

  export type IssuerMaxAggregateInputType = {
    id?: true
    user_id?: true
    company_name?: true
    company_registration_number?: true
    jurisdiction?: true
    verification_status?: true
    verification_date?: true
    created_at?: true
    updated_at?: true
    wallet_address?: true
    wallet_created_at?: true
    ethereum_address?: true
    ethereum_wallet_created_at?: true
    solana_address?: true
    solana_wallet_created_at?: true
  }

  export type IssuerCountAggregateInputType = {
    id?: true
    user_id?: true
    company_name?: true
    company_registration_number?: true
    jurisdiction?: true
    verification_status?: true
    verification_date?: true
    company_documents?: true
    created_at?: true
    updated_at?: true
    wallet_address?: true
    wallet_created_at?: true
    ethereum_address?: true
    ethereum_wallet_created_at?: true
    solana_address?: true
    solana_wallet_created_at?: true
    _all?: true
  }

  export type IssuerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which issuer to aggregate.
     */
    where?: issuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuers to fetch.
     */
    orderBy?: issuerOrderByWithRelationInput | issuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: issuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned issuers
    **/
    _count?: true | IssuerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IssuerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IssuerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssuerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssuerMaxAggregateInputType
  }

  export type GetIssuerAggregateType<T extends IssuerAggregateArgs> = {
        [P in keyof T & keyof AggregateIssuer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssuer[P]>
      : GetScalarType<T[P], AggregateIssuer[P]>
  }




  export type issuerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: issuerWhereInput
    orderBy?: issuerOrderByWithAggregationInput | issuerOrderByWithAggregationInput[]
    by: IssuerScalarFieldEnum[] | IssuerScalarFieldEnum
    having?: issuerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssuerCountAggregateInputType | true
    _avg?: IssuerAvgAggregateInputType
    _sum?: IssuerSumAggregateInputType
    _min?: IssuerMinAggregateInputType
    _max?: IssuerMaxAggregateInputType
  }

  export type IssuerGroupByOutputType = {
    id: number
    user_id: number
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status: boolean
    verification_date: Date | null
    company_documents: JsonValue | null
    created_at: Date
    updated_at: Date
    wallet_address: string | null
    wallet_created_at: Date | null
    ethereum_address: string | null
    ethereum_wallet_created_at: Date | null
    solana_address: string | null
    solana_wallet_created_at: Date | null
    _count: IssuerCountAggregateOutputType | null
    _avg: IssuerAvgAggregateOutputType | null
    _sum: IssuerSumAggregateOutputType | null
    _min: IssuerMinAggregateOutputType | null
    _max: IssuerMaxAggregateOutputType | null
  }

  type GetIssuerGroupByPayload<T extends issuerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssuerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssuerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssuerGroupByOutputType[P]>
            : GetScalarType<T[P], IssuerGroupByOutputType[P]>
        }
      >
    >


  export type issuerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    company_name?: boolean
    company_registration_number?: boolean
    jurisdiction?: boolean
    verification_status?: boolean
    verification_date?: boolean
    company_documents?: boolean
    created_at?: boolean
    updated_at?: boolean
    wallet_address?: boolean
    wallet_created_at?: boolean
    ethereum_address?: boolean
    ethereum_wallet_created_at?: boolean
    solana_address?: boolean
    solana_wallet_created_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    offering?: boolean | issuer$offeringArgs<ExtArgs>
    _count?: boolean | IssuerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issuer"]>


  export type issuerSelectScalar = {
    id?: boolean
    user_id?: boolean
    company_name?: boolean
    company_registration_number?: boolean
    jurisdiction?: boolean
    verification_status?: boolean
    verification_date?: boolean
    company_documents?: boolean
    created_at?: boolean
    updated_at?: boolean
    wallet_address?: boolean
    wallet_created_at?: boolean
    ethereum_address?: boolean
    ethereum_wallet_created_at?: boolean
    solana_address?: boolean
    solana_wallet_created_at?: boolean
  }

  export type issuerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    offering?: boolean | issuer$offeringArgs<ExtArgs>
    _count?: boolean | IssuerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $issuerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "issuer"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      offering: Prisma.$offeringPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      company_name: string
      company_registration_number: string
      jurisdiction: string
      verification_status: boolean
      verification_date: Date | null
      company_documents: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
      wallet_address: string | null
      wallet_created_at: Date | null
      ethereum_address: string | null
      ethereum_wallet_created_at: Date | null
      solana_address: string | null
      solana_wallet_created_at: Date | null
    }, ExtArgs["result"]["issuer"]>
    composites: {}
  }

  type issuerGetPayload<S extends boolean | null | undefined | issuerDefaultArgs> = $Result.GetResult<Prisma.$issuerPayload, S>

  type issuerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<issuerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IssuerCountAggregateInputType | true
    }

  export interface issuerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['issuer'], meta: { name: 'issuer' } }
    /**
     * Find zero or one Issuer that matches the filter.
     * @param {issuerFindUniqueArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends issuerFindUniqueArgs>(args: SelectSubset<T, issuerFindUniqueArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Issuer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {issuerFindUniqueOrThrowArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends issuerFindUniqueOrThrowArgs>(args: SelectSubset<T, issuerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Issuer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerFindFirstArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends issuerFindFirstArgs>(args?: SelectSubset<T, issuerFindFirstArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Issuer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerFindFirstOrThrowArgs} args - Arguments to find a Issuer
     * @example
     * // Get one Issuer
     * const issuer = await prisma.issuer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends issuerFindFirstOrThrowArgs>(args?: SelectSubset<T, issuerFindFirstOrThrowArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Issuers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Issuers
     * const issuers = await prisma.issuer.findMany()
     * 
     * // Get first 10 Issuers
     * const issuers = await prisma.issuer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issuerWithIdOnly = await prisma.issuer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends issuerFindManyArgs>(args?: SelectSubset<T, issuerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Issuer.
     * @param {issuerCreateArgs} args - Arguments to create a Issuer.
     * @example
     * // Create one Issuer
     * const Issuer = await prisma.issuer.create({
     *   data: {
     *     // ... data to create a Issuer
     *   }
     * })
     * 
     */
    create<T extends issuerCreateArgs>(args: SelectSubset<T, issuerCreateArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Issuers.
     * @param {issuerCreateManyArgs} args - Arguments to create many Issuers.
     * @example
     * // Create many Issuers
     * const issuer = await prisma.issuer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends issuerCreateManyArgs>(args?: SelectSubset<T, issuerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Issuer.
     * @param {issuerDeleteArgs} args - Arguments to delete one Issuer.
     * @example
     * // Delete one Issuer
     * const Issuer = await prisma.issuer.delete({
     *   where: {
     *     // ... filter to delete one Issuer
     *   }
     * })
     * 
     */
    delete<T extends issuerDeleteArgs>(args: SelectSubset<T, issuerDeleteArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Issuer.
     * @param {issuerUpdateArgs} args - Arguments to update one Issuer.
     * @example
     * // Update one Issuer
     * const issuer = await prisma.issuer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends issuerUpdateArgs>(args: SelectSubset<T, issuerUpdateArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Issuers.
     * @param {issuerDeleteManyArgs} args - Arguments to filter Issuers to delete.
     * @example
     * // Delete a few Issuers
     * const { count } = await prisma.issuer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends issuerDeleteManyArgs>(args?: SelectSubset<T, issuerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issuers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Issuers
     * const issuer = await prisma.issuer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends issuerUpdateManyArgs>(args: SelectSubset<T, issuerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Issuer.
     * @param {issuerUpsertArgs} args - Arguments to update or create a Issuer.
     * @example
     * // Update or create a Issuer
     * const issuer = await prisma.issuer.upsert({
     *   create: {
     *     // ... data to create a Issuer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Issuer we want to update
     *   }
     * })
     */
    upsert<T extends issuerUpsertArgs>(args: SelectSubset<T, issuerUpsertArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Issuers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerCountArgs} args - Arguments to filter Issuers to count.
     * @example
     * // Count the number of Issuers
     * const count = await prisma.issuer.count({
     *   where: {
     *     // ... the filter for the Issuers we want to count
     *   }
     * })
    **/
    count<T extends issuerCountArgs>(
      args?: Subset<T, issuerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssuerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Issuer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssuerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssuerAggregateArgs>(args: Subset<T, IssuerAggregateArgs>): Prisma.PrismaPromise<GetIssuerAggregateType<T>>

    /**
     * Group by Issuer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {issuerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends issuerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: issuerGroupByArgs['orderBy'] }
        : { orderBy?: issuerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, issuerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssuerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the issuer model
   */
  readonly fields: issuerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for issuer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__issuerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    offering<T extends issuer$offeringArgs<ExtArgs> = {}>(args?: Subset<T, issuer$offeringArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the issuer model
   */ 
  interface issuerFieldRefs {
    readonly id: FieldRef<"issuer", 'Int'>
    readonly user_id: FieldRef<"issuer", 'Int'>
    readonly company_name: FieldRef<"issuer", 'String'>
    readonly company_registration_number: FieldRef<"issuer", 'String'>
    readonly jurisdiction: FieldRef<"issuer", 'String'>
    readonly verification_status: FieldRef<"issuer", 'Boolean'>
    readonly verification_date: FieldRef<"issuer", 'DateTime'>
    readonly company_documents: FieldRef<"issuer", 'Json'>
    readonly created_at: FieldRef<"issuer", 'DateTime'>
    readonly updated_at: FieldRef<"issuer", 'DateTime'>
    readonly wallet_address: FieldRef<"issuer", 'String'>
    readonly wallet_created_at: FieldRef<"issuer", 'DateTime'>
    readonly ethereum_address: FieldRef<"issuer", 'String'>
    readonly ethereum_wallet_created_at: FieldRef<"issuer", 'DateTime'>
    readonly solana_address: FieldRef<"issuer", 'String'>
    readonly solana_wallet_created_at: FieldRef<"issuer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * issuer findUnique
   */
  export type issuerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuer to fetch.
     */
    where: issuerWhereUniqueInput
  }

  /**
   * issuer findUniqueOrThrow
   */
  export type issuerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuer to fetch.
     */
    where: issuerWhereUniqueInput
  }

  /**
   * issuer findFirst
   */
  export type issuerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuer to fetch.
     */
    where?: issuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuers to fetch.
     */
    orderBy?: issuerOrderByWithRelationInput | issuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issuers.
     */
    cursor?: issuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issuers.
     */
    distinct?: IssuerScalarFieldEnum | IssuerScalarFieldEnum[]
  }

  /**
   * issuer findFirstOrThrow
   */
  export type issuerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuer to fetch.
     */
    where?: issuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuers to fetch.
     */
    orderBy?: issuerOrderByWithRelationInput | issuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for issuers.
     */
    cursor?: issuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of issuers.
     */
    distinct?: IssuerScalarFieldEnum | IssuerScalarFieldEnum[]
  }

  /**
   * issuer findMany
   */
  export type issuerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter, which issuers to fetch.
     */
    where?: issuerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of issuers to fetch.
     */
    orderBy?: issuerOrderByWithRelationInput | issuerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing issuers.
     */
    cursor?: issuerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` issuers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` issuers.
     */
    skip?: number
    distinct?: IssuerScalarFieldEnum | IssuerScalarFieldEnum[]
  }

  /**
   * issuer create
   */
  export type issuerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * The data needed to create a issuer.
     */
    data: XOR<issuerCreateInput, issuerUncheckedCreateInput>
  }

  /**
   * issuer createMany
   */
  export type issuerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many issuers.
     */
    data: issuerCreateManyInput | issuerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * issuer update
   */
  export type issuerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * The data needed to update a issuer.
     */
    data: XOR<issuerUpdateInput, issuerUncheckedUpdateInput>
    /**
     * Choose, which issuer to update.
     */
    where: issuerWhereUniqueInput
  }

  /**
   * issuer updateMany
   */
  export type issuerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update issuers.
     */
    data: XOR<issuerUpdateManyMutationInput, issuerUncheckedUpdateManyInput>
    /**
     * Filter which issuers to update
     */
    where?: issuerWhereInput
  }

  /**
   * issuer upsert
   */
  export type issuerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * The filter to search for the issuer to update in case it exists.
     */
    where: issuerWhereUniqueInput
    /**
     * In case the issuer found by the `where` argument doesn't exist, create a new issuer with this data.
     */
    create: XOR<issuerCreateInput, issuerUncheckedCreateInput>
    /**
     * In case the issuer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<issuerUpdateInput, issuerUncheckedUpdateInput>
  }

  /**
   * issuer delete
   */
  export type issuerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    /**
     * Filter which issuer to delete.
     */
    where: issuerWhereUniqueInput
  }

  /**
   * issuer deleteMany
   */
  export type issuerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which issuers to delete
     */
    where?: issuerWhereInput
  }

  /**
   * issuer.offering
   */
  export type issuer$offeringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    where?: offeringWhereInput
    orderBy?: offeringOrderByWithRelationInput | offeringOrderByWithRelationInput[]
    cursor?: offeringWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferingScalarFieldEnum | OfferingScalarFieldEnum[]
  }

  /**
   * issuer without action
   */
  export type issuerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
  }


  /**
   * Model offering
   */

  export type AggregateOffering = {
    _count: OfferingCountAggregateOutputType | null
    _avg: OfferingAvgAggregateOutputType | null
    _sum: OfferingSumAggregateOutputType | null
    _min: OfferingMinAggregateOutputType | null
    _max: OfferingMaxAggregateOutputType | null
  }

  export type OfferingAvgAggregateOutputType = {
    id: number | null
    issuer_id: number | null
    target_amount: Decimal | null
    minimum_investment: Decimal | null
  }

  export type OfferingSumAggregateOutputType = {
    id: number | null
    issuer_id: number | null
    target_amount: Decimal | null
    minimum_investment: Decimal | null
  }

  export type OfferingMinAggregateOutputType = {
    id: number | null
    issuer_id: number | null
    name: string | null
    description: string | null
    target_amount: Decimal | null
    minimum_investment: Decimal | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OfferingMaxAggregateOutputType = {
    id: number | null
    issuer_id: number | null
    name: string | null
    description: string | null
    target_amount: Decimal | null
    minimum_investment: Decimal | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OfferingCountAggregateOutputType = {
    id: number
    issuer_id: number
    name: number
    description: number
    target_amount: number
    minimum_investment: number
    start_date: number
    end_date: number
    status: number
    created_at: number
    updated_at: number
    documents: number
    _all: number
  }


  export type OfferingAvgAggregateInputType = {
    id?: true
    issuer_id?: true
    target_amount?: true
    minimum_investment?: true
  }

  export type OfferingSumAggregateInputType = {
    id?: true
    issuer_id?: true
    target_amount?: true
    minimum_investment?: true
  }

  export type OfferingMinAggregateInputType = {
    id?: true
    issuer_id?: true
    name?: true
    description?: true
    target_amount?: true
    minimum_investment?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type OfferingMaxAggregateInputType = {
    id?: true
    issuer_id?: true
    name?: true
    description?: true
    target_amount?: true
    minimum_investment?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type OfferingCountAggregateInputType = {
    id?: true
    issuer_id?: true
    name?: true
    description?: true
    target_amount?: true
    minimum_investment?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    documents?: true
    _all?: true
  }

  export type OfferingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offering to aggregate.
     */
    where?: offeringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offerings to fetch.
     */
    orderBy?: offeringOrderByWithRelationInput | offeringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: offeringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned offerings
    **/
    _count?: true | OfferingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferingMaxAggregateInputType
  }

  export type GetOfferingAggregateType<T extends OfferingAggregateArgs> = {
        [P in keyof T & keyof AggregateOffering]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffering[P]>
      : GetScalarType<T[P], AggregateOffering[P]>
  }




  export type offeringGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offeringWhereInput
    orderBy?: offeringOrderByWithAggregationInput | offeringOrderByWithAggregationInput[]
    by: OfferingScalarFieldEnum[] | OfferingScalarFieldEnum
    having?: offeringScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferingCountAggregateInputType | true
    _avg?: OfferingAvgAggregateInputType
    _sum?: OfferingSumAggregateInputType
    _min?: OfferingMinAggregateInputType
    _max?: OfferingMaxAggregateInputType
  }

  export type OfferingGroupByOutputType = {
    id: number
    issuer_id: number
    name: string
    description: string
    target_amount: Decimal
    minimum_investment: Decimal
    start_date: Date
    end_date: Date
    status: string
    created_at: Date
    updated_at: Date
    documents: JsonValue | null
    _count: OfferingCountAggregateOutputType | null
    _avg: OfferingAvgAggregateOutputType | null
    _sum: OfferingSumAggregateOutputType | null
    _min: OfferingMinAggregateOutputType | null
    _max: OfferingMaxAggregateOutputType | null
  }

  type GetOfferingGroupByPayload<T extends offeringGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferingGroupByOutputType[P]>
            : GetScalarType<T[P], OfferingGroupByOutputType[P]>
        }
      >
    >


  export type offeringSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issuer_id?: boolean
    name?: boolean
    description?: boolean
    target_amount?: boolean
    minimum_investment?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    documents?: boolean
    issuer?: boolean | issuerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offering"]>


  export type offeringSelectScalar = {
    id?: boolean
    issuer_id?: boolean
    name?: boolean
    description?: boolean
    target_amount?: boolean
    minimum_investment?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    documents?: boolean
  }

  export type offeringInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issuer?: boolean | issuerDefaultArgs<ExtArgs>
  }

  export type $offeringPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "offering"
    objects: {
      issuer: Prisma.$issuerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      issuer_id: number
      name: string
      description: string
      target_amount: Prisma.Decimal
      minimum_investment: Prisma.Decimal
      start_date: Date
      end_date: Date
      status: string
      created_at: Date
      updated_at: Date
      documents: Prisma.JsonValue | null
    }, ExtArgs["result"]["offering"]>
    composites: {}
  }

  type offeringGetPayload<S extends boolean | null | undefined | offeringDefaultArgs> = $Result.GetResult<Prisma.$offeringPayload, S>

  type offeringCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<offeringFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OfferingCountAggregateInputType | true
    }

  export interface offeringDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['offering'], meta: { name: 'offering' } }
    /**
     * Find zero or one Offering that matches the filter.
     * @param {offeringFindUniqueArgs} args - Arguments to find a Offering
     * @example
     * // Get one Offering
     * const offering = await prisma.offering.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends offeringFindUniqueArgs>(args: SelectSubset<T, offeringFindUniqueArgs<ExtArgs>>): Prisma__offeringClient<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Offering that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {offeringFindUniqueOrThrowArgs} args - Arguments to find a Offering
     * @example
     * // Get one Offering
     * const offering = await prisma.offering.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends offeringFindUniqueOrThrowArgs>(args: SelectSubset<T, offeringFindUniqueOrThrowArgs<ExtArgs>>): Prisma__offeringClient<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Offering that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offeringFindFirstArgs} args - Arguments to find a Offering
     * @example
     * // Get one Offering
     * const offering = await prisma.offering.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends offeringFindFirstArgs>(args?: SelectSubset<T, offeringFindFirstArgs<ExtArgs>>): Prisma__offeringClient<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Offering that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offeringFindFirstOrThrowArgs} args - Arguments to find a Offering
     * @example
     * // Get one Offering
     * const offering = await prisma.offering.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends offeringFindFirstOrThrowArgs>(args?: SelectSubset<T, offeringFindFirstOrThrowArgs<ExtArgs>>): Prisma__offeringClient<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Offerings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offeringFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offerings
     * const offerings = await prisma.offering.findMany()
     * 
     * // Get first 10 Offerings
     * const offerings = await prisma.offering.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offeringWithIdOnly = await prisma.offering.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends offeringFindManyArgs>(args?: SelectSubset<T, offeringFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Offering.
     * @param {offeringCreateArgs} args - Arguments to create a Offering.
     * @example
     * // Create one Offering
     * const Offering = await prisma.offering.create({
     *   data: {
     *     // ... data to create a Offering
     *   }
     * })
     * 
     */
    create<T extends offeringCreateArgs>(args: SelectSubset<T, offeringCreateArgs<ExtArgs>>): Prisma__offeringClient<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Offerings.
     * @param {offeringCreateManyArgs} args - Arguments to create many Offerings.
     * @example
     * // Create many Offerings
     * const offering = await prisma.offering.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends offeringCreateManyArgs>(args?: SelectSubset<T, offeringCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offering.
     * @param {offeringDeleteArgs} args - Arguments to delete one Offering.
     * @example
     * // Delete one Offering
     * const Offering = await prisma.offering.delete({
     *   where: {
     *     // ... filter to delete one Offering
     *   }
     * })
     * 
     */
    delete<T extends offeringDeleteArgs>(args: SelectSubset<T, offeringDeleteArgs<ExtArgs>>): Prisma__offeringClient<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Offering.
     * @param {offeringUpdateArgs} args - Arguments to update one Offering.
     * @example
     * // Update one Offering
     * const offering = await prisma.offering.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends offeringUpdateArgs>(args: SelectSubset<T, offeringUpdateArgs<ExtArgs>>): Prisma__offeringClient<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Offerings.
     * @param {offeringDeleteManyArgs} args - Arguments to filter Offerings to delete.
     * @example
     * // Delete a few Offerings
     * const { count } = await prisma.offering.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends offeringDeleteManyArgs>(args?: SelectSubset<T, offeringDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offeringUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offerings
     * const offering = await prisma.offering.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends offeringUpdateManyArgs>(args: SelectSubset<T, offeringUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offering.
     * @param {offeringUpsertArgs} args - Arguments to update or create a Offering.
     * @example
     * // Update or create a Offering
     * const offering = await prisma.offering.upsert({
     *   create: {
     *     // ... data to create a Offering
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offering we want to update
     *   }
     * })
     */
    upsert<T extends offeringUpsertArgs>(args: SelectSubset<T, offeringUpsertArgs<ExtArgs>>): Prisma__offeringClient<$Result.GetResult<Prisma.$offeringPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Offerings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offeringCountArgs} args - Arguments to filter Offerings to count.
     * @example
     * // Count the number of Offerings
     * const count = await prisma.offering.count({
     *   where: {
     *     // ... the filter for the Offerings we want to count
     *   }
     * })
    **/
    count<T extends offeringCountArgs>(
      args?: Subset<T, offeringCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferingAggregateArgs>(args: Subset<T, OfferingAggregateArgs>): Prisma.PrismaPromise<GetOfferingAggregateType<T>>

    /**
     * Group by Offering.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offeringGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends offeringGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: offeringGroupByArgs['orderBy'] }
        : { orderBy?: offeringGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, offeringGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the offering model
   */
  readonly fields: offeringFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for offering.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__offeringClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    issuer<T extends issuerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, issuerDefaultArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the offering model
   */ 
  interface offeringFieldRefs {
    readonly id: FieldRef<"offering", 'Int'>
    readonly issuer_id: FieldRef<"offering", 'Int'>
    readonly name: FieldRef<"offering", 'String'>
    readonly description: FieldRef<"offering", 'String'>
    readonly target_amount: FieldRef<"offering", 'Decimal'>
    readonly minimum_investment: FieldRef<"offering", 'Decimal'>
    readonly start_date: FieldRef<"offering", 'DateTime'>
    readonly end_date: FieldRef<"offering", 'DateTime'>
    readonly status: FieldRef<"offering", 'String'>
    readonly created_at: FieldRef<"offering", 'DateTime'>
    readonly updated_at: FieldRef<"offering", 'DateTime'>
    readonly documents: FieldRef<"offering", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * offering findUnique
   */
  export type offeringFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    /**
     * Filter, which offering to fetch.
     */
    where: offeringWhereUniqueInput
  }

  /**
   * offering findUniqueOrThrow
   */
  export type offeringFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    /**
     * Filter, which offering to fetch.
     */
    where: offeringWhereUniqueInput
  }

  /**
   * offering findFirst
   */
  export type offeringFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    /**
     * Filter, which offering to fetch.
     */
    where?: offeringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offerings to fetch.
     */
    orderBy?: offeringOrderByWithRelationInput | offeringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offerings.
     */
    cursor?: offeringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offerings.
     */
    distinct?: OfferingScalarFieldEnum | OfferingScalarFieldEnum[]
  }

  /**
   * offering findFirstOrThrow
   */
  export type offeringFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    /**
     * Filter, which offering to fetch.
     */
    where?: offeringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offerings to fetch.
     */
    orderBy?: offeringOrderByWithRelationInput | offeringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offerings.
     */
    cursor?: offeringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offerings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offerings.
     */
    distinct?: OfferingScalarFieldEnum | OfferingScalarFieldEnum[]
  }

  /**
   * offering findMany
   */
  export type offeringFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    /**
     * Filter, which offerings to fetch.
     */
    where?: offeringWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offerings to fetch.
     */
    orderBy?: offeringOrderByWithRelationInput | offeringOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing offerings.
     */
    cursor?: offeringWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offerings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offerings.
     */
    skip?: number
    distinct?: OfferingScalarFieldEnum | OfferingScalarFieldEnum[]
  }

  /**
   * offering create
   */
  export type offeringCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    /**
     * The data needed to create a offering.
     */
    data: XOR<offeringCreateInput, offeringUncheckedCreateInput>
  }

  /**
   * offering createMany
   */
  export type offeringCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many offerings.
     */
    data: offeringCreateManyInput | offeringCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * offering update
   */
  export type offeringUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    /**
     * The data needed to update a offering.
     */
    data: XOR<offeringUpdateInput, offeringUncheckedUpdateInput>
    /**
     * Choose, which offering to update.
     */
    where: offeringWhereUniqueInput
  }

  /**
   * offering updateMany
   */
  export type offeringUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update offerings.
     */
    data: XOR<offeringUpdateManyMutationInput, offeringUncheckedUpdateManyInput>
    /**
     * Filter which offerings to update
     */
    where?: offeringWhereInput
  }

  /**
   * offering upsert
   */
  export type offeringUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    /**
     * The filter to search for the offering to update in case it exists.
     */
    where: offeringWhereUniqueInput
    /**
     * In case the offering found by the `where` argument doesn't exist, create a new offering with this data.
     */
    create: XOR<offeringCreateInput, offeringUncheckedCreateInput>
    /**
     * In case the offering was found with the provided `where` argument, update it with this data.
     */
    update: XOR<offeringUpdateInput, offeringUncheckedUpdateInput>
  }

  /**
   * offering delete
   */
  export type offeringDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
    /**
     * Filter which offering to delete.
     */
    where: offeringWhereUniqueInput
  }

  /**
   * offering deleteMany
   */
  export type offeringDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offerings to delete
     */
    where?: offeringWhereInput
  }

  /**
   * offering without action
   */
  export type offeringDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offering
     */
    select?: offeringSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offeringInclude<ExtArgs> | null
  }


  /**
   * Model refreshtoken
   */

  export type AggregateRefreshtoken = {
    _count: RefreshtokenCountAggregateOutputType | null
    _avg: RefreshtokenAvgAggregateOutputType | null
    _sum: RefreshtokenSumAggregateOutputType | null
    _min: RefreshtokenMinAggregateOutputType | null
    _max: RefreshtokenMaxAggregateOutputType | null
  }

  export type RefreshtokenAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type RefreshtokenSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type RefreshtokenMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    token: string | null
    expires_at: Date | null
    created_at: Date | null
    device_info: string | null
  }

  export type RefreshtokenMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    token: string | null
    expires_at: Date | null
    created_at: Date | null
    device_info: string | null
  }

  export type RefreshtokenCountAggregateOutputType = {
    id: number
    user_id: number
    token: number
    expires_at: number
    created_at: number
    device_info: number
    _all: number
  }


  export type RefreshtokenAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type RefreshtokenSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type RefreshtokenMinAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    device_info?: true
  }

  export type RefreshtokenMaxAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    device_info?: true
  }

  export type RefreshtokenCountAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    expires_at?: true
    created_at?: true
    device_info?: true
    _all?: true
  }

  export type RefreshtokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refreshtoken to aggregate.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned refreshtokens
    **/
    _count?: true | RefreshtokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshtokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshtokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshtokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshtokenMaxAggregateInputType
  }

  export type GetRefreshtokenAggregateType<T extends RefreshtokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshtoken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshtoken[P]>
      : GetScalarType<T[P], AggregateRefreshtoken[P]>
  }




  export type refreshtokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: refreshtokenWhereInput
    orderBy?: refreshtokenOrderByWithAggregationInput | refreshtokenOrderByWithAggregationInput[]
    by: RefreshtokenScalarFieldEnum[] | RefreshtokenScalarFieldEnum
    having?: refreshtokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshtokenCountAggregateInputType | true
    _avg?: RefreshtokenAvgAggregateInputType
    _sum?: RefreshtokenSumAggregateInputType
    _min?: RefreshtokenMinAggregateInputType
    _max?: RefreshtokenMaxAggregateInputType
  }

  export type RefreshtokenGroupByOutputType = {
    id: number
    user_id: number
    token: string
    expires_at: Date
    created_at: Date
    device_info: string | null
    _count: RefreshtokenCountAggregateOutputType | null
    _avg: RefreshtokenAvgAggregateOutputType | null
    _sum: RefreshtokenSumAggregateOutputType | null
    _min: RefreshtokenMinAggregateOutputType | null
    _max: RefreshtokenMaxAggregateOutputType | null
  }

  type GetRefreshtokenGroupByPayload<T extends refreshtokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshtokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshtokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshtokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshtokenGroupByOutputType[P]>
        }
      >
    >


  export type refreshtokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
    device_info?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshtoken"]>


  export type refreshtokenSelectScalar = {
    id?: boolean
    user_id?: boolean
    token?: boolean
    expires_at?: boolean
    created_at?: boolean
    device_info?: boolean
  }

  export type refreshtokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $refreshtokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "refreshtoken"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      token: string
      expires_at: Date
      created_at: Date
      device_info: string | null
    }, ExtArgs["result"]["refreshtoken"]>
    composites: {}
  }

  type refreshtokenGetPayload<S extends boolean | null | undefined | refreshtokenDefaultArgs> = $Result.GetResult<Prisma.$refreshtokenPayload, S>

  type refreshtokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<refreshtokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshtokenCountAggregateInputType | true
    }

  export interface refreshtokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['refreshtoken'], meta: { name: 'refreshtoken' } }
    /**
     * Find zero or one Refreshtoken that matches the filter.
     * @param {refreshtokenFindUniqueArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends refreshtokenFindUniqueArgs>(args: SelectSubset<T, refreshtokenFindUniqueArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Refreshtoken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {refreshtokenFindUniqueOrThrowArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends refreshtokenFindUniqueOrThrowArgs>(args: SelectSubset<T, refreshtokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Refreshtoken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindFirstArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends refreshtokenFindFirstArgs>(args?: SelectSubset<T, refreshtokenFindFirstArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Refreshtoken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindFirstOrThrowArgs} args - Arguments to find a Refreshtoken
     * @example
     * // Get one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends refreshtokenFindFirstOrThrowArgs>(args?: SelectSubset<T, refreshtokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Refreshtokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refreshtokens
     * const refreshtokens = await prisma.refreshtoken.findMany()
     * 
     * // Get first 10 Refreshtokens
     * const refreshtokens = await prisma.refreshtoken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshtokenWithIdOnly = await prisma.refreshtoken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends refreshtokenFindManyArgs>(args?: SelectSubset<T, refreshtokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Refreshtoken.
     * @param {refreshtokenCreateArgs} args - Arguments to create a Refreshtoken.
     * @example
     * // Create one Refreshtoken
     * const Refreshtoken = await prisma.refreshtoken.create({
     *   data: {
     *     // ... data to create a Refreshtoken
     *   }
     * })
     * 
     */
    create<T extends refreshtokenCreateArgs>(args: SelectSubset<T, refreshtokenCreateArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Refreshtokens.
     * @param {refreshtokenCreateManyArgs} args - Arguments to create many Refreshtokens.
     * @example
     * // Create many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends refreshtokenCreateManyArgs>(args?: SelectSubset<T, refreshtokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Refreshtoken.
     * @param {refreshtokenDeleteArgs} args - Arguments to delete one Refreshtoken.
     * @example
     * // Delete one Refreshtoken
     * const Refreshtoken = await prisma.refreshtoken.delete({
     *   where: {
     *     // ... filter to delete one Refreshtoken
     *   }
     * })
     * 
     */
    delete<T extends refreshtokenDeleteArgs>(args: SelectSubset<T, refreshtokenDeleteArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Refreshtoken.
     * @param {refreshtokenUpdateArgs} args - Arguments to update one Refreshtoken.
     * @example
     * // Update one Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends refreshtokenUpdateArgs>(args: SelectSubset<T, refreshtokenUpdateArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Refreshtokens.
     * @param {refreshtokenDeleteManyArgs} args - Arguments to filter Refreshtokens to delete.
     * @example
     * // Delete a few Refreshtokens
     * const { count } = await prisma.refreshtoken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends refreshtokenDeleteManyArgs>(args?: SelectSubset<T, refreshtokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refreshtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refreshtokens
     * const refreshtoken = await prisma.refreshtoken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends refreshtokenUpdateManyArgs>(args: SelectSubset<T, refreshtokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refreshtoken.
     * @param {refreshtokenUpsertArgs} args - Arguments to update or create a Refreshtoken.
     * @example
     * // Update or create a Refreshtoken
     * const refreshtoken = await prisma.refreshtoken.upsert({
     *   create: {
     *     // ... data to create a Refreshtoken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refreshtoken we want to update
     *   }
     * })
     */
    upsert<T extends refreshtokenUpsertArgs>(args: SelectSubset<T, refreshtokenUpsertArgs<ExtArgs>>): Prisma__refreshtokenClient<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Refreshtokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenCountArgs} args - Arguments to filter Refreshtokens to count.
     * @example
     * // Count the number of Refreshtokens
     * const count = await prisma.refreshtoken.count({
     *   where: {
     *     // ... the filter for the Refreshtokens we want to count
     *   }
     * })
    **/
    count<T extends refreshtokenCountArgs>(
      args?: Subset<T, refreshtokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshtokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refreshtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshtokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshtokenAggregateArgs>(args: Subset<T, RefreshtokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshtokenAggregateType<T>>

    /**
     * Group by Refreshtoken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {refreshtokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends refreshtokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: refreshtokenGroupByArgs['orderBy'] }
        : { orderBy?: refreshtokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, refreshtokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshtokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the refreshtoken model
   */
  readonly fields: refreshtokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for refreshtoken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__refreshtokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the refreshtoken model
   */ 
  interface refreshtokenFieldRefs {
    readonly id: FieldRef<"refreshtoken", 'Int'>
    readonly user_id: FieldRef<"refreshtoken", 'Int'>
    readonly token: FieldRef<"refreshtoken", 'String'>
    readonly expires_at: FieldRef<"refreshtoken", 'DateTime'>
    readonly created_at: FieldRef<"refreshtoken", 'DateTime'>
    readonly device_info: FieldRef<"refreshtoken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * refreshtoken findUnique
   */
  export type refreshtokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken findUniqueOrThrow
   */
  export type refreshtokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken findFirst
   */
  export type refreshtokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refreshtokens.
     */
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken findFirstOrThrow
   */
  export type refreshtokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtoken to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of refreshtokens.
     */
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken findMany
   */
  export type refreshtokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter, which refreshtokens to fetch.
     */
    where?: refreshtokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of refreshtokens to fetch.
     */
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing refreshtokens.
     */
    cursor?: refreshtokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` refreshtokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` refreshtokens.
     */
    skip?: number
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * refreshtoken create
   */
  export type refreshtokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The data needed to create a refreshtoken.
     */
    data: XOR<refreshtokenCreateInput, refreshtokenUncheckedCreateInput>
  }

  /**
   * refreshtoken createMany
   */
  export type refreshtokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many refreshtokens.
     */
    data: refreshtokenCreateManyInput | refreshtokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * refreshtoken update
   */
  export type refreshtokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The data needed to update a refreshtoken.
     */
    data: XOR<refreshtokenUpdateInput, refreshtokenUncheckedUpdateInput>
    /**
     * Choose, which refreshtoken to update.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken updateMany
   */
  export type refreshtokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update refreshtokens.
     */
    data: XOR<refreshtokenUpdateManyMutationInput, refreshtokenUncheckedUpdateManyInput>
    /**
     * Filter which refreshtokens to update
     */
    where?: refreshtokenWhereInput
  }

  /**
   * refreshtoken upsert
   */
  export type refreshtokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * The filter to search for the refreshtoken to update in case it exists.
     */
    where: refreshtokenWhereUniqueInput
    /**
     * In case the refreshtoken found by the `where` argument doesn't exist, create a new refreshtoken with this data.
     */
    create: XOR<refreshtokenCreateInput, refreshtokenUncheckedCreateInput>
    /**
     * In case the refreshtoken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<refreshtokenUpdateInput, refreshtokenUncheckedUpdateInput>
  }

  /**
   * refreshtoken delete
   */
  export type refreshtokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    /**
     * Filter which refreshtoken to delete.
     */
    where: refreshtokenWhereUniqueInput
  }

  /**
   * refreshtoken deleteMany
   */
  export type refreshtokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which refreshtokens to delete
     */
    where?: refreshtokenWhereInput
  }

  /**
   * refreshtoken without action
   */
  export type refreshtokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password_hash: string | null
    first_name: string | null
    last_name: string | null
    created_at: Date | null
    updated_at: Date | null
    email_verified: boolean | null
    profile_image: string | null
    phone_number: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password_hash: string | null
    first_name: string | null
    last_name: string | null
    created_at: Date | null
    updated_at: Date | null
    email_verified: boolean | null
    profile_image: string | null
    phone_number: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    first_name: number
    last_name: number
    created_at: number
    updated_at: number
    email_verified: number
    profile_image: number
    phone_number: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    first_name?: true
    last_name?: true
    created_at?: true
    updated_at?: true
    email_verified?: true
    profile_image?: true
    phone_number?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    first_name?: true
    last_name?: true
    created_at?: true
    updated_at?: true
    email_verified?: true
    profile_image?: true
    phone_number?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    first_name?: true
    last_name?: true
    created_at?: true
    updated_at?: true
    email_verified?: true
    profile_image?: true
    phone_number?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password_hash: string | null
    first_name: string
    last_name: string
    created_at: Date
    updated_at: Date
    email_verified: boolean
    profile_image: string | null
    phone_number: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    first_name?: boolean
    last_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_verified?: boolean
    profile_image?: boolean
    phone_number?: boolean
    admin?: boolean | user$adminArgs<ExtArgs>
    authprovider?: boolean | user$authproviderArgs<ExtArgs>
    didwallet?: boolean | user$didwalletArgs<ExtArgs>
    investor?: boolean | user$investorArgs<ExtArgs>
    issuer?: boolean | user$issuerArgs<ExtArgs>
    refreshtoken?: boolean | user$refreshtokenArgs<ExtArgs>
    userrole?: boolean | user$userroleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type userSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    first_name?: boolean
    last_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    email_verified?: boolean
    profile_image?: boolean
    phone_number?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | user$adminArgs<ExtArgs>
    authprovider?: boolean | user$authproviderArgs<ExtArgs>
    didwallet?: boolean | user$didwalletArgs<ExtArgs>
    investor?: boolean | user$investorArgs<ExtArgs>
    issuer?: boolean | user$issuerArgs<ExtArgs>
    refreshtoken?: boolean | user$refreshtokenArgs<ExtArgs>
    userrole?: boolean | user$userroleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs> | null
      authprovider: Prisma.$authproviderPayload<ExtArgs>[]
      didwallet: Prisma.$didwalletPayload<ExtArgs>[]
      investor: Prisma.$investorPayload<ExtArgs> | null
      issuer: Prisma.$issuerPayload<ExtArgs> | null
      refreshtoken: Prisma.$refreshtokenPayload<ExtArgs>[]
      userrole: Prisma.$userrolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password_hash: string | null
      first_name: string
      last_name: string
      created_at: Date
      updated_at: Date
      email_verified: boolean
      profile_image: string | null
      phone_number: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends user$adminArgs<ExtArgs> = {}>(args?: Subset<T, user$adminArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    authprovider<T extends user$authproviderArgs<ExtArgs> = {}>(args?: Subset<T, user$authproviderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authproviderPayload<ExtArgs>, T, "findMany"> | Null>
    didwallet<T extends user$didwalletArgs<ExtArgs> = {}>(args?: Subset<T, user$didwalletArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$didwalletPayload<ExtArgs>, T, "findMany"> | Null>
    investor<T extends user$investorArgs<ExtArgs> = {}>(args?: Subset<T, user$investorArgs<ExtArgs>>): Prisma__investorClient<$Result.GetResult<Prisma.$investorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    issuer<T extends user$issuerArgs<ExtArgs> = {}>(args?: Subset<T, user$issuerArgs<ExtArgs>>): Prisma__issuerClient<$Result.GetResult<Prisma.$issuerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    refreshtoken<T extends user$refreshtokenArgs<ExtArgs> = {}>(args?: Subset<T, user$refreshtokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$refreshtokenPayload<ExtArgs>, T, "findMany"> | Null>
    userrole<T extends user$userroleArgs<ExtArgs> = {}>(args?: Subset<T, user$userroleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly email: FieldRef<"user", 'String'>
    readonly password_hash: FieldRef<"user", 'String'>
    readonly first_name: FieldRef<"user", 'String'>
    readonly last_name: FieldRef<"user", 'String'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
    readonly email_verified: FieldRef<"user", 'Boolean'>
    readonly profile_image: FieldRef<"user", 'String'>
    readonly phone_number: FieldRef<"user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }

  /**
   * user.admin
   */
  export type user$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
  }

  /**
   * user.authprovider
   */
  export type user$authproviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authprovider
     */
    select?: authproviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authproviderInclude<ExtArgs> | null
    where?: authproviderWhereInput
    orderBy?: authproviderOrderByWithRelationInput | authproviderOrderByWithRelationInput[]
    cursor?: authproviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthproviderScalarFieldEnum | AuthproviderScalarFieldEnum[]
  }

  /**
   * user.didwallet
   */
  export type user$didwalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the didwallet
     */
    select?: didwalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: didwalletInclude<ExtArgs> | null
    where?: didwalletWhereInput
    orderBy?: didwalletOrderByWithRelationInput | didwalletOrderByWithRelationInput[]
    cursor?: didwalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DidwalletScalarFieldEnum | DidwalletScalarFieldEnum[]
  }

  /**
   * user.investor
   */
  export type user$investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the investor
     */
    select?: investorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: investorInclude<ExtArgs> | null
    where?: investorWhereInput
  }

  /**
   * user.issuer
   */
  export type user$issuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the issuer
     */
    select?: issuerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: issuerInclude<ExtArgs> | null
    where?: issuerWhereInput
  }

  /**
   * user.refreshtoken
   */
  export type user$refreshtokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the refreshtoken
     */
    select?: refreshtokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: refreshtokenInclude<ExtArgs> | null
    where?: refreshtokenWhereInput
    orderBy?: refreshtokenOrderByWithRelationInput | refreshtokenOrderByWithRelationInput[]
    cursor?: refreshtokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshtokenScalarFieldEnum | RefreshtokenScalarFieldEnum[]
  }

  /**
   * user.userrole
   */
  export type user$userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model userrole
   */

  export type AggregateUserrole = {
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  export type UserroleAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserroleSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type UserroleMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    role: string | null
    created_at: Date | null
  }

  export type UserroleMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    role: string | null
    created_at: Date | null
  }

  export type UserroleCountAggregateOutputType = {
    id: number
    user_id: number
    role: number
    created_at: number
    _all: number
  }


  export type UserroleAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserroleSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type UserroleMinAggregateInputType = {
    id?: true
    user_id?: true
    role?: true
    created_at?: true
  }

  export type UserroleMaxAggregateInputType = {
    id?: true
    user_id?: true
    role?: true
    created_at?: true
  }

  export type UserroleCountAggregateInputType = {
    id?: true
    user_id?: true
    role?: true
    created_at?: true
    _all?: true
  }

  export type UserroleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userrole to aggregate.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userroles
    **/
    _count?: true | UserroleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserroleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserroleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserroleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserroleMaxAggregateInputType
  }

  export type GetUserroleAggregateType<T extends UserroleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserrole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserrole[P]>
      : GetScalarType<T[P], AggregateUserrole[P]>
  }




  export type userroleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithAggregationInput | userroleOrderByWithAggregationInput[]
    by: UserroleScalarFieldEnum[] | UserroleScalarFieldEnum
    having?: userroleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserroleCountAggregateInputType | true
    _avg?: UserroleAvgAggregateInputType
    _sum?: UserroleSumAggregateInputType
    _min?: UserroleMinAggregateInputType
    _max?: UserroleMaxAggregateInputType
  }

  export type UserroleGroupByOutputType = {
    id: number
    user_id: number
    role: string
    created_at: Date
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  type GetUserroleGroupByPayload<T extends userroleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserroleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserroleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserroleGroupByOutputType[P]>
            : GetScalarType<T[P], UserroleGroupByOutputType[P]>
        }
      >
    >


  export type userroleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    role?: boolean
    created_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>


  export type userroleSelectScalar = {
    id?: boolean
    user_id?: boolean
    role?: boolean
    created_at?: boolean
  }

  export type userroleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userrolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userrole"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      role: string
      created_at: Date
    }, ExtArgs["result"]["userrole"]>
    composites: {}
  }

  type userroleGetPayload<S extends boolean | null | undefined | userroleDefaultArgs> = $Result.GetResult<Prisma.$userrolePayload, S>

  type userroleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<userroleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserroleCountAggregateInputType | true
    }

  export interface userroleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userrole'], meta: { name: 'userrole' } }
    /**
     * Find zero or one Userrole that matches the filter.
     * @param {userroleFindUniqueArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userroleFindUniqueArgs>(args: SelectSubset<T, userroleFindUniqueArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Userrole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {userroleFindUniqueOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userroleFindUniqueOrThrowArgs>(args: SelectSubset<T, userroleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Userrole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userroleFindFirstArgs>(args?: SelectSubset<T, userroleFindFirstArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Userrole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userroleFindFirstOrThrowArgs>(args?: SelectSubset<T, userroleFindFirstOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Userroles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userroles
     * const userroles = await prisma.userrole.findMany()
     * 
     * // Get first 10 Userroles
     * const userroles = await prisma.userrole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userroleWithIdOnly = await prisma.userrole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userroleFindManyArgs>(args?: SelectSubset<T, userroleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Userrole.
     * @param {userroleCreateArgs} args - Arguments to create a Userrole.
     * @example
     * // Create one Userrole
     * const Userrole = await prisma.userrole.create({
     *   data: {
     *     // ... data to create a Userrole
     *   }
     * })
     * 
     */
    create<T extends userroleCreateArgs>(args: SelectSubset<T, userroleCreateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Userroles.
     * @param {userroleCreateManyArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userroleCreateManyArgs>(args?: SelectSubset<T, userroleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userrole.
     * @param {userroleDeleteArgs} args - Arguments to delete one Userrole.
     * @example
     * // Delete one Userrole
     * const Userrole = await prisma.userrole.delete({
     *   where: {
     *     // ... filter to delete one Userrole
     *   }
     * })
     * 
     */
    delete<T extends userroleDeleteArgs>(args: SelectSubset<T, userroleDeleteArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Userrole.
     * @param {userroleUpdateArgs} args - Arguments to update one Userrole.
     * @example
     * // Update one Userrole
     * const userrole = await prisma.userrole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userroleUpdateArgs>(args: SelectSubset<T, userroleUpdateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Userroles.
     * @param {userroleDeleteManyArgs} args - Arguments to filter Userroles to delete.
     * @example
     * // Delete a few Userroles
     * const { count } = await prisma.userrole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userroleDeleteManyArgs>(args?: SelectSubset<T, userroleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userroleUpdateManyArgs>(args: SelectSubset<T, userroleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userrole.
     * @param {userroleUpsertArgs} args - Arguments to update or create a Userrole.
     * @example
     * // Update or create a Userrole
     * const userrole = await prisma.userrole.upsert({
     *   create: {
     *     // ... data to create a Userrole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userrole we want to update
     *   }
     * })
     */
    upsert<T extends userroleUpsertArgs>(args: SelectSubset<T, userroleUpsertArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleCountArgs} args - Arguments to filter Userroles to count.
     * @example
     * // Count the number of Userroles
     * const count = await prisma.userrole.count({
     *   where: {
     *     // ... the filter for the Userroles we want to count
     *   }
     * })
    **/
    count<T extends userroleCountArgs>(
      args?: Subset<T, userroleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserroleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserroleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserroleAggregateArgs>(args: Subset<T, UserroleAggregateArgs>): Prisma.PrismaPromise<GetUserroleAggregateType<T>>

    /**
     * Group by Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userroleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userroleGroupByArgs['orderBy'] }
        : { orderBy?: userroleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userroleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserroleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userrole model
   */
  readonly fields: userroleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userrole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userroleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userrole model
   */ 
  interface userroleFieldRefs {
    readonly id: FieldRef<"userrole", 'Int'>
    readonly user_id: FieldRef<"userrole", 'Int'>
    readonly role: FieldRef<"userrole", 'String'>
    readonly created_at: FieldRef<"userrole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userrole findUnique
   */
  export type userroleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findUniqueOrThrow
   */
  export type userroleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findFirst
   */
  export type userroleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findFirstOrThrow
   */
  export type userroleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findMany
   */
  export type userroleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userroles to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole create
   */
  export type userroleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to create a userrole.
     */
    data: XOR<userroleCreateInput, userroleUncheckedCreateInput>
  }

  /**
   * userrole createMany
   */
  export type userroleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userrole update
   */
  export type userroleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to update a userrole.
     */
    data: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
    /**
     * Choose, which userrole to update.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole updateMany
   */
  export type userroleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
  }

  /**
   * userrole upsert
   */
  export type userroleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The filter to search for the userrole to update in case it exists.
     */
    where: userroleWhereUniqueInput
    /**
     * In case the userrole found by the `where` argument doesn't exist, create a new userrole with this data.
     */
    create: XOR<userroleCreateInput, userroleUncheckedCreateInput>
    /**
     * In case the userrole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
  }

  /**
   * userrole delete
   */
  export type userroleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter which userrole to delete.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole deleteMany
   */
  export type userroleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroles to delete
     */
    where?: userroleWhereInput
  }

  /**
   * userrole without action
   */
  export type userroleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    department: 'department',
    position: 'position',
    last_login: 'last_login'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const AuthproviderScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    provider_name: 'provider_name',
    provider_user_id: 'provider_user_id',
    provider_data: 'provider_data',
    created_at: 'created_at',
    last_used: 'last_used'
  };

  export type AuthproviderScalarFieldEnum = (typeof AuthproviderScalarFieldEnum)[keyof typeof AuthproviderScalarFieldEnum]


  export const DidwalletScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    wallet_address: 'wallet_address',
    did: 'did',
    is_primary: 'is_primary',
    created_at: 'created_at',
    last_used: 'last_used'
  };

  export type DidwalletScalarFieldEnum = (typeof DidwalletScalarFieldEnum)[keyof typeof DidwalletScalarFieldEnum]


  export const InvestorScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    investor_type: 'investor_type',
    accreditation_status: 'accreditation_status',
    accreditation_date: 'accreditation_date',
    kyc_documents: 'kyc_documents',
    aml_documents: 'aml_documents',
    kyc_verified: 'kyc_verified',
    aml_verified: 'aml_verified'
  };

  export type InvestorScalarFieldEnum = (typeof InvestorScalarFieldEnum)[keyof typeof InvestorScalarFieldEnum]


  export const IssuerScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    company_name: 'company_name',
    company_registration_number: 'company_registration_number',
    jurisdiction: 'jurisdiction',
    verification_status: 'verification_status',
    verification_date: 'verification_date',
    company_documents: 'company_documents',
    created_at: 'created_at',
    updated_at: 'updated_at',
    wallet_address: 'wallet_address',
    wallet_created_at: 'wallet_created_at',
    ethereum_address: 'ethereum_address',
    ethereum_wallet_created_at: 'ethereum_wallet_created_at',
    solana_address: 'solana_address',
    solana_wallet_created_at: 'solana_wallet_created_at'
  };

  export type IssuerScalarFieldEnum = (typeof IssuerScalarFieldEnum)[keyof typeof IssuerScalarFieldEnum]


  export const OfferingScalarFieldEnum: {
    id: 'id',
    issuer_id: 'issuer_id',
    name: 'name',
    description: 'description',
    target_amount: 'target_amount',
    minimum_investment: 'minimum_investment',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    documents: 'documents'
  };

  export type OfferingScalarFieldEnum = (typeof OfferingScalarFieldEnum)[keyof typeof OfferingScalarFieldEnum]


  export const RefreshtokenScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token: 'token',
    expires_at: 'expires_at',
    created_at: 'created_at',
    device_info: 'device_info'
  };

  export type RefreshtokenScalarFieldEnum = (typeof RefreshtokenScalarFieldEnum)[keyof typeof RefreshtokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    first_name: 'first_name',
    last_name: 'last_name',
    created_at: 'created_at',
    updated_at: 'updated_at',
    email_verified: 'email_verified',
    profile_image: 'profile_image',
    phone_number: 'phone_number'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserroleScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    role: 'role',
    created_at: 'created_at'
  };

  export type UserroleScalarFieldEnum = (typeof UserroleScalarFieldEnum)[keyof typeof UserroleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    id?: IntFilter<"admin"> | number
    user_id?: IntFilter<"admin"> | number
    department?: StringFilter<"admin"> | string
    position?: StringFilter<"admin"> | string
    last_login?: DateTimeNullableFilter<"admin"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type adminOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    department?: StringFilter<"admin"> | string
    position?: StringFilter<"admin"> | string
    last_login?: DateTimeNullableFilter<"admin"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "user_id">

  export type adminOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrderInput | SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin"> | number
    user_id?: IntWithAggregatesFilter<"admin"> | number
    department?: StringWithAggregatesFilter<"admin"> | string
    position?: StringWithAggregatesFilter<"admin"> | string
    last_login?: DateTimeNullableWithAggregatesFilter<"admin"> | Date | string | null
  }

  export type authproviderWhereInput = {
    AND?: authproviderWhereInput | authproviderWhereInput[]
    OR?: authproviderWhereInput[]
    NOT?: authproviderWhereInput | authproviderWhereInput[]
    id?: IntFilter<"authprovider"> | number
    user_id?: IntFilter<"authprovider"> | number
    provider_name?: StringFilter<"authprovider"> | string
    provider_user_id?: StringFilter<"authprovider"> | string
    provider_data?: JsonNullableFilter<"authprovider">
    created_at?: DateTimeFilter<"authprovider"> | Date | string
    last_used?: DateTimeFilter<"authprovider"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type authproviderOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    provider_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type authproviderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: authproviderWhereInput | authproviderWhereInput[]
    OR?: authproviderWhereInput[]
    NOT?: authproviderWhereInput | authproviderWhereInput[]
    user_id?: IntFilter<"authprovider"> | number
    provider_name?: StringFilter<"authprovider"> | string
    provider_user_id?: StringFilter<"authprovider"> | string
    provider_data?: JsonNullableFilter<"authprovider">
    created_at?: DateTimeFilter<"authprovider"> | Date | string
    last_used?: DateTimeFilter<"authprovider"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type authproviderOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    provider_data?: SortOrderInput | SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    _count?: authproviderCountOrderByAggregateInput
    _avg?: authproviderAvgOrderByAggregateInput
    _max?: authproviderMaxOrderByAggregateInput
    _min?: authproviderMinOrderByAggregateInput
    _sum?: authproviderSumOrderByAggregateInput
  }

  export type authproviderScalarWhereWithAggregatesInput = {
    AND?: authproviderScalarWhereWithAggregatesInput | authproviderScalarWhereWithAggregatesInput[]
    OR?: authproviderScalarWhereWithAggregatesInput[]
    NOT?: authproviderScalarWhereWithAggregatesInput | authproviderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"authprovider"> | number
    user_id?: IntWithAggregatesFilter<"authprovider"> | number
    provider_name?: StringWithAggregatesFilter<"authprovider"> | string
    provider_user_id?: StringWithAggregatesFilter<"authprovider"> | string
    provider_data?: JsonNullableWithAggregatesFilter<"authprovider">
    created_at?: DateTimeWithAggregatesFilter<"authprovider"> | Date | string
    last_used?: DateTimeWithAggregatesFilter<"authprovider"> | Date | string
  }

  export type didwalletWhereInput = {
    AND?: didwalletWhereInput | didwalletWhereInput[]
    OR?: didwalletWhereInput[]
    NOT?: didwalletWhereInput | didwalletWhereInput[]
    id?: IntFilter<"didwallet"> | number
    user_id?: IntFilter<"didwallet"> | number
    wallet_address?: StringFilter<"didwallet"> | string
    did?: StringFilter<"didwallet"> | string
    is_primary?: BoolFilter<"didwallet"> | boolean
    created_at?: DateTimeFilter<"didwallet"> | Date | string
    last_used?: DateTimeFilter<"didwallet"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type didwalletOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type didwalletWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: didwalletWhereInput | didwalletWhereInput[]
    OR?: didwalletWhereInput[]
    NOT?: didwalletWhereInput | didwalletWhereInput[]
    user_id?: IntFilter<"didwallet"> | number
    wallet_address?: StringFilter<"didwallet"> | string
    did?: StringFilter<"didwallet"> | string
    is_primary?: BoolFilter<"didwallet"> | boolean
    created_at?: DateTimeFilter<"didwallet"> | Date | string
    last_used?: DateTimeFilter<"didwallet"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type didwalletOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
    _count?: didwalletCountOrderByAggregateInput
    _avg?: didwalletAvgOrderByAggregateInput
    _max?: didwalletMaxOrderByAggregateInput
    _min?: didwalletMinOrderByAggregateInput
    _sum?: didwalletSumOrderByAggregateInput
  }

  export type didwalletScalarWhereWithAggregatesInput = {
    AND?: didwalletScalarWhereWithAggregatesInput | didwalletScalarWhereWithAggregatesInput[]
    OR?: didwalletScalarWhereWithAggregatesInput[]
    NOT?: didwalletScalarWhereWithAggregatesInput | didwalletScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"didwallet"> | number
    user_id?: IntWithAggregatesFilter<"didwallet"> | number
    wallet_address?: StringWithAggregatesFilter<"didwallet"> | string
    did?: StringWithAggregatesFilter<"didwallet"> | string
    is_primary?: BoolWithAggregatesFilter<"didwallet"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"didwallet"> | Date | string
    last_used?: DateTimeWithAggregatesFilter<"didwallet"> | Date | string
  }

  export type investorWhereInput = {
    AND?: investorWhereInput | investorWhereInput[]
    OR?: investorWhereInput[]
    NOT?: investorWhereInput | investorWhereInput[]
    id?: IntFilter<"investor"> | number
    user_id?: IntFilter<"investor"> | number
    investor_type?: StringFilter<"investor"> | string
    accreditation_status?: StringFilter<"investor"> | string
    accreditation_date?: DateTimeNullableFilter<"investor"> | Date | string | null
    kyc_documents?: JsonNullableFilter<"investor">
    aml_documents?: JsonNullableFilter<"investor">
    kyc_verified?: BoolFilter<"investor"> | boolean
    aml_verified?: BoolFilter<"investor"> | boolean
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type investorOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrderInput | SortOrder
    kyc_documents?: SortOrderInput | SortOrder
    aml_documents?: SortOrderInput | SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type investorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: investorWhereInput | investorWhereInput[]
    OR?: investorWhereInput[]
    NOT?: investorWhereInput | investorWhereInput[]
    investor_type?: StringFilter<"investor"> | string
    accreditation_status?: StringFilter<"investor"> | string
    accreditation_date?: DateTimeNullableFilter<"investor"> | Date | string | null
    kyc_documents?: JsonNullableFilter<"investor">
    aml_documents?: JsonNullableFilter<"investor">
    kyc_verified?: BoolFilter<"investor"> | boolean
    aml_verified?: BoolFilter<"investor"> | boolean
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "user_id">

  export type investorOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrderInput | SortOrder
    kyc_documents?: SortOrderInput | SortOrder
    aml_documents?: SortOrderInput | SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
    _count?: investorCountOrderByAggregateInput
    _avg?: investorAvgOrderByAggregateInput
    _max?: investorMaxOrderByAggregateInput
    _min?: investorMinOrderByAggregateInput
    _sum?: investorSumOrderByAggregateInput
  }

  export type investorScalarWhereWithAggregatesInput = {
    AND?: investorScalarWhereWithAggregatesInput | investorScalarWhereWithAggregatesInput[]
    OR?: investorScalarWhereWithAggregatesInput[]
    NOT?: investorScalarWhereWithAggregatesInput | investorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"investor"> | number
    user_id?: IntWithAggregatesFilter<"investor"> | number
    investor_type?: StringWithAggregatesFilter<"investor"> | string
    accreditation_status?: StringWithAggregatesFilter<"investor"> | string
    accreditation_date?: DateTimeNullableWithAggregatesFilter<"investor"> | Date | string | null
    kyc_documents?: JsonNullableWithAggregatesFilter<"investor">
    aml_documents?: JsonNullableWithAggregatesFilter<"investor">
    kyc_verified?: BoolWithAggregatesFilter<"investor"> | boolean
    aml_verified?: BoolWithAggregatesFilter<"investor"> | boolean
  }

  export type issuerWhereInput = {
    AND?: issuerWhereInput | issuerWhereInput[]
    OR?: issuerWhereInput[]
    NOT?: issuerWhereInput | issuerWhereInput[]
    id?: IntFilter<"issuer"> | number
    user_id?: IntFilter<"issuer"> | number
    company_name?: StringFilter<"issuer"> | string
    company_registration_number?: StringFilter<"issuer"> | string
    jurisdiction?: StringFilter<"issuer"> | string
    verification_status?: BoolFilter<"issuer"> | boolean
    verification_date?: DateTimeNullableFilter<"issuer"> | Date | string | null
    company_documents?: JsonNullableFilter<"issuer">
    created_at?: DateTimeFilter<"issuer"> | Date | string
    updated_at?: DateTimeFilter<"issuer"> | Date | string
    wallet_address?: StringNullableFilter<"issuer"> | string | null
    wallet_created_at?: DateTimeNullableFilter<"issuer"> | Date | string | null
    ethereum_address?: StringNullableFilter<"issuer"> | string | null
    ethereum_wallet_created_at?: DateTimeNullableFilter<"issuer"> | Date | string | null
    solana_address?: StringNullableFilter<"issuer"> | string | null
    solana_wallet_created_at?: DateTimeNullableFilter<"issuer"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    offering?: OfferingListRelationFilter
  }

  export type issuerOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrderInput | SortOrder
    company_documents?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    wallet_address?: SortOrderInput | SortOrder
    wallet_created_at?: SortOrderInput | SortOrder
    ethereum_address?: SortOrderInput | SortOrder
    ethereum_wallet_created_at?: SortOrderInput | SortOrder
    solana_address?: SortOrderInput | SortOrder
    solana_wallet_created_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    offering?: offeringOrderByRelationAggregateInput
  }

  export type issuerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: issuerWhereInput | issuerWhereInput[]
    OR?: issuerWhereInput[]
    NOT?: issuerWhereInput | issuerWhereInput[]
    company_name?: StringFilter<"issuer"> | string
    company_registration_number?: StringFilter<"issuer"> | string
    jurisdiction?: StringFilter<"issuer"> | string
    verification_status?: BoolFilter<"issuer"> | boolean
    verification_date?: DateTimeNullableFilter<"issuer"> | Date | string | null
    company_documents?: JsonNullableFilter<"issuer">
    created_at?: DateTimeFilter<"issuer"> | Date | string
    updated_at?: DateTimeFilter<"issuer"> | Date | string
    wallet_address?: StringNullableFilter<"issuer"> | string | null
    wallet_created_at?: DateTimeNullableFilter<"issuer"> | Date | string | null
    ethereum_address?: StringNullableFilter<"issuer"> | string | null
    ethereum_wallet_created_at?: DateTimeNullableFilter<"issuer"> | Date | string | null
    solana_address?: StringNullableFilter<"issuer"> | string | null
    solana_wallet_created_at?: DateTimeNullableFilter<"issuer"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    offering?: OfferingListRelationFilter
  }, "id" | "user_id">

  export type issuerOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrderInput | SortOrder
    company_documents?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    wallet_address?: SortOrderInput | SortOrder
    wallet_created_at?: SortOrderInput | SortOrder
    ethereum_address?: SortOrderInput | SortOrder
    ethereum_wallet_created_at?: SortOrderInput | SortOrder
    solana_address?: SortOrderInput | SortOrder
    solana_wallet_created_at?: SortOrderInput | SortOrder
    _count?: issuerCountOrderByAggregateInput
    _avg?: issuerAvgOrderByAggregateInput
    _max?: issuerMaxOrderByAggregateInput
    _min?: issuerMinOrderByAggregateInput
    _sum?: issuerSumOrderByAggregateInput
  }

  export type issuerScalarWhereWithAggregatesInput = {
    AND?: issuerScalarWhereWithAggregatesInput | issuerScalarWhereWithAggregatesInput[]
    OR?: issuerScalarWhereWithAggregatesInput[]
    NOT?: issuerScalarWhereWithAggregatesInput | issuerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"issuer"> | number
    user_id?: IntWithAggregatesFilter<"issuer"> | number
    company_name?: StringWithAggregatesFilter<"issuer"> | string
    company_registration_number?: StringWithAggregatesFilter<"issuer"> | string
    jurisdiction?: StringWithAggregatesFilter<"issuer"> | string
    verification_status?: BoolWithAggregatesFilter<"issuer"> | boolean
    verification_date?: DateTimeNullableWithAggregatesFilter<"issuer"> | Date | string | null
    company_documents?: JsonNullableWithAggregatesFilter<"issuer">
    created_at?: DateTimeWithAggregatesFilter<"issuer"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"issuer"> | Date | string
    wallet_address?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    wallet_created_at?: DateTimeNullableWithAggregatesFilter<"issuer"> | Date | string | null
    ethereum_address?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    ethereum_wallet_created_at?: DateTimeNullableWithAggregatesFilter<"issuer"> | Date | string | null
    solana_address?: StringNullableWithAggregatesFilter<"issuer"> | string | null
    solana_wallet_created_at?: DateTimeNullableWithAggregatesFilter<"issuer"> | Date | string | null
  }

  export type offeringWhereInput = {
    AND?: offeringWhereInput | offeringWhereInput[]
    OR?: offeringWhereInput[]
    NOT?: offeringWhereInput | offeringWhereInput[]
    id?: IntFilter<"offering"> | number
    issuer_id?: IntFilter<"offering"> | number
    name?: StringFilter<"offering"> | string
    description?: StringFilter<"offering"> | string
    target_amount?: DecimalFilter<"offering"> | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFilter<"offering"> | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFilter<"offering"> | Date | string
    end_date?: DateTimeFilter<"offering"> | Date | string
    status?: StringFilter<"offering"> | string
    created_at?: DateTimeFilter<"offering"> | Date | string
    updated_at?: DateTimeFilter<"offering"> | Date | string
    documents?: JsonNullableFilter<"offering">
    issuer?: XOR<IssuerRelationFilter, issuerWhereInput>
  }

  export type offeringOrderByWithRelationInput = {
    id?: SortOrder
    issuer_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    target_amount?: SortOrder
    minimum_investment?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    documents?: SortOrderInput | SortOrder
    issuer?: issuerOrderByWithRelationInput
  }

  export type offeringWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: offeringWhereInput | offeringWhereInput[]
    OR?: offeringWhereInput[]
    NOT?: offeringWhereInput | offeringWhereInput[]
    issuer_id?: IntFilter<"offering"> | number
    name?: StringFilter<"offering"> | string
    description?: StringFilter<"offering"> | string
    target_amount?: DecimalFilter<"offering"> | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFilter<"offering"> | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFilter<"offering"> | Date | string
    end_date?: DateTimeFilter<"offering"> | Date | string
    status?: StringFilter<"offering"> | string
    created_at?: DateTimeFilter<"offering"> | Date | string
    updated_at?: DateTimeFilter<"offering"> | Date | string
    documents?: JsonNullableFilter<"offering">
    issuer?: XOR<IssuerRelationFilter, issuerWhereInput>
  }, "id">

  export type offeringOrderByWithAggregationInput = {
    id?: SortOrder
    issuer_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    target_amount?: SortOrder
    minimum_investment?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    documents?: SortOrderInput | SortOrder
    _count?: offeringCountOrderByAggregateInput
    _avg?: offeringAvgOrderByAggregateInput
    _max?: offeringMaxOrderByAggregateInput
    _min?: offeringMinOrderByAggregateInput
    _sum?: offeringSumOrderByAggregateInput
  }

  export type offeringScalarWhereWithAggregatesInput = {
    AND?: offeringScalarWhereWithAggregatesInput | offeringScalarWhereWithAggregatesInput[]
    OR?: offeringScalarWhereWithAggregatesInput[]
    NOT?: offeringScalarWhereWithAggregatesInput | offeringScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"offering"> | number
    issuer_id?: IntWithAggregatesFilter<"offering"> | number
    name?: StringWithAggregatesFilter<"offering"> | string
    description?: StringWithAggregatesFilter<"offering"> | string
    target_amount?: DecimalWithAggregatesFilter<"offering"> | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalWithAggregatesFilter<"offering"> | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeWithAggregatesFilter<"offering"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"offering"> | Date | string
    status?: StringWithAggregatesFilter<"offering"> | string
    created_at?: DateTimeWithAggregatesFilter<"offering"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"offering"> | Date | string
    documents?: JsonNullableWithAggregatesFilter<"offering">
  }

  export type refreshtokenWhereInput = {
    AND?: refreshtokenWhereInput | refreshtokenWhereInput[]
    OR?: refreshtokenWhereInput[]
    NOT?: refreshtokenWhereInput | refreshtokenWhereInput[]
    id?: IntFilter<"refreshtoken"> | number
    user_id?: IntFilter<"refreshtoken"> | number
    token?: StringFilter<"refreshtoken"> | string
    expires_at?: DateTimeFilter<"refreshtoken"> | Date | string
    created_at?: DateTimeFilter<"refreshtoken"> | Date | string
    device_info?: StringNullableFilter<"refreshtoken"> | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type refreshtokenOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type refreshtokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: refreshtokenWhereInput | refreshtokenWhereInput[]
    OR?: refreshtokenWhereInput[]
    NOT?: refreshtokenWhereInput | refreshtokenWhereInput[]
    user_id?: IntFilter<"refreshtoken"> | number
    expires_at?: DateTimeFilter<"refreshtoken"> | Date | string
    created_at?: DateTimeFilter<"refreshtoken"> | Date | string
    device_info?: StringNullableFilter<"refreshtoken"> | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "token">

  export type refreshtokenOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrderInput | SortOrder
    _count?: refreshtokenCountOrderByAggregateInput
    _avg?: refreshtokenAvgOrderByAggregateInput
    _max?: refreshtokenMaxOrderByAggregateInput
    _min?: refreshtokenMinOrderByAggregateInput
    _sum?: refreshtokenSumOrderByAggregateInput
  }

  export type refreshtokenScalarWhereWithAggregatesInput = {
    AND?: refreshtokenScalarWhereWithAggregatesInput | refreshtokenScalarWhereWithAggregatesInput[]
    OR?: refreshtokenScalarWhereWithAggregatesInput[]
    NOT?: refreshtokenScalarWhereWithAggregatesInput | refreshtokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"refreshtoken"> | number
    user_id?: IntWithAggregatesFilter<"refreshtoken"> | number
    token?: StringWithAggregatesFilter<"refreshtoken"> | string
    expires_at?: DateTimeWithAggregatesFilter<"refreshtoken"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"refreshtoken"> | Date | string
    device_info?: StringNullableWithAggregatesFilter<"refreshtoken"> | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    email?: StringFilter<"user"> | string
    password_hash?: StringNullableFilter<"user"> | string | null
    first_name?: StringFilter<"user"> | string
    last_name?: StringFilter<"user"> | string
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    email_verified?: BoolFilter<"user"> | boolean
    profile_image?: StringNullableFilter<"user"> | string | null
    phone_number?: StringNullableFilter<"user"> | string | null
    admin?: XOR<AdminNullableRelationFilter, adminWhereInput> | null
    authprovider?: AuthproviderListRelationFilter
    didwallet?: DidwalletListRelationFilter
    investor?: XOR<InvestorNullableRelationFilter, investorWhereInput> | null
    issuer?: XOR<IssuerNullableRelationFilter, issuerWhereInput> | null
    refreshtoken?: RefreshtokenListRelationFilter
    userrole?: UserroleListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    admin?: adminOrderByWithRelationInput
    authprovider?: authproviderOrderByRelationAggregateInput
    didwallet?: didwalletOrderByRelationAggregateInput
    investor?: investorOrderByWithRelationInput
    issuer?: issuerOrderByWithRelationInput
    refreshtoken?: refreshtokenOrderByRelationAggregateInput
    userrole?: userroleOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password_hash?: StringNullableFilter<"user"> | string | null
    first_name?: StringFilter<"user"> | string
    last_name?: StringFilter<"user"> | string
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    email_verified?: BoolFilter<"user"> | boolean
    profile_image?: StringNullableFilter<"user"> | string | null
    phone_number?: StringNullableFilter<"user"> | string | null
    admin?: XOR<AdminNullableRelationFilter, adminWhereInput> | null
    authprovider?: AuthproviderListRelationFilter
    didwallet?: DidwalletListRelationFilter
    investor?: XOR<InvestorNullableRelationFilter, investorWhereInput> | null
    issuer?: XOR<IssuerNullableRelationFilter, issuerWhereInput> | null
    refreshtoken?: RefreshtokenListRelationFilter
    userrole?: UserroleListRelationFilter
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrder
    profile_image?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    email?: StringWithAggregatesFilter<"user"> | string
    password_hash?: StringNullableWithAggregatesFilter<"user"> | string | null
    first_name?: StringWithAggregatesFilter<"user"> | string
    last_name?: StringWithAggregatesFilter<"user"> | string
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    email_verified?: BoolWithAggregatesFilter<"user"> | boolean
    profile_image?: StringNullableWithAggregatesFilter<"user"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"user"> | string | null
  }

  export type userroleWhereInput = {
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    id?: IntFilter<"userrole"> | number
    user_id?: IntFilter<"userrole"> | number
    role?: StringFilter<"userrole"> | string
    created_at?: DateTimeFilter<"userrole"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type userroleOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type userroleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    user_id?: IntFilter<"userrole"> | number
    role?: StringFilter<"userrole"> | string
    created_at?: DateTimeFilter<"userrole"> | Date | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id">

  export type userroleOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    _count?: userroleCountOrderByAggregateInput
    _avg?: userroleAvgOrderByAggregateInput
    _max?: userroleMaxOrderByAggregateInput
    _min?: userroleMinOrderByAggregateInput
    _sum?: userroleSumOrderByAggregateInput
  }

  export type userroleScalarWhereWithAggregatesInput = {
    AND?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    OR?: userroleScalarWhereWithAggregatesInput[]
    NOT?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userrole"> | number
    user_id?: IntWithAggregatesFilter<"userrole"> | number
    role?: StringWithAggregatesFilter<"userrole"> | string
    created_at?: DateTimeWithAggregatesFilter<"userrole"> | Date | string
  }

  export type adminCreateInput = {
    department: string
    position: string
    last_login?: Date | string | null
    user: userCreateNestedOneWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    id?: number
    user_id: number
    department: string
    position: string
    last_login?: Date | string | null
  }

  export type adminUpdateInput = {
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminCreateManyInput = {
    id?: number
    user_id: number
    department: string
    position: string
    last_login?: Date | string | null
  }

  export type adminUpdateManyMutationInput = {
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type authproviderCreateInput = {
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
    user: userCreateNestedOneWithoutAuthproviderInput
  }

  export type authproviderUncheckedCreateInput = {
    id?: number
    user_id: number
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type authproviderUpdateInput = {
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutAuthproviderNestedInput
  }

  export type authproviderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authproviderCreateManyInput = {
    id?: number
    user_id: number
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type authproviderUpdateManyMutationInput = {
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authproviderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletCreateInput = {
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
    user: userCreateNestedOneWithoutDidwalletInput
  }

  export type didwalletUncheckedCreateInput = {
    id?: number
    user_id: number
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletUpdateInput = {
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutDidwalletNestedInput
  }

  export type didwalletUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletCreateManyInput = {
    id?: number
    user_id: number
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletUpdateManyMutationInput = {
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type investorCreateInput = {
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
    user: userCreateNestedOneWithoutInvestorInput
  }

  export type investorUncheckedCreateInput = {
    id?: number
    user_id: number
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorUpdateInput = {
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
    user?: userUpdateOneRequiredWithoutInvestorNestedInput
  }

  export type investorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type investorCreateManyInput = {
    id?: number
    user_id: number
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorUpdateManyMutationInput = {
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type investorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type issuerCreateInput = {
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    wallet_address?: string | null
    wallet_created_at?: Date | string | null
    ethereum_address?: string | null
    ethereum_wallet_created_at?: Date | string | null
    solana_address?: string | null
    solana_wallet_created_at?: Date | string | null
    user: userCreateNestedOneWithoutIssuerInput
    offering?: offeringCreateNestedManyWithoutIssuerInput
  }

  export type issuerUncheckedCreateInput = {
    id?: number
    user_id: number
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    wallet_address?: string | null
    wallet_created_at?: Date | string | null
    ethereum_address?: string | null
    ethereum_wallet_created_at?: Date | string | null
    solana_address?: string | null
    solana_wallet_created_at?: Date | string | null
    offering?: offeringUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type issuerUpdateInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ethereum_address?: NullableStringFieldUpdateOperationsInput | string | null
    ethereum_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solana_address?: NullableStringFieldUpdateOperationsInput | string | null
    solana_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutIssuerNestedInput
    offering?: offeringUpdateManyWithoutIssuerNestedInput
  }

  export type issuerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ethereum_address?: NullableStringFieldUpdateOperationsInput | string | null
    ethereum_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solana_address?: NullableStringFieldUpdateOperationsInput | string | null
    solana_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offering?: offeringUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type issuerCreateManyInput = {
    id?: number
    user_id: number
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    wallet_address?: string | null
    wallet_created_at?: Date | string | null
    ethereum_address?: string | null
    ethereum_wallet_created_at?: Date | string | null
    solana_address?: string | null
    solana_wallet_created_at?: Date | string | null
  }

  export type issuerUpdateManyMutationInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ethereum_address?: NullableStringFieldUpdateOperationsInput | string | null
    ethereum_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solana_address?: NullableStringFieldUpdateOperationsInput | string | null
    solana_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type issuerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ethereum_address?: NullableStringFieldUpdateOperationsInput | string | null
    ethereum_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solana_address?: NullableStringFieldUpdateOperationsInput | string | null
    solana_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offeringCreateInput = {
    name: string
    description: string
    target_amount: Decimal | DecimalJsLike | number | string
    minimum_investment: Decimal | DecimalJsLike | number | string
    start_date: Date | string
    end_date: Date | string
    status?: string
    created_at?: Date | string
    updated_at: Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
    issuer: issuerCreateNestedOneWithoutOfferingInput
  }

  export type offeringUncheckedCreateInput = {
    id?: number
    issuer_id: number
    name: string
    description: string
    target_amount: Decimal | DecimalJsLike | number | string
    minimum_investment: Decimal | DecimalJsLike | number | string
    start_date: Date | string
    end_date: Date | string
    status?: string
    created_at?: Date | string
    updated_at: Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type offeringUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    target_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
    issuer?: issuerUpdateOneRequiredWithoutOfferingNestedInput
  }

  export type offeringUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    issuer_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    target_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type offeringCreateManyInput = {
    id?: number
    issuer_id: number
    name: string
    description: string
    target_amount: Decimal | DecimalJsLike | number | string
    minimum_investment: Decimal | DecimalJsLike | number | string
    start_date: Date | string
    end_date: Date | string
    status?: string
    created_at?: Date | string
    updated_at: Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type offeringUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    target_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type offeringUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    issuer_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    target_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type refreshtokenCreateInput = {
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
    user: userCreateNestedOneWithoutRefreshtokenInput
  }

  export type refreshtokenUncheckedCreateInput = {
    id?: number
    user_id: number
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type refreshtokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutRefreshtokenNestedInput
  }

  export type refreshtokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refreshtokenCreateManyInput = {
    id?: number
    user_id: number
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type refreshtokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refreshtokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateInput = {
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    authprovider?: authproviderCreateNestedManyWithoutUserInput
    didwallet?: didwalletCreateNestedManyWithoutUserInput
    investor?: investorCreateNestedOneWithoutUserInput
    issuer?: issuerCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUserInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUserInput
    investor?: investorUncheckedCreateNestedOneWithoutUserInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUpdateManyWithoutUserNestedInput
    investor?: investorUpdateOneWithoutUserNestedInput
    issuer?: issuerUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUserNestedInput
    investor?: investorUncheckedUpdateOneWithoutUserNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userroleCreateInput = {
    role: string
    created_at?: Date | string
    user: userCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateInput = {
    id?: number
    user_id: number
    role: string
    created_at?: Date | string
  }

  export type userroleUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroleCreateManyInput = {
    id?: number
    user_id: number
    role: string
    created_at?: Date | string
  }

  export type userroleUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type adminCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    department?: SortOrder
    position?: SortOrder
    last_login?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type authproviderCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    provider_data?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type authproviderAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type authproviderMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type authproviderMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    provider_name?: SortOrder
    provider_user_id?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type authproviderSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type didwalletCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type didwalletAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type didwalletMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type didwalletMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    wallet_address?: SortOrder
    did?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    last_used?: SortOrder
  }

  export type didwalletSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type investorCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrder
    kyc_documents?: SortOrder
    aml_documents?: SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
  }

  export type investorAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type investorMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
  }

  export type investorMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    investor_type?: SortOrder
    accreditation_status?: SortOrder
    accreditation_date?: SortOrder
    kyc_verified?: SortOrder
    aml_verified?: SortOrder
  }

  export type investorSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type OfferingListRelationFilter = {
    every?: offeringWhereInput
    some?: offeringWhereInput
    none?: offeringWhereInput
  }

  export type offeringOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type issuerCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrder
    company_documents?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    wallet_address?: SortOrder
    wallet_created_at?: SortOrder
    ethereum_address?: SortOrder
    ethereum_wallet_created_at?: SortOrder
    solana_address?: SortOrder
    solana_wallet_created_at?: SortOrder
  }

  export type issuerAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type issuerMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    wallet_address?: SortOrder
    wallet_created_at?: SortOrder
    ethereum_address?: SortOrder
    ethereum_wallet_created_at?: SortOrder
    solana_address?: SortOrder
    solana_wallet_created_at?: SortOrder
  }

  export type issuerMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    company_name?: SortOrder
    company_registration_number?: SortOrder
    jurisdiction?: SortOrder
    verification_status?: SortOrder
    verification_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    wallet_address?: SortOrder
    wallet_created_at?: SortOrder
    ethereum_address?: SortOrder
    ethereum_wallet_created_at?: SortOrder
    solana_address?: SortOrder
    solana_wallet_created_at?: SortOrder
  }

  export type issuerSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IssuerRelationFilter = {
    is?: issuerWhereInput
    isNot?: issuerWhereInput
  }

  export type offeringCountOrderByAggregateInput = {
    id?: SortOrder
    issuer_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    target_amount?: SortOrder
    minimum_investment?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    documents?: SortOrder
  }

  export type offeringAvgOrderByAggregateInput = {
    id?: SortOrder
    issuer_id?: SortOrder
    target_amount?: SortOrder
    minimum_investment?: SortOrder
  }

  export type offeringMaxOrderByAggregateInput = {
    id?: SortOrder
    issuer_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    target_amount?: SortOrder
    minimum_investment?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type offeringMinOrderByAggregateInput = {
    id?: SortOrder
    issuer_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    target_amount?: SortOrder
    minimum_investment?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type offeringSumOrderByAggregateInput = {
    id?: SortOrder
    issuer_id?: SortOrder
    target_amount?: SortOrder
    minimum_investment?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type refreshtokenCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrder
  }

  export type refreshtokenAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type refreshtokenMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrder
  }

  export type refreshtokenMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
    device_info?: SortOrder
  }

  export type refreshtokenSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type AdminNullableRelationFilter = {
    is?: adminWhereInput | null
    isNot?: adminWhereInput | null
  }

  export type AuthproviderListRelationFilter = {
    every?: authproviderWhereInput
    some?: authproviderWhereInput
    none?: authproviderWhereInput
  }

  export type DidwalletListRelationFilter = {
    every?: didwalletWhereInput
    some?: didwalletWhereInput
    none?: didwalletWhereInput
  }

  export type InvestorNullableRelationFilter = {
    is?: investorWhereInput | null
    isNot?: investorWhereInput | null
  }

  export type IssuerNullableRelationFilter = {
    is?: issuerWhereInput | null
    isNot?: issuerWhereInput | null
  }

  export type RefreshtokenListRelationFilter = {
    every?: refreshtokenWhereInput
    some?: refreshtokenWhereInput
    none?: refreshtokenWhereInput
  }

  export type UserroleListRelationFilter = {
    every?: userroleWhereInput
    some?: userroleWhereInput
    none?: userroleWhereInput
  }

  export type authproviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type didwalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type refreshtokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userroleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrder
    profile_image?: SortOrder
    phone_number?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrder
    profile_image?: SortOrder
    phone_number?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_verified?: SortOrder
    profile_image?: SortOrder
    phone_number?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userroleCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type userroleAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type userroleMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type userroleMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type userroleSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type userCreateNestedOneWithoutAdminInput = {
    create?: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
    connectOrCreate?: userCreateOrConnectWithoutAdminInput
    connect?: userWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type userUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
    connectOrCreate?: userCreateOrConnectWithoutAdminInput
    upsert?: userUpsertWithoutAdminInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAdminInput, userUpdateWithoutAdminInput>, userUncheckedUpdateWithoutAdminInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type userCreateNestedOneWithoutAuthproviderInput = {
    create?: XOR<userCreateWithoutAuthproviderInput, userUncheckedCreateWithoutAuthproviderInput>
    connectOrCreate?: userCreateOrConnectWithoutAuthproviderInput
    connect?: userWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type userUpdateOneRequiredWithoutAuthproviderNestedInput = {
    create?: XOR<userCreateWithoutAuthproviderInput, userUncheckedCreateWithoutAuthproviderInput>
    connectOrCreate?: userCreateOrConnectWithoutAuthproviderInput
    upsert?: userUpsertWithoutAuthproviderInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAuthproviderInput, userUpdateWithoutAuthproviderInput>, userUncheckedUpdateWithoutAuthproviderInput>
  }

  export type userCreateNestedOneWithoutDidwalletInput = {
    create?: XOR<userCreateWithoutDidwalletInput, userUncheckedCreateWithoutDidwalletInput>
    connectOrCreate?: userCreateOrConnectWithoutDidwalletInput
    connect?: userWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type userUpdateOneRequiredWithoutDidwalletNestedInput = {
    create?: XOR<userCreateWithoutDidwalletInput, userUncheckedCreateWithoutDidwalletInput>
    connectOrCreate?: userCreateOrConnectWithoutDidwalletInput
    upsert?: userUpsertWithoutDidwalletInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutDidwalletInput, userUpdateWithoutDidwalletInput>, userUncheckedUpdateWithoutDidwalletInput>
  }

  export type userCreateNestedOneWithoutInvestorInput = {
    create?: XOR<userCreateWithoutInvestorInput, userUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: userCreateOrConnectWithoutInvestorInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutInvestorNestedInput = {
    create?: XOR<userCreateWithoutInvestorInput, userUncheckedCreateWithoutInvestorInput>
    connectOrCreate?: userCreateOrConnectWithoutInvestorInput
    upsert?: userUpsertWithoutInvestorInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutInvestorInput, userUpdateWithoutInvestorInput>, userUncheckedUpdateWithoutInvestorInput>
  }

  export type userCreateNestedOneWithoutIssuerInput = {
    create?: XOR<userCreateWithoutIssuerInput, userUncheckedCreateWithoutIssuerInput>
    connectOrCreate?: userCreateOrConnectWithoutIssuerInput
    connect?: userWhereUniqueInput
  }

  export type offeringCreateNestedManyWithoutIssuerInput = {
    create?: XOR<offeringCreateWithoutIssuerInput, offeringUncheckedCreateWithoutIssuerInput> | offeringCreateWithoutIssuerInput[] | offeringUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: offeringCreateOrConnectWithoutIssuerInput | offeringCreateOrConnectWithoutIssuerInput[]
    createMany?: offeringCreateManyIssuerInputEnvelope
    connect?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
  }

  export type offeringUncheckedCreateNestedManyWithoutIssuerInput = {
    create?: XOR<offeringCreateWithoutIssuerInput, offeringUncheckedCreateWithoutIssuerInput> | offeringCreateWithoutIssuerInput[] | offeringUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: offeringCreateOrConnectWithoutIssuerInput | offeringCreateOrConnectWithoutIssuerInput[]
    createMany?: offeringCreateManyIssuerInputEnvelope
    connect?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type userUpdateOneRequiredWithoutIssuerNestedInput = {
    create?: XOR<userCreateWithoutIssuerInput, userUncheckedCreateWithoutIssuerInput>
    connectOrCreate?: userCreateOrConnectWithoutIssuerInput
    upsert?: userUpsertWithoutIssuerInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutIssuerInput, userUpdateWithoutIssuerInput>, userUncheckedUpdateWithoutIssuerInput>
  }

  export type offeringUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<offeringCreateWithoutIssuerInput, offeringUncheckedCreateWithoutIssuerInput> | offeringCreateWithoutIssuerInput[] | offeringUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: offeringCreateOrConnectWithoutIssuerInput | offeringCreateOrConnectWithoutIssuerInput[]
    upsert?: offeringUpsertWithWhereUniqueWithoutIssuerInput | offeringUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: offeringCreateManyIssuerInputEnvelope
    set?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
    disconnect?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
    delete?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
    connect?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
    update?: offeringUpdateWithWhereUniqueWithoutIssuerInput | offeringUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: offeringUpdateManyWithWhereWithoutIssuerInput | offeringUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: offeringScalarWhereInput | offeringScalarWhereInput[]
  }

  export type offeringUncheckedUpdateManyWithoutIssuerNestedInput = {
    create?: XOR<offeringCreateWithoutIssuerInput, offeringUncheckedCreateWithoutIssuerInput> | offeringCreateWithoutIssuerInput[] | offeringUncheckedCreateWithoutIssuerInput[]
    connectOrCreate?: offeringCreateOrConnectWithoutIssuerInput | offeringCreateOrConnectWithoutIssuerInput[]
    upsert?: offeringUpsertWithWhereUniqueWithoutIssuerInput | offeringUpsertWithWhereUniqueWithoutIssuerInput[]
    createMany?: offeringCreateManyIssuerInputEnvelope
    set?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
    disconnect?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
    delete?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
    connect?: offeringWhereUniqueInput | offeringWhereUniqueInput[]
    update?: offeringUpdateWithWhereUniqueWithoutIssuerInput | offeringUpdateWithWhereUniqueWithoutIssuerInput[]
    updateMany?: offeringUpdateManyWithWhereWithoutIssuerInput | offeringUpdateManyWithWhereWithoutIssuerInput[]
    deleteMany?: offeringScalarWhereInput | offeringScalarWhereInput[]
  }

  export type issuerCreateNestedOneWithoutOfferingInput = {
    create?: XOR<issuerCreateWithoutOfferingInput, issuerUncheckedCreateWithoutOfferingInput>
    connectOrCreate?: issuerCreateOrConnectWithoutOfferingInput
    connect?: issuerWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type issuerUpdateOneRequiredWithoutOfferingNestedInput = {
    create?: XOR<issuerCreateWithoutOfferingInput, issuerUncheckedCreateWithoutOfferingInput>
    connectOrCreate?: issuerCreateOrConnectWithoutOfferingInput
    upsert?: issuerUpsertWithoutOfferingInput
    connect?: issuerWhereUniqueInput
    update?: XOR<XOR<issuerUpdateToOneWithWhereWithoutOfferingInput, issuerUpdateWithoutOfferingInput>, issuerUncheckedUpdateWithoutOfferingInput>
  }

  export type userCreateNestedOneWithoutRefreshtokenInput = {
    create?: XOR<userCreateWithoutRefreshtokenInput, userUncheckedCreateWithoutRefreshtokenInput>
    connectOrCreate?: userCreateOrConnectWithoutRefreshtokenInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutRefreshtokenNestedInput = {
    create?: XOR<userCreateWithoutRefreshtokenInput, userUncheckedCreateWithoutRefreshtokenInput>
    connectOrCreate?: userCreateOrConnectWithoutRefreshtokenInput
    upsert?: userUpsertWithoutRefreshtokenInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRefreshtokenInput, userUpdateWithoutRefreshtokenInput>, userUncheckedUpdateWithoutRefreshtokenInput>
  }

  export type adminCreateNestedOneWithoutUserInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    connectOrCreate?: adminCreateOrConnectWithoutUserInput
    connect?: adminWhereUniqueInput
  }

  export type authproviderCreateNestedManyWithoutUserInput = {
    create?: XOR<authproviderCreateWithoutUserInput, authproviderUncheckedCreateWithoutUserInput> | authproviderCreateWithoutUserInput[] | authproviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: authproviderCreateOrConnectWithoutUserInput | authproviderCreateOrConnectWithoutUserInput[]
    createMany?: authproviderCreateManyUserInputEnvelope
    connect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
  }

  export type didwalletCreateNestedManyWithoutUserInput = {
    create?: XOR<didwalletCreateWithoutUserInput, didwalletUncheckedCreateWithoutUserInput> | didwalletCreateWithoutUserInput[] | didwalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: didwalletCreateOrConnectWithoutUserInput | didwalletCreateOrConnectWithoutUserInput[]
    createMany?: didwalletCreateManyUserInputEnvelope
    connect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
  }

  export type investorCreateNestedOneWithoutUserInput = {
    create?: XOR<investorCreateWithoutUserInput, investorUncheckedCreateWithoutUserInput>
    connectOrCreate?: investorCreateOrConnectWithoutUserInput
    connect?: investorWhereUniqueInput
  }

  export type issuerCreateNestedOneWithoutUserInput = {
    create?: XOR<issuerCreateWithoutUserInput, issuerUncheckedCreateWithoutUserInput>
    connectOrCreate?: issuerCreateOrConnectWithoutUserInput
    connect?: issuerWhereUniqueInput
  }

  export type refreshtokenCreateNestedManyWithoutUserInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
  }

  export type userroleCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type adminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    connectOrCreate?: adminCreateOrConnectWithoutUserInput
    connect?: adminWhereUniqueInput
  }

  export type authproviderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<authproviderCreateWithoutUserInput, authproviderUncheckedCreateWithoutUserInput> | authproviderCreateWithoutUserInput[] | authproviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: authproviderCreateOrConnectWithoutUserInput | authproviderCreateOrConnectWithoutUserInput[]
    createMany?: authproviderCreateManyUserInputEnvelope
    connect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
  }

  export type didwalletUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<didwalletCreateWithoutUserInput, didwalletUncheckedCreateWithoutUserInput> | didwalletCreateWithoutUserInput[] | didwalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: didwalletCreateOrConnectWithoutUserInput | didwalletCreateOrConnectWithoutUserInput[]
    createMany?: didwalletCreateManyUserInputEnvelope
    connect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
  }

  export type investorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<investorCreateWithoutUserInput, investorUncheckedCreateWithoutUserInput>
    connectOrCreate?: investorCreateOrConnectWithoutUserInput
    connect?: investorWhereUniqueInput
  }

  export type issuerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<issuerCreateWithoutUserInput, issuerUncheckedCreateWithoutUserInput>
    connectOrCreate?: issuerCreateOrConnectWithoutUserInput
    connect?: issuerWhereUniqueInput
  }

  export type refreshtokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type adminUpdateOneWithoutUserNestedInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    connectOrCreate?: adminCreateOrConnectWithoutUserInput
    upsert?: adminUpsertWithoutUserInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUserInput, adminUpdateWithoutUserInput>, adminUncheckedUpdateWithoutUserInput>
  }

  export type authproviderUpdateManyWithoutUserNestedInput = {
    create?: XOR<authproviderCreateWithoutUserInput, authproviderUncheckedCreateWithoutUserInput> | authproviderCreateWithoutUserInput[] | authproviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: authproviderCreateOrConnectWithoutUserInput | authproviderCreateOrConnectWithoutUserInput[]
    upsert?: authproviderUpsertWithWhereUniqueWithoutUserInput | authproviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: authproviderCreateManyUserInputEnvelope
    set?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    disconnect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    delete?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    connect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    update?: authproviderUpdateWithWhereUniqueWithoutUserInput | authproviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: authproviderUpdateManyWithWhereWithoutUserInput | authproviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: authproviderScalarWhereInput | authproviderScalarWhereInput[]
  }

  export type didwalletUpdateManyWithoutUserNestedInput = {
    create?: XOR<didwalletCreateWithoutUserInput, didwalletUncheckedCreateWithoutUserInput> | didwalletCreateWithoutUserInput[] | didwalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: didwalletCreateOrConnectWithoutUserInput | didwalletCreateOrConnectWithoutUserInput[]
    upsert?: didwalletUpsertWithWhereUniqueWithoutUserInput | didwalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: didwalletCreateManyUserInputEnvelope
    set?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    disconnect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    delete?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    connect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    update?: didwalletUpdateWithWhereUniqueWithoutUserInput | didwalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: didwalletUpdateManyWithWhereWithoutUserInput | didwalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: didwalletScalarWhereInput | didwalletScalarWhereInput[]
  }

  export type investorUpdateOneWithoutUserNestedInput = {
    create?: XOR<investorCreateWithoutUserInput, investorUncheckedCreateWithoutUserInput>
    connectOrCreate?: investorCreateOrConnectWithoutUserInput
    upsert?: investorUpsertWithoutUserInput
    disconnect?: investorWhereInput | boolean
    delete?: investorWhereInput | boolean
    connect?: investorWhereUniqueInput
    update?: XOR<XOR<investorUpdateToOneWithWhereWithoutUserInput, investorUpdateWithoutUserInput>, investorUncheckedUpdateWithoutUserInput>
  }

  export type issuerUpdateOneWithoutUserNestedInput = {
    create?: XOR<issuerCreateWithoutUserInput, issuerUncheckedCreateWithoutUserInput>
    connectOrCreate?: issuerCreateOrConnectWithoutUserInput
    upsert?: issuerUpsertWithoutUserInput
    disconnect?: issuerWhereInput | boolean
    delete?: issuerWhereInput | boolean
    connect?: issuerWhereUniqueInput
    update?: XOR<XOR<issuerUpdateToOneWithWhereWithoutUserInput, issuerUpdateWithoutUserInput>, issuerUncheckedUpdateWithoutUserInput>
  }

  export type refreshtokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    upsert?: refreshtokenUpsertWithWhereUniqueWithoutUserInput | refreshtokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    set?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    disconnect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    delete?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    update?: refreshtokenUpdateWithWhereUniqueWithoutUserInput | refreshtokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: refreshtokenUpdateManyWithWhereWithoutUserInput | refreshtokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
  }

  export type userroleUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type adminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    connectOrCreate?: adminCreateOrConnectWithoutUserInput
    upsert?: adminUpsertWithoutUserInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUserInput, adminUpdateWithoutUserInput>, adminUncheckedUpdateWithoutUserInput>
  }

  export type authproviderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<authproviderCreateWithoutUserInput, authproviderUncheckedCreateWithoutUserInput> | authproviderCreateWithoutUserInput[] | authproviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: authproviderCreateOrConnectWithoutUserInput | authproviderCreateOrConnectWithoutUserInput[]
    upsert?: authproviderUpsertWithWhereUniqueWithoutUserInput | authproviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: authproviderCreateManyUserInputEnvelope
    set?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    disconnect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    delete?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    connect?: authproviderWhereUniqueInput | authproviderWhereUniqueInput[]
    update?: authproviderUpdateWithWhereUniqueWithoutUserInput | authproviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: authproviderUpdateManyWithWhereWithoutUserInput | authproviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: authproviderScalarWhereInput | authproviderScalarWhereInput[]
  }

  export type didwalletUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<didwalletCreateWithoutUserInput, didwalletUncheckedCreateWithoutUserInput> | didwalletCreateWithoutUserInput[] | didwalletUncheckedCreateWithoutUserInput[]
    connectOrCreate?: didwalletCreateOrConnectWithoutUserInput | didwalletCreateOrConnectWithoutUserInput[]
    upsert?: didwalletUpsertWithWhereUniqueWithoutUserInput | didwalletUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: didwalletCreateManyUserInputEnvelope
    set?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    disconnect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    delete?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    connect?: didwalletWhereUniqueInput | didwalletWhereUniqueInput[]
    update?: didwalletUpdateWithWhereUniqueWithoutUserInput | didwalletUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: didwalletUpdateManyWithWhereWithoutUserInput | didwalletUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: didwalletScalarWhereInput | didwalletScalarWhereInput[]
  }

  export type investorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<investorCreateWithoutUserInput, investorUncheckedCreateWithoutUserInput>
    connectOrCreate?: investorCreateOrConnectWithoutUserInput
    upsert?: investorUpsertWithoutUserInput
    disconnect?: investorWhereInput | boolean
    delete?: investorWhereInput | boolean
    connect?: investorWhereUniqueInput
    update?: XOR<XOR<investorUpdateToOneWithWhereWithoutUserInput, investorUpdateWithoutUserInput>, investorUncheckedUpdateWithoutUserInput>
  }

  export type issuerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<issuerCreateWithoutUserInput, issuerUncheckedCreateWithoutUserInput>
    connectOrCreate?: issuerCreateOrConnectWithoutUserInput
    upsert?: issuerUpsertWithoutUserInput
    disconnect?: issuerWhereInput | boolean
    delete?: issuerWhereInput | boolean
    connect?: issuerWhereUniqueInput
    update?: XOR<XOR<issuerUpdateToOneWithWhereWithoutUserInput, issuerUpdateWithoutUserInput>, issuerUncheckedUpdateWithoutUserInput>
  }

  export type refreshtokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput> | refreshtokenCreateWithoutUserInput[] | refreshtokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: refreshtokenCreateOrConnectWithoutUserInput | refreshtokenCreateOrConnectWithoutUserInput[]
    upsert?: refreshtokenUpsertWithWhereUniqueWithoutUserInput | refreshtokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: refreshtokenCreateManyUserInputEnvelope
    set?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    disconnect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    delete?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    connect?: refreshtokenWhereUniqueInput | refreshtokenWhereUniqueInput[]
    update?: refreshtokenUpdateWithWhereUniqueWithoutUserInput | refreshtokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: refreshtokenUpdateManyWithWhereWithoutUserInput | refreshtokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutUserroleInput = {
    create?: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: userCreateOrConnectWithoutUserroleInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutUserroleNestedInput = {
    create?: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: userCreateOrConnectWithoutUserroleInput
    upsert?: userUpsertWithoutUserroleInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserroleInput, userUpdateWithoutUserroleInput>, userUncheckedUpdateWithoutUserroleInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type userCreateWithoutAdminInput = {
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    authprovider?: authproviderCreateNestedManyWithoutUserInput
    didwallet?: didwalletCreateNestedManyWithoutUserInput
    investor?: investorCreateNestedOneWithoutUserInput
    issuer?: issuerCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAdminInput = {
    id?: number
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUserInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUserInput
    investor?: investorUncheckedCreateNestedOneWithoutUserInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAdminInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
  }

  export type userUpsertWithoutAdminInput = {
    update: XOR<userUpdateWithoutAdminInput, userUncheckedUpdateWithoutAdminInput>
    create: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAdminInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAdminInput, userUncheckedUpdateWithoutAdminInput>
  }

  export type userUpdateWithoutAdminInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    authprovider?: authproviderUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUpdateManyWithoutUserNestedInput
    investor?: investorUpdateOneWithoutUserNestedInput
    issuer?: issuerUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    authprovider?: authproviderUncheckedUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUserNestedInput
    investor?: investorUncheckedUpdateOneWithoutUserNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutAuthproviderInput = {
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    didwallet?: didwalletCreateNestedManyWithoutUserInput
    investor?: investorCreateNestedOneWithoutUserInput
    issuer?: issuerCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAuthproviderInput = {
    id?: number
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUserInput
    investor?: investorUncheckedCreateNestedOneWithoutUserInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAuthproviderInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAuthproviderInput, userUncheckedCreateWithoutAuthproviderInput>
  }

  export type userUpsertWithoutAuthproviderInput = {
    update: XOR<userUpdateWithoutAuthproviderInput, userUncheckedUpdateWithoutAuthproviderInput>
    create: XOR<userCreateWithoutAuthproviderInput, userUncheckedCreateWithoutAuthproviderInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAuthproviderInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAuthproviderInput, userUncheckedUpdateWithoutAuthproviderInput>
  }

  export type userUpdateWithoutAuthproviderInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    didwallet?: didwalletUpdateManyWithoutUserNestedInput
    investor?: investorUpdateOneWithoutUserNestedInput
    issuer?: issuerUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAuthproviderInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUserNestedInput
    investor?: investorUncheckedUpdateOneWithoutUserNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutDidwalletInput = {
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    authprovider?: authproviderCreateNestedManyWithoutUserInput
    investor?: investorCreateNestedOneWithoutUserInput
    issuer?: issuerCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutDidwalletInput = {
    id?: number
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUserInput
    investor?: investorUncheckedCreateNestedOneWithoutUserInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutDidwalletInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutDidwalletInput, userUncheckedCreateWithoutDidwalletInput>
  }

  export type userUpsertWithoutDidwalletInput = {
    update: XOR<userUpdateWithoutDidwalletInput, userUncheckedUpdateWithoutDidwalletInput>
    create: XOR<userCreateWithoutDidwalletInput, userUncheckedCreateWithoutDidwalletInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutDidwalletInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutDidwalletInput, userUncheckedUpdateWithoutDidwalletInput>
  }

  export type userUpdateWithoutDidwalletInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUpdateManyWithoutUserNestedInput
    investor?: investorUpdateOneWithoutUserNestedInput
    issuer?: issuerUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutDidwalletInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUserNestedInput
    investor?: investorUncheckedUpdateOneWithoutUserNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutInvestorInput = {
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    authprovider?: authproviderCreateNestedManyWithoutUserInput
    didwallet?: didwalletCreateNestedManyWithoutUserInput
    issuer?: issuerCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutInvestorInput = {
    id?: number
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUserInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUserInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutInvestorInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutInvestorInput, userUncheckedCreateWithoutInvestorInput>
  }

  export type userUpsertWithoutInvestorInput = {
    update: XOR<userUpdateWithoutInvestorInput, userUncheckedUpdateWithoutInvestorInput>
    create: XOR<userCreateWithoutInvestorInput, userUncheckedCreateWithoutInvestorInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutInvestorInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutInvestorInput, userUncheckedUpdateWithoutInvestorInput>
  }

  export type userUpdateWithoutInvestorInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUpdateManyWithoutUserNestedInput
    issuer?: issuerUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutInvestorInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUserNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutIssuerInput = {
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    authprovider?: authproviderCreateNestedManyWithoutUserInput
    didwallet?: didwalletCreateNestedManyWithoutUserInput
    investor?: investorCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutIssuerInput = {
    id?: number
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUserInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUserInput
    investor?: investorUncheckedCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutIssuerInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutIssuerInput, userUncheckedCreateWithoutIssuerInput>
  }

  export type offeringCreateWithoutIssuerInput = {
    name: string
    description: string
    target_amount: Decimal | DecimalJsLike | number | string
    minimum_investment: Decimal | DecimalJsLike | number | string
    start_date: Date | string
    end_date: Date | string
    status?: string
    created_at?: Date | string
    updated_at: Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type offeringUncheckedCreateWithoutIssuerInput = {
    id?: number
    name: string
    description: string
    target_amount: Decimal | DecimalJsLike | number | string
    minimum_investment: Decimal | DecimalJsLike | number | string
    start_date: Date | string
    end_date: Date | string
    status?: string
    created_at?: Date | string
    updated_at: Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type offeringCreateOrConnectWithoutIssuerInput = {
    where: offeringWhereUniqueInput
    create: XOR<offeringCreateWithoutIssuerInput, offeringUncheckedCreateWithoutIssuerInput>
  }

  export type offeringCreateManyIssuerInputEnvelope = {
    data: offeringCreateManyIssuerInput | offeringCreateManyIssuerInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutIssuerInput = {
    update: XOR<userUpdateWithoutIssuerInput, userUncheckedUpdateWithoutIssuerInput>
    create: XOR<userCreateWithoutIssuerInput, userUncheckedCreateWithoutIssuerInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutIssuerInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutIssuerInput, userUncheckedUpdateWithoutIssuerInput>
  }

  export type userUpdateWithoutIssuerInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUpdateManyWithoutUserNestedInput
    investor?: investorUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutIssuerInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUserNestedInput
    investor?: investorUncheckedUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type offeringUpsertWithWhereUniqueWithoutIssuerInput = {
    where: offeringWhereUniqueInput
    update: XOR<offeringUpdateWithoutIssuerInput, offeringUncheckedUpdateWithoutIssuerInput>
    create: XOR<offeringCreateWithoutIssuerInput, offeringUncheckedCreateWithoutIssuerInput>
  }

  export type offeringUpdateWithWhereUniqueWithoutIssuerInput = {
    where: offeringWhereUniqueInput
    data: XOR<offeringUpdateWithoutIssuerInput, offeringUncheckedUpdateWithoutIssuerInput>
  }

  export type offeringUpdateManyWithWhereWithoutIssuerInput = {
    where: offeringScalarWhereInput
    data: XOR<offeringUpdateManyMutationInput, offeringUncheckedUpdateManyWithoutIssuerInput>
  }

  export type offeringScalarWhereInput = {
    AND?: offeringScalarWhereInput | offeringScalarWhereInput[]
    OR?: offeringScalarWhereInput[]
    NOT?: offeringScalarWhereInput | offeringScalarWhereInput[]
    id?: IntFilter<"offering"> | number
    issuer_id?: IntFilter<"offering"> | number
    name?: StringFilter<"offering"> | string
    description?: StringFilter<"offering"> | string
    target_amount?: DecimalFilter<"offering"> | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFilter<"offering"> | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFilter<"offering"> | Date | string
    end_date?: DateTimeFilter<"offering"> | Date | string
    status?: StringFilter<"offering"> | string
    created_at?: DateTimeFilter<"offering"> | Date | string
    updated_at?: DateTimeFilter<"offering"> | Date | string
    documents?: JsonNullableFilter<"offering">
  }

  export type issuerCreateWithoutOfferingInput = {
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    wallet_address?: string | null
    wallet_created_at?: Date | string | null
    ethereum_address?: string | null
    ethereum_wallet_created_at?: Date | string | null
    solana_address?: string | null
    solana_wallet_created_at?: Date | string | null
    user: userCreateNestedOneWithoutIssuerInput
  }

  export type issuerUncheckedCreateWithoutOfferingInput = {
    id?: number
    user_id: number
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    wallet_address?: string | null
    wallet_created_at?: Date | string | null
    ethereum_address?: string | null
    ethereum_wallet_created_at?: Date | string | null
    solana_address?: string | null
    solana_wallet_created_at?: Date | string | null
  }

  export type issuerCreateOrConnectWithoutOfferingInput = {
    where: issuerWhereUniqueInput
    create: XOR<issuerCreateWithoutOfferingInput, issuerUncheckedCreateWithoutOfferingInput>
  }

  export type issuerUpsertWithoutOfferingInput = {
    update: XOR<issuerUpdateWithoutOfferingInput, issuerUncheckedUpdateWithoutOfferingInput>
    create: XOR<issuerCreateWithoutOfferingInput, issuerUncheckedCreateWithoutOfferingInput>
    where?: issuerWhereInput
  }

  export type issuerUpdateToOneWithWhereWithoutOfferingInput = {
    where?: issuerWhereInput
    data: XOR<issuerUpdateWithoutOfferingInput, issuerUncheckedUpdateWithoutOfferingInput>
  }

  export type issuerUpdateWithoutOfferingInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ethereum_address?: NullableStringFieldUpdateOperationsInput | string | null
    ethereum_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solana_address?: NullableStringFieldUpdateOperationsInput | string | null
    solana_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutIssuerNestedInput
  }

  export type issuerUncheckedUpdateWithoutOfferingInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ethereum_address?: NullableStringFieldUpdateOperationsInput | string | null
    ethereum_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solana_address?: NullableStringFieldUpdateOperationsInput | string | null
    solana_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userCreateWithoutRefreshtokenInput = {
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    authprovider?: authproviderCreateNestedManyWithoutUserInput
    didwallet?: didwalletCreateNestedManyWithoutUserInput
    investor?: investorCreateNestedOneWithoutUserInput
    issuer?: issuerCreateNestedOneWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutRefreshtokenInput = {
    id?: number
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUserInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUserInput
    investor?: investorUncheckedCreateNestedOneWithoutUserInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRefreshtokenInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRefreshtokenInput, userUncheckedCreateWithoutRefreshtokenInput>
  }

  export type userUpsertWithoutRefreshtokenInput = {
    update: XOR<userUpdateWithoutRefreshtokenInput, userUncheckedUpdateWithoutRefreshtokenInput>
    create: XOR<userCreateWithoutRefreshtokenInput, userUncheckedCreateWithoutRefreshtokenInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRefreshtokenInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRefreshtokenInput, userUncheckedUpdateWithoutRefreshtokenInput>
  }

  export type userUpdateWithoutRefreshtokenInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUpdateManyWithoutUserNestedInput
    investor?: investorUpdateOneWithoutUserNestedInput
    issuer?: issuerUpdateOneWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRefreshtokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUserNestedInput
    investor?: investorUncheckedUpdateOneWithoutUserNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type adminCreateWithoutUserInput = {
    department: string
    position: string
    last_login?: Date | string | null
  }

  export type adminUncheckedCreateWithoutUserInput = {
    id?: number
    department: string
    position: string
    last_login?: Date | string | null
  }

  export type adminCreateOrConnectWithoutUserInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
  }

  export type authproviderCreateWithoutUserInput = {
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type authproviderUncheckedCreateWithoutUserInput = {
    id?: number
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type authproviderCreateOrConnectWithoutUserInput = {
    where: authproviderWhereUniqueInput
    create: XOR<authproviderCreateWithoutUserInput, authproviderUncheckedCreateWithoutUserInput>
  }

  export type authproviderCreateManyUserInputEnvelope = {
    data: authproviderCreateManyUserInput | authproviderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type didwalletCreateWithoutUserInput = {
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletUncheckedCreateWithoutUserInput = {
    id?: number
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletCreateOrConnectWithoutUserInput = {
    where: didwalletWhereUniqueInput
    create: XOR<didwalletCreateWithoutUserInput, didwalletUncheckedCreateWithoutUserInput>
  }

  export type didwalletCreateManyUserInputEnvelope = {
    data: didwalletCreateManyUserInput | didwalletCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type investorCreateWithoutUserInput = {
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorUncheckedCreateWithoutUserInput = {
    id?: number
    investor_type: string
    accreditation_status: string
    accreditation_date?: Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: boolean
    aml_verified?: boolean
  }

  export type investorCreateOrConnectWithoutUserInput = {
    where: investorWhereUniqueInput
    create: XOR<investorCreateWithoutUserInput, investorUncheckedCreateWithoutUserInput>
  }

  export type issuerCreateWithoutUserInput = {
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    wallet_address?: string | null
    wallet_created_at?: Date | string | null
    ethereum_address?: string | null
    ethereum_wallet_created_at?: Date | string | null
    solana_address?: string | null
    solana_wallet_created_at?: Date | string | null
    offering?: offeringCreateNestedManyWithoutIssuerInput
  }

  export type issuerUncheckedCreateWithoutUserInput = {
    id?: number
    company_name: string
    company_registration_number: string
    jurisdiction: string
    verification_status?: boolean
    verification_date?: Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    wallet_address?: string | null
    wallet_created_at?: Date | string | null
    ethereum_address?: string | null
    ethereum_wallet_created_at?: Date | string | null
    solana_address?: string | null
    solana_wallet_created_at?: Date | string | null
    offering?: offeringUncheckedCreateNestedManyWithoutIssuerInput
  }

  export type issuerCreateOrConnectWithoutUserInput = {
    where: issuerWhereUniqueInput
    create: XOR<issuerCreateWithoutUserInput, issuerUncheckedCreateWithoutUserInput>
  }

  export type refreshtokenCreateWithoutUserInput = {
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type refreshtokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type refreshtokenCreateOrConnectWithoutUserInput = {
    where: refreshtokenWhereUniqueInput
    create: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput>
  }

  export type refreshtokenCreateManyUserInputEnvelope = {
    data: refreshtokenCreateManyUserInput | refreshtokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userroleCreateWithoutUserInput = {
    role: string
    created_at?: Date | string
  }

  export type userroleUncheckedCreateWithoutUserInput = {
    id?: number
    role: string
    created_at?: Date | string
  }

  export type userroleCreateOrConnectWithoutUserInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleCreateManyUserInputEnvelope = {
    data: userroleCreateManyUserInput | userroleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type adminUpsertWithoutUserInput = {
    update: XOR<adminUpdateWithoutUserInput, adminUncheckedUpdateWithoutUserInput>
    create: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutUserInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutUserInput, adminUncheckedUpdateWithoutUserInput>
  }

  export type adminUpdateWithoutUserInput = {
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type adminUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    department?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    last_login?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type authproviderUpsertWithWhereUniqueWithoutUserInput = {
    where: authproviderWhereUniqueInput
    update: XOR<authproviderUpdateWithoutUserInput, authproviderUncheckedUpdateWithoutUserInput>
    create: XOR<authproviderCreateWithoutUserInput, authproviderUncheckedCreateWithoutUserInput>
  }

  export type authproviderUpdateWithWhereUniqueWithoutUserInput = {
    where: authproviderWhereUniqueInput
    data: XOR<authproviderUpdateWithoutUserInput, authproviderUncheckedUpdateWithoutUserInput>
  }

  export type authproviderUpdateManyWithWhereWithoutUserInput = {
    where: authproviderScalarWhereInput
    data: XOR<authproviderUpdateManyMutationInput, authproviderUncheckedUpdateManyWithoutUserInput>
  }

  export type authproviderScalarWhereInput = {
    AND?: authproviderScalarWhereInput | authproviderScalarWhereInput[]
    OR?: authproviderScalarWhereInput[]
    NOT?: authproviderScalarWhereInput | authproviderScalarWhereInput[]
    id?: IntFilter<"authprovider"> | number
    user_id?: IntFilter<"authprovider"> | number
    provider_name?: StringFilter<"authprovider"> | string
    provider_user_id?: StringFilter<"authprovider"> | string
    provider_data?: JsonNullableFilter<"authprovider">
    created_at?: DateTimeFilter<"authprovider"> | Date | string
    last_used?: DateTimeFilter<"authprovider"> | Date | string
  }

  export type didwalletUpsertWithWhereUniqueWithoutUserInput = {
    where: didwalletWhereUniqueInput
    update: XOR<didwalletUpdateWithoutUserInput, didwalletUncheckedUpdateWithoutUserInput>
    create: XOR<didwalletCreateWithoutUserInput, didwalletUncheckedCreateWithoutUserInput>
  }

  export type didwalletUpdateWithWhereUniqueWithoutUserInput = {
    where: didwalletWhereUniqueInput
    data: XOR<didwalletUpdateWithoutUserInput, didwalletUncheckedUpdateWithoutUserInput>
  }

  export type didwalletUpdateManyWithWhereWithoutUserInput = {
    where: didwalletScalarWhereInput
    data: XOR<didwalletUpdateManyMutationInput, didwalletUncheckedUpdateManyWithoutUserInput>
  }

  export type didwalletScalarWhereInput = {
    AND?: didwalletScalarWhereInput | didwalletScalarWhereInput[]
    OR?: didwalletScalarWhereInput[]
    NOT?: didwalletScalarWhereInput | didwalletScalarWhereInput[]
    id?: IntFilter<"didwallet"> | number
    user_id?: IntFilter<"didwallet"> | number
    wallet_address?: StringFilter<"didwallet"> | string
    did?: StringFilter<"didwallet"> | string
    is_primary?: BoolFilter<"didwallet"> | boolean
    created_at?: DateTimeFilter<"didwallet"> | Date | string
    last_used?: DateTimeFilter<"didwallet"> | Date | string
  }

  export type investorUpsertWithoutUserInput = {
    update: XOR<investorUpdateWithoutUserInput, investorUncheckedUpdateWithoutUserInput>
    create: XOR<investorCreateWithoutUserInput, investorUncheckedCreateWithoutUserInput>
    where?: investorWhereInput
  }

  export type investorUpdateToOneWithWhereWithoutUserInput = {
    where?: investorWhereInput
    data: XOR<investorUpdateWithoutUserInput, investorUncheckedUpdateWithoutUserInput>
  }

  export type investorUpdateWithoutUserInput = {
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type investorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    investor_type?: StringFieldUpdateOperationsInput | string
    accreditation_status?: StringFieldUpdateOperationsInput | string
    accreditation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kyc_documents?: NullableJsonNullValueInput | InputJsonValue
    aml_documents?: NullableJsonNullValueInput | InputJsonValue
    kyc_verified?: BoolFieldUpdateOperationsInput | boolean
    aml_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type issuerUpsertWithoutUserInput = {
    update: XOR<issuerUpdateWithoutUserInput, issuerUncheckedUpdateWithoutUserInput>
    create: XOR<issuerCreateWithoutUserInput, issuerUncheckedCreateWithoutUserInput>
    where?: issuerWhereInput
  }

  export type issuerUpdateToOneWithWhereWithoutUserInput = {
    where?: issuerWhereInput
    data: XOR<issuerUpdateWithoutUserInput, issuerUncheckedUpdateWithoutUserInput>
  }

  export type issuerUpdateWithoutUserInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ethereum_address?: NullableStringFieldUpdateOperationsInput | string | null
    ethereum_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solana_address?: NullableStringFieldUpdateOperationsInput | string | null
    solana_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offering?: offeringUpdateManyWithoutIssuerNestedInput
  }

  export type issuerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: StringFieldUpdateOperationsInput | string
    company_registration_number?: StringFieldUpdateOperationsInput | string
    jurisdiction?: StringFieldUpdateOperationsInput | string
    verification_status?: BoolFieldUpdateOperationsInput | boolean
    verification_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_documents?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ethereum_address?: NullableStringFieldUpdateOperationsInput | string | null
    ethereum_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    solana_address?: NullableStringFieldUpdateOperationsInput | string | null
    solana_wallet_created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offering?: offeringUncheckedUpdateManyWithoutIssuerNestedInput
  }

  export type refreshtokenUpsertWithWhereUniqueWithoutUserInput = {
    where: refreshtokenWhereUniqueInput
    update: XOR<refreshtokenUpdateWithoutUserInput, refreshtokenUncheckedUpdateWithoutUserInput>
    create: XOR<refreshtokenCreateWithoutUserInput, refreshtokenUncheckedCreateWithoutUserInput>
  }

  export type refreshtokenUpdateWithWhereUniqueWithoutUserInput = {
    where: refreshtokenWhereUniqueInput
    data: XOR<refreshtokenUpdateWithoutUserInput, refreshtokenUncheckedUpdateWithoutUserInput>
  }

  export type refreshtokenUpdateManyWithWhereWithoutUserInput = {
    where: refreshtokenScalarWhereInput
    data: XOR<refreshtokenUpdateManyMutationInput, refreshtokenUncheckedUpdateManyWithoutUserInput>
  }

  export type refreshtokenScalarWhereInput = {
    AND?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
    OR?: refreshtokenScalarWhereInput[]
    NOT?: refreshtokenScalarWhereInput | refreshtokenScalarWhereInput[]
    id?: IntFilter<"refreshtoken"> | number
    user_id?: IntFilter<"refreshtoken"> | number
    token?: StringFilter<"refreshtoken"> | string
    expires_at?: DateTimeFilter<"refreshtoken"> | Date | string
    created_at?: DateTimeFilter<"refreshtoken"> | Date | string
    device_info?: StringNullableFilter<"refreshtoken"> | string | null
  }

  export type userroleUpsertWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
  }

  export type userroleUpdateManyWithWhereWithoutUserInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutUserInput>
  }

  export type userroleScalarWhereInput = {
    AND?: userroleScalarWhereInput | userroleScalarWhereInput[]
    OR?: userroleScalarWhereInput[]
    NOT?: userroleScalarWhereInput | userroleScalarWhereInput[]
    id?: IntFilter<"userrole"> | number
    user_id?: IntFilter<"userrole"> | number
    role?: StringFilter<"userrole"> | string
    created_at?: DateTimeFilter<"userrole"> | Date | string
  }

  export type userCreateWithoutUserroleInput = {
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    authprovider?: authproviderCreateNestedManyWithoutUserInput
    didwallet?: didwalletCreateNestedManyWithoutUserInput
    investor?: investorCreateNestedOneWithoutUserInput
    issuer?: issuerCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserroleInput = {
    id?: number
    email: string
    password_hash?: string | null
    first_name: string
    last_name: string
    created_at?: Date | string
    updated_at: Date | string
    email_verified?: boolean
    profile_image?: string | null
    phone_number?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    authprovider?: authproviderUncheckedCreateNestedManyWithoutUserInput
    didwallet?: didwalletUncheckedCreateNestedManyWithoutUserInput
    investor?: investorUncheckedCreateNestedOneWithoutUserInput
    issuer?: issuerUncheckedCreateNestedOneWithoutUserInput
    refreshtoken?: refreshtokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserroleInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
  }

  export type userUpsertWithoutUserroleInput = {
    update: XOR<userUpdateWithoutUserroleInput, userUncheckedUpdateWithoutUserroleInput>
    create: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserroleInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserroleInput, userUncheckedUpdateWithoutUserroleInput>
  }

  export type userUpdateWithoutUserroleInput = {
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUpdateManyWithoutUserNestedInput
    investor?: investorUpdateOneWithoutUserNestedInput
    issuer?: issuerUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserroleInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: NullableStringFieldUpdateOperationsInput | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email_verified?: BoolFieldUpdateOperationsInput | boolean
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    authprovider?: authproviderUncheckedUpdateManyWithoutUserNestedInput
    didwallet?: didwalletUncheckedUpdateManyWithoutUserNestedInput
    investor?: investorUncheckedUpdateOneWithoutUserNestedInput
    issuer?: issuerUncheckedUpdateOneWithoutUserNestedInput
    refreshtoken?: refreshtokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type offeringCreateManyIssuerInput = {
    id?: number
    name: string
    description: string
    target_amount: Decimal | DecimalJsLike | number | string
    minimum_investment: Decimal | DecimalJsLike | number | string
    start_date: Date | string
    end_date: Date | string
    status?: string
    created_at?: Date | string
    updated_at: Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type offeringUpdateWithoutIssuerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    target_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type offeringUncheckedUpdateWithoutIssuerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    target_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type offeringUncheckedUpdateManyWithoutIssuerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    target_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minimum_investment?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: NullableJsonNullValueInput | InputJsonValue
  }

  export type authproviderCreateManyUserInput = {
    id?: number
    provider_name: string
    provider_user_id: string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    last_used: Date | string
  }

  export type didwalletCreateManyUserInput = {
    id?: number
    wallet_address: string
    did: string
    is_primary?: boolean
    created_at?: Date | string
    last_used: Date | string
  }

  export type refreshtokenCreateManyUserInput = {
    id?: number
    token: string
    expires_at: Date | string
    created_at?: Date | string
    device_info?: string | null
  }

  export type userroleCreateManyUserInput = {
    id?: number
    role: string
    created_at?: Date | string
  }

  export type authproviderUpdateWithoutUserInput = {
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authproviderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authproviderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    provider_user_id?: StringFieldUpdateOperationsInput | string
    provider_data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletUpdateWithoutUserInput = {
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type didwalletUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    wallet_address?: StringFieldUpdateOperationsInput | string
    did?: StringFieldUpdateOperationsInput | string
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_used?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type refreshtokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refreshtokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type refreshtokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userroleUpdateWithoutUserInput = {
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use IssuerCountOutputTypeDefaultArgs instead
     */
    export type IssuerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IssuerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use adminDefaultArgs instead
     */
    export type adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = adminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use authproviderDefaultArgs instead
     */
    export type authproviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = authproviderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use didwalletDefaultArgs instead
     */
    export type didwalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = didwalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use investorDefaultArgs instead
     */
    export type investorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = investorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use issuerDefaultArgs instead
     */
    export type issuerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = issuerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use offeringDefaultArgs instead
     */
    export type offeringArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = offeringDefaultArgs<ExtArgs>
    /**
     * @deprecated Use refreshtokenDefaultArgs instead
     */
    export type refreshtokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = refreshtokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userDefaultArgs instead
     */
    export type userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use userroleDefaultArgs instead
     */
    export type userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = userroleDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}